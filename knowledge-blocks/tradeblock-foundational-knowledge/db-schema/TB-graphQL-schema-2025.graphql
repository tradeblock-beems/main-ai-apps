schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""Offer item data for a specific inventory item."""
input AcceptOfferInventoryItem {
  inventoryItemId: String!
}

"""Returns the ID of the new bank account."""
type AddBankAccountResult {
  id: String!
}

type Address {
  city: String
  country: String
  externalId: String
  state: String
  street1: String
  street2: String
  zip: String
}

"""Input parameters to create or update an address record."""
input AddressInput {
  city: String!
  country: String!
  firstName: String
  isBillingDefault: Boolean!
  isShippingDefault: Boolean!
  lastName: String
  name: String!
  state: String!
  street: String!
  zip: String!
}

"""
Returns error if address is invalid, success as false if there are suggestions, and success as true if the address was created or updated.
"""
type AddressResponse {
  addressId: String
  responseId: String
  success: Boolean!
  suggestedAddress: SuggestedAddress
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

type BillingDetails {
  address: Address!
  name: String
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""Checkout details for an offer."""
input CheckoutDetails {
  coverPartnerAuthentication: Boolean
  inboundInsurance: Boolean!
  outboundInsurance: Boolean!
  partnerInsuranceAmount: Int
  paymentMethodId: String!
  shippingAddressId: String!
}

"""Returns the closet value and percentile of the user."""
type ClosetValue {
  hasPricingIssues: Boolean!
  percentile: Float!
  value: Float!
}

type CollectorTradeStats {
  authIssuesCount: Int!
  completedTradesCount: Int!
  failedToShipCount: Int!
  qcIssuesCount: Int!
  totalTradesCount: Int!
}

type Customer {
  balance: Int!
  defaultPaymentMethod: String
  id: String!
}

type CustomerPaymentMethodResourceList {
  data: [PaymentMethod]!
  hasMore: Boolean!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type DeletedExternalAccount {
  deleted: Boolean!
  id: String!
}

type ExternalAccount {
  bankName: String!
  default: Boolean!
  id: String!
  lastFour: String!
}

type ExternalAccountsResourceList {
  data: [ExternalAccount]!
  hasMore: Boolean!
}

type GetCollectorTradeStatsResponse {
  consideredTradesStats: CollectorTradeStats!
  consideredTradesStatsDate: DateTime
  ignoredTradesStats: CollectorTradeStats
}

type GetRevertTradeStepsResponse {
  revertTradeSteps: [RevertTradeStepType!]!
}

"""Returns the current health status of the application."""
type Health {
  ok: Boolean!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""Returns the created file ID."""
type NotifyUploadedFileResult {
  id: String!
}

"""An offer."""
type Offer {
  id: String!
}

"""Applied offer discount type."""
enum OfferDiscountType {
  bounty
  firstPurchase
  firstTrade
  freeSell
  promoPurchase
  promoSell
}

"""Offer earnings & line items."""
type OfferEarnings {
  additionalShoesFee: Float!
  cash: Float!
  discountType: OfferDiscountType
  earnings: Float!
  earningsBeforeTax: Float!
  fees: Float!
  insureToValidator: Float!
  serviceFee: Float!
  serviceFeeDiscount: Float
  tax: Float!
  withdrawFromWallet: Float!
}

"""Input parameters to calculate offer earnings."""
input OfferEarningsInput {
  cash: Float!
  inboundInsurance: Boolean!
  itemsForSellCount: Int!
  offerId: String
  productVariantIds: [String!]
}

"""An idea for an offer."""
type OfferIdea {
  cash: Float!
  creatorItems: [OfferIdeaCreatorItem!]!
  creatorItemsValue: Float!
  hasMore: Boolean
  offerKey: String!
  receiverItems: [OfferIdeaReceiverItem!]!
  receiverItemsValue: Float!
  signature: String!
}

"""A creator item for an offer idea."""
type OfferIdeaCreatorItem {
  condition: String!
  hasDefects: Boolean!
  imageUrl: String!
  inventoryItemId: String!
  name: String!
  size: String!
  sizing: String!
}

"""A receiver item for an offer idea."""
type OfferIdeaReceiverItem {
  condition: String!
  hasDefects: Boolean!
  imageUrl: String!
  inventoryItemId: String
  name: String!
  productVariantId: String!
  size: String!
  sizing: String!
}

"""Offer idea paginated response."""
type OfferIdeasPaginated {
  count: Int!
  items: [OfferIdea]!
}

"""Offer item for a specific inventory item."""
input OfferInventoryItem {
  inventoryItemId: String!
  productVariantId: String!
}

"""Offer item for sell."""
input OfferItemForSell {
  inventoryItemId: String
  productVariantId: String!
}

""""""
input OfferItemIssue {
  note: String
  pictureIds: [String!]
  subject: String!
  types: [String!]!
}

"""Owner for the offer item."""
enum OfferItemOwner {
  Creator
  Receiver
}

"""Offer total & line items."""
type OfferTotal {
  additionalShoesFee: Float!
  bountyReward: Float!
  discountType: OfferDiscountType
  extraCash: Float!
  fees: Float!
  insureToCollector: Float!
  insureToValidator: Float!
  isTrustedTrader: Boolean!
  partnerAdditionalAuthShoesFee: Float!
  partnerAuthFee: Float!
  partnerInsuranceFee: Float!
  serviceFee: Float!
  serviceFeeDiscount: Float
  shipping: Float!
  shippingDiscount: Float
  tax: Float!
  total: Float!
  totalBeforeTax: Float!
  withdrawFromWallet: Float!
}

"""Input parameters to calculate offer total."""
input OfferTotalInput {
  creatorCash: Float!
  creatorInboundInsurance: Boolean!
  creatorItemsCount: Int!
  creatorOutboundInsurance: Boolean!
  creatorShippingAddressId: String!
  isOfferIdea: Boolean
  offerId: String
  offerReceiverId: String
  productVariantIds: [String!]
  receiverCash: Float!
}

"""Array of offer total & line items."""
type OfferTotalMany {
  totalMany: [OfferTotal!]!
}

"""Offer transaction."""
type OfferTransaction {
  acceptedAtISO: String
  createdAtISO: String!
  creatorTerms: OfferTransactionTerm!
  isArbitOrigin: Boolean
  isPublic: Boolean!
  offerId: String!
  productUrl: String
  receiverTerms: OfferTransactionTerm!
  transactionType: OfferTransactionTypeInput!
}

"""Offer transaction mode."""
enum OfferTransactionMode {
  completed
  lowest_ask
}

"""Offer transaction term."""
type OfferTransactionTerm {
  addedCash: Float!
  estimatedValue: Float
  items: [OfferTransactionTermOfferItem]
}

"""Transaction offer item."""
type OfferTransactionTermOfferItem {
  condition: String
  productId: String!
  size: Float!
  sku: String!
}

"""Available offer transaction types."""
enum OfferTransactionTypeInput {
  BUY
  EXCHANGE
  SELL
}

"""Array of offer transaction."""
type OfferTransactions {
  data: [OfferTransaction!]!
}

"""Available offer types."""
enum OfferTypeInput {
  PRIVATE
  PUBLIC
}

type PaymentMethod {
  card: PaymentMethodCard
  customName: String
  default: Boolean!
  id: String!
  verificationStatus: String
  verified: Boolean!
}

type PaymentMethodCard {
  billingDetails: BillingDetails!
  brand: String!
  expMonth: Int!
  expYear: Int!
  fingerprint: String
  lastFour: String!
  wallet: Wallet
}

type PresignedUploadPost {
  fields: [PresignedUploadPostField!]!
  path: String!
  url: String!
}

"""Name and value pair for a POST field."""
type PresignedUploadPostField {
  name: String!
  value: String!
}

"""Offer item for a specific inventory item."""
input PrivateOfferItem {
  inventoryItemId: String!
  owner: OfferItemOwner!
  productVariantId: String!
}

"""Input for creating a public offer."""
input PublicOfferInput {
  creatorCash: Float!
  creatorCheckoutDetails: CheckoutDetails!
  creatorItems: [OfferInventoryItem!]!
  editedOfferId: String
  offerIdeaSignature: String
  receiverCash: Float!
  receiverItems: [PublicOfferVariantItem!]!
  skipDuplicateOfferCheck: Boolean
}

"""Offer item for a generic product variant."""
input PublicOfferVariantItem {
  productVariantId: String!
}

"""Revert Trade Step."""
enum RevertTradeStepType {
  PRE_MEMBER_REVIEW
  PRE_VALIDATION
}

"""Response for sending an otp."""
type SendOtpResponse {
  last4: String!
}

"""A smart idea batch."""
type SmartOfferIdeaBatch {
  items: [OfferIdea]!
  startAt: String!
}

"""Input for todays pick inventory"""
input SmartOfferIdeaCreatorInventoryPair {
  inventoryItemIds: [String!]!
}

"""A smart ideas batch list"""
type SmartOfferIdeas {
  items: [SmartOfferIdeaBatch]!
  key: String!
}

"""Available social authentication providers."""
enum SocialAuthProvider {
  Apple
  Google
}

"""Returns the current status of the application."""
type Status {
  chargeActualShippingFee: Boolean!
  maintenanceModeEnabled: Boolean!
  privateOfferDaysToExpire: Int!
  publicOfferDaysToExpire: Int!
  shippingBillingAlertUrl: String!
  trustedPartnerAdditionalShoesFee: Float!
  trustedPartnerAuthenticationFee: Float!
  trustedPartnerInsuranceAmountCap: Float!
  trustedPartnerInsuranceFreeAmount: Float!
  trustedPartnerInsurancePerDollarPrice: Float!
  versionAndroid: String!
  versionIOS: String!
  weeklyPurchaseLimit: Int!
  weeklyPurchaseLimitEnabled: Boolean!
}

input StrapiBooleanFilterInput {
  and: [Boolean]
  between: [Boolean]
  contains: Boolean
  containsi: Boolean
  endsWith: Boolean
  eq: Boolean
  eqi: Boolean
  gt: Boolean
  gte: Boolean
  in: [Boolean]
  lt: Boolean
  lte: Boolean
  ne: Boolean
  nei: Boolean
  not: StrapiBooleanFilterInput
  notContains: Boolean
  notContainsi: Boolean
  notIn: [Boolean]
  notNull: Boolean
  null: Boolean
  or: [Boolean]
  startsWith: Boolean
}

type StrapiComponentUiConfigurationBreakpoints {
  id: ID!
  value: StrapiENUM_COMPONENTUICONFIGURATIONBREAKPOINTS_VALUE
}

input StrapiComponentUiConfigurationBreakpointsFiltersInput {
  and: [StrapiComponentUiConfigurationBreakpointsFiltersInput]
  not: StrapiComponentUiConfigurationBreakpointsFiltersInput
  or: [StrapiComponentUiConfigurationBreakpointsFiltersInput]
  value: StrapiStringFilterInput
}

input StrapiComponentUiConfigurationBreakpointsInput {
  id: ID
  value: StrapiENUM_COMPONENTUICONFIGURATIONBREAKPOINTS_VALUE
}

type StrapiComponentUiConfigurationMarketingBannerItem {
  backgroundColor: String
  breakpoints(filters: StrapiComponentUiConfigurationBreakpointsFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): [StrapiComponentUiConfigurationBreakpoints]
  height: Int
  id: ID!
  marketingBannerItemContent(filters: StrapiComponentUiConfigurationMarketingBannerItemContentFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): [StrapiComponentUiConfigurationMarketingBannerItemContent]
  name: String
}

type StrapiComponentUiConfigurationMarketingBannerItemContent {
  backgroundColor: String
  id: ID!
  linkUrl: String!
  mainImage: StrapiUploadFileEntityResponse
  openInModal: Boolean
  openInNewWindow: Boolean
}

input StrapiComponentUiConfigurationMarketingBannerItemContentFiltersInput {
  and: [StrapiComponentUiConfigurationMarketingBannerItemContentFiltersInput]
  backgroundColor: StrapiStringFilterInput
  linkUrl: StrapiStringFilterInput
  not: StrapiComponentUiConfigurationMarketingBannerItemContentFiltersInput
  openInModal: StrapiBooleanFilterInput
  openInNewWindow: StrapiBooleanFilterInput
  or: [StrapiComponentUiConfigurationMarketingBannerItemContentFiltersInput]
}

input StrapiComponentUiConfigurationMarketingBannerItemContentInput {
  backgroundColor: String
  id: ID
  linkUrl: String
  mainImage: ID
  openInModal: Boolean
  openInNewWindow: Boolean
}

input StrapiComponentUiConfigurationMarketingBannerItemFiltersInput {
  and: [StrapiComponentUiConfigurationMarketingBannerItemFiltersInput]
  backgroundColor: StrapiStringFilterInput
  breakpoints: StrapiComponentUiConfigurationBreakpointsFiltersInput
  height: StrapiIntFilterInput
  marketingBannerItemContent: StrapiComponentUiConfigurationMarketingBannerItemContentFiltersInput
  name: StrapiStringFilterInput
  not: StrapiComponentUiConfigurationMarketingBannerItemFiltersInput
  or: [StrapiComponentUiConfigurationMarketingBannerItemFiltersInput]
}

input StrapiComponentUiConfigurationMarketingBannerItemInput {
  backgroundColor: String
  breakpoints: [StrapiComponentUiConfigurationBreakpointsInput]
  height: Int
  id: ID
  marketingBannerItemContent: [StrapiComponentUiConfigurationMarketingBannerItemContentInput]
  name: String
}

type StrapiContentReleasesRelease {
  actions(filters: StrapiContentReleasesReleaseActionFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiContentReleasesReleaseActionRelationResponseCollection
  createdAt: StrapiDateTime
  name: String!
  releasedAt: StrapiDateTime
  scheduledAt: StrapiDateTime
  timezone: String
  updatedAt: StrapiDateTime
}

type StrapiContentReleasesReleaseAction {
  contentType: String!
  createdAt: StrapiDateTime
  entry: StrapiGenericMorph
  locale: String
  release: StrapiContentReleasesReleaseEntityResponse
  type: StrapiENUM_CONTENTRELEASESRELEASEACTION_TYPE!
  updatedAt: StrapiDateTime
}

type StrapiContentReleasesReleaseActionEntity {
  attributes: StrapiContentReleasesReleaseAction
  id: ID
}

type StrapiContentReleasesReleaseActionEntityResponse {
  data: StrapiContentReleasesReleaseActionEntity
}

type StrapiContentReleasesReleaseActionEntityResponseCollection {
  data: [StrapiContentReleasesReleaseActionEntity!]!
  meta: StrapiResponseCollectionMeta!
}

input StrapiContentReleasesReleaseActionFiltersInput {
  and: [StrapiContentReleasesReleaseActionFiltersInput]
  contentType: StrapiStringFilterInput
  createdAt: StrapiDateTimeFilterInput
  id: StrapiIDFilterInput
  locale: StrapiStringFilterInput
  not: StrapiContentReleasesReleaseActionFiltersInput
  or: [StrapiContentReleasesReleaseActionFiltersInput]
  release: StrapiContentReleasesReleaseFiltersInput
  type: StrapiStringFilterInput
  updatedAt: StrapiDateTimeFilterInput
}

input StrapiContentReleasesReleaseActionInput {
  contentType: String
  locale: String
  release: ID
  type: StrapiENUM_CONTENTRELEASESRELEASEACTION_TYPE
}

type StrapiContentReleasesReleaseActionRelationResponseCollection {
  data: [StrapiContentReleasesReleaseActionEntity!]!
}

type StrapiContentReleasesReleaseEntity {
  attributes: StrapiContentReleasesRelease
  id: ID
}

type StrapiContentReleasesReleaseEntityResponse {
  data: StrapiContentReleasesReleaseEntity
}

type StrapiContentReleasesReleaseEntityResponseCollection {
  data: [StrapiContentReleasesReleaseEntity!]!
  meta: StrapiResponseCollectionMeta!
}

input StrapiContentReleasesReleaseFiltersInput {
  actions: StrapiContentReleasesReleaseActionFiltersInput
  and: [StrapiContentReleasesReleaseFiltersInput]
  createdAt: StrapiDateTimeFilterInput
  id: StrapiIDFilterInput
  name: StrapiStringFilterInput
  not: StrapiContentReleasesReleaseFiltersInput
  or: [StrapiContentReleasesReleaseFiltersInput]
  releasedAt: StrapiDateTimeFilterInput
  scheduledAt: StrapiDateTimeFilterInput
  timezone: StrapiStringFilterInput
  updatedAt: StrapiDateTimeFilterInput
}

input StrapiContentReleasesReleaseInput {
  actions: [ID]
  name: String
  releasedAt: StrapiDateTime
  scheduledAt: StrapiDateTime
  timezone: String
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar StrapiDateTime

input StrapiDateTimeFilterInput {
  and: [StrapiDateTime]
  between: [StrapiDateTime]
  contains: StrapiDateTime
  containsi: StrapiDateTime
  endsWith: StrapiDateTime
  eq: StrapiDateTime
  eqi: StrapiDateTime
  gt: StrapiDateTime
  gte: StrapiDateTime
  in: [StrapiDateTime]
  lt: StrapiDateTime
  lte: StrapiDateTime
  ne: StrapiDateTime
  nei: StrapiDateTime
  not: StrapiDateTimeFilterInput
  notContains: StrapiDateTime
  notContainsi: StrapiDateTime
  notIn: [StrapiDateTime]
  notNull: Boolean
  null: Boolean
  or: [StrapiDateTime]
  startsWith: StrapiDateTime
}

enum StrapiENUM_COMPONENTUICONFIGURATIONBREAKPOINTS_VALUE {
  lg
  md
  sm
  xl
  xs
}

enum StrapiENUM_CONTENTRELEASESRELEASEACTION_TYPE {
  publish
  unpublish
}

type StrapiEntityNotesNote {
  content: String
  createdAt: StrapiDateTime
  entityId: Int
  entitySlug: String
  title: String
  updatedAt: StrapiDateTime
}

type StrapiEntityNotesNoteEntity {
  attributes: StrapiEntityNotesNote
  id: ID
}

type StrapiEntityNotesNoteEntityResponse {
  data: StrapiEntityNotesNoteEntity
}

type StrapiEntityNotesNoteEntityResponseCollection {
  data: [StrapiEntityNotesNoteEntity!]!
  meta: StrapiResponseCollectionMeta!
}

input StrapiEntityNotesNoteFiltersInput {
  and: [StrapiEntityNotesNoteFiltersInput]
  content: StrapiStringFilterInput
  createdAt: StrapiDateTimeFilterInput
  entityId: StrapiIntFilterInput
  entitySlug: StrapiStringFilterInput
  id: StrapiIDFilterInput
  not: StrapiEntityNotesNoteFiltersInput
  or: [StrapiEntityNotesNoteFiltersInput]
  title: StrapiStringFilterInput
  updatedAt: StrapiDateTimeFilterInput
}

input StrapiEntityNotesNoteInput {
  content: String
  entityId: Int
  entitySlug: String
  title: String
}

input StrapiFileInfoInput {
  alternativeText: String
  caption: String
  name: String
}

input StrapiFloatFilterInput {
  and: [Float]
  between: [Float]
  contains: Float
  containsi: Float
  endsWith: Float
  eq: Float
  eqi: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  ne: Float
  nei: Float
  not: StrapiFloatFilterInput
  notContains: Float
  notContainsi: Float
  notIn: [Float]
  notNull: Boolean
  null: Boolean
  or: [Float]
  startsWith: Float
}

union StrapiGenericMorph = StrapiComponentUiConfigurationBreakpoints | StrapiComponentUiConfigurationMarketingBannerItem | StrapiComponentUiConfigurationMarketingBannerItemContent | StrapiContentReleasesRelease | StrapiContentReleasesReleaseAction | StrapiEntityNotesNote | StrapiI18NLocale | StrapiMarketingBanner | StrapiUploadFile | StrapiUploadFolder | StrapiUsersPermissionsPermission | StrapiUsersPermissionsRole | StrapiUsersPermissionsUser

type StrapiI18NLocale {
  code: String
  createdAt: StrapiDateTime
  name: String
  updatedAt: StrapiDateTime
}

type StrapiI18NLocaleEntity {
  attributes: StrapiI18NLocale
  id: ID
}

type StrapiI18NLocaleEntityResponse {
  data: StrapiI18NLocaleEntity
}

type StrapiI18NLocaleEntityResponseCollection {
  data: [StrapiI18NLocaleEntity!]!
  meta: StrapiResponseCollectionMeta!
}

input StrapiI18NLocaleFiltersInput {
  and: [StrapiI18NLocaleFiltersInput]
  code: StrapiStringFilterInput
  createdAt: StrapiDateTimeFilterInput
  id: StrapiIDFilterInput
  name: StrapiStringFilterInput
  not: StrapiI18NLocaleFiltersInput
  or: [StrapiI18NLocaleFiltersInput]
  updatedAt: StrapiDateTimeFilterInput
}

input StrapiIDFilterInput {
  and: [ID]
  between: [ID]
  contains: ID
  containsi: ID
  endsWith: ID
  eq: ID
  eqi: ID
  gt: ID
  gte: ID
  in: [ID]
  lt: ID
  lte: ID
  ne: ID
  nei: ID
  not: StrapiIDFilterInput
  notContains: ID
  notContainsi: ID
  notIn: [ID]
  notNull: Boolean
  null: Boolean
  or: [ID]
  startsWith: ID
}

input StrapiIntFilterInput {
  and: [Int]
  between: [Int]
  contains: Int
  containsi: Int
  endsWith: Int
  eq: Int
  eqi: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  ne: Int
  nei: Int
  not: StrapiIntFilterInput
  notContains: Int
  notContainsi: Int
  notIn: [Int]
  notNull: Boolean
  null: Boolean
  or: [Int]
  startsWith: Int
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar StrapiJSON

input StrapiJSONFilterInput {
  and: [StrapiJSON]
  between: [StrapiJSON]
  contains: StrapiJSON
  containsi: StrapiJSON
  endsWith: StrapiJSON
  eq: StrapiJSON
  eqi: StrapiJSON
  gt: StrapiJSON
  gte: StrapiJSON
  in: [StrapiJSON]
  lt: StrapiJSON
  lte: StrapiJSON
  ne: StrapiJSON
  nei: StrapiJSON
  not: StrapiJSONFilterInput
  notContains: StrapiJSON
  notContainsi: StrapiJSON
  notIn: [StrapiJSON]
  notNull: Boolean
  null: Boolean
  or: [StrapiJSON]
  startsWith: StrapiJSON
}

type StrapiMarketingBanner {
  content(filters: StrapiComponentUiConfigurationMarketingBannerItemFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): [StrapiComponentUiConfigurationMarketingBannerItem]
  createdAt: StrapiDateTime
  enabled: Boolean
  name: String
  updatedAt: StrapiDateTime
}

type StrapiMarketingBannerEntity {
  attributes: StrapiMarketingBanner
  id: ID
}

type StrapiMarketingBannerEntityResponse {
  data: StrapiMarketingBannerEntity
}

type StrapiMarketingBannerEntityResponseCollection {
  data: [StrapiMarketingBannerEntity!]!
  meta: StrapiResponseCollectionMeta!
}

input StrapiMarketingBannerFiltersInput {
  and: [StrapiMarketingBannerFiltersInput]
  content: StrapiComponentUiConfigurationMarketingBannerItemFiltersInput
  createdAt: StrapiDateTimeFilterInput
  enabled: StrapiBooleanFilterInput
  id: StrapiIDFilterInput
  name: StrapiStringFilterInput
  not: StrapiMarketingBannerFiltersInput
  or: [StrapiMarketingBannerFiltersInput]
  updatedAt: StrapiDateTimeFilterInput
}

input StrapiMarketingBannerInput {
  content: [StrapiComponentUiConfigurationMarketingBannerItemInput]
  enabled: Boolean
  name: String
}

type StrapiPagination {
  page: Int!
  pageCount: Int!
  pageSize: Int!
  total: Int!
}

input StrapiPaginationArg {
  limit: Int
  page: Int
  pageSize: Int
  start: Int
}

type StrapiResponseCollectionMeta {
  pagination: StrapiPagination!
}

input StrapiStringFilterInput {
  and: [String]
  between: [String]
  contains: String
  containsi: String
  endsWith: String
  eq: String
  eqi: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  ne: String
  nei: String
  not: StrapiStringFilterInput
  notContains: String
  notContainsi: String
  notIn: [String]
  notNull: Boolean
  null: Boolean
  or: [String]
  startsWith: String
}

"""The `Upload` scalar type represents a file upload."""
scalar StrapiUpload

type StrapiUploadFile {
  alternativeText: String
  caption: String
  createdAt: StrapiDateTime
  ext: String
  formats: StrapiJSON
  hash: String!
  height: Int
  mime: String!
  name: String!
  previewUrl: String
  provider: String!
  provider_metadata: StrapiJSON
  related: [StrapiGenericMorph]
  size: Float!
  updatedAt: StrapiDateTime
  url: String!
  width: Int
}

type StrapiUploadFileEntity {
  attributes: StrapiUploadFile
  id: ID
}

type StrapiUploadFileEntityResponse {
  data: StrapiUploadFileEntity
}

type StrapiUploadFileEntityResponseCollection {
  data: [StrapiUploadFileEntity!]!
  meta: StrapiResponseCollectionMeta!
}

input StrapiUploadFileFiltersInput {
  alternativeText: StrapiStringFilterInput
  and: [StrapiUploadFileFiltersInput]
  caption: StrapiStringFilterInput
  createdAt: StrapiDateTimeFilterInput
  ext: StrapiStringFilterInput
  folder: StrapiUploadFolderFiltersInput
  folderPath: StrapiStringFilterInput
  formats: StrapiJSONFilterInput
  hash: StrapiStringFilterInput
  height: StrapiIntFilterInput
  id: StrapiIDFilterInput
  mime: StrapiStringFilterInput
  name: StrapiStringFilterInput
  not: StrapiUploadFileFiltersInput
  or: [StrapiUploadFileFiltersInput]
  previewUrl: StrapiStringFilterInput
  provider: StrapiStringFilterInput
  provider_metadata: StrapiJSONFilterInput
  size: StrapiFloatFilterInput
  updatedAt: StrapiDateTimeFilterInput
  url: StrapiStringFilterInput
  width: StrapiIntFilterInput
}

input StrapiUploadFileInput {
  alternativeText: String
  caption: String
  ext: String
  folder: ID
  folderPath: String
  formats: StrapiJSON
  hash: String
  height: Int
  mime: String
  name: String
  previewUrl: String
  provider: String
  provider_metadata: StrapiJSON
  size: Float
  url: String
  width: Int
}

type StrapiUploadFileRelationResponseCollection {
  data: [StrapiUploadFileEntity!]!
}

type StrapiUploadFolder {
  children(filters: StrapiUploadFolderFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiUploadFolderRelationResponseCollection
  createdAt: StrapiDateTime
  files(filters: StrapiUploadFileFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiUploadFileRelationResponseCollection
  name: String!
  parent: StrapiUploadFolderEntityResponse
  path: String!
  pathId: Int!
  updatedAt: StrapiDateTime
}

type StrapiUploadFolderEntity {
  attributes: StrapiUploadFolder
  id: ID
}

type StrapiUploadFolderEntityResponse {
  data: StrapiUploadFolderEntity
}

type StrapiUploadFolderEntityResponseCollection {
  data: [StrapiUploadFolderEntity!]!
  meta: StrapiResponseCollectionMeta!
}

input StrapiUploadFolderFiltersInput {
  and: [StrapiUploadFolderFiltersInput]
  children: StrapiUploadFolderFiltersInput
  createdAt: StrapiDateTimeFilterInput
  files: StrapiUploadFileFiltersInput
  id: StrapiIDFilterInput
  name: StrapiStringFilterInput
  not: StrapiUploadFolderFiltersInput
  or: [StrapiUploadFolderFiltersInput]
  parent: StrapiUploadFolderFiltersInput
  path: StrapiStringFilterInput
  pathId: StrapiIntFilterInput
  updatedAt: StrapiDateTimeFilterInput
}

input StrapiUploadFolderInput {
  children: [ID]
  files: [ID]
  name: String
  parent: ID
  path: String
  pathId: Int
}

type StrapiUploadFolderRelationResponseCollection {
  data: [StrapiUploadFolderEntity!]!
}

type StrapiUsersPermissionsCreateRolePayload {
  ok: Boolean!
}

type StrapiUsersPermissionsDeleteRolePayload {
  ok: Boolean!
}

input StrapiUsersPermissionsLoginInput {
  identifier: String!
  password: String!
  provider: String! = "local"
}

type StrapiUsersPermissionsLoginPayload {
  jwt: String
  user: StrapiUsersPermissionsMe!
}

type StrapiUsersPermissionsMe {
  blocked: Boolean
  confirmed: Boolean
  email: String
  id: ID!
  role: StrapiUsersPermissionsMeRole
  username: String!
}

type StrapiUsersPermissionsMeRole {
  description: String
  id: ID!
  name: String!
  type: String
}

type StrapiUsersPermissionsPasswordPayload {
  ok: Boolean!
}

type StrapiUsersPermissionsPermission {
  action: String!
  createdAt: StrapiDateTime
  role: StrapiUsersPermissionsRoleEntityResponse
  updatedAt: StrapiDateTime
}

type StrapiUsersPermissionsPermissionEntity {
  attributes: StrapiUsersPermissionsPermission
  id: ID
}

input StrapiUsersPermissionsPermissionFiltersInput {
  action: StrapiStringFilterInput
  and: [StrapiUsersPermissionsPermissionFiltersInput]
  createdAt: StrapiDateTimeFilterInput
  id: StrapiIDFilterInput
  not: StrapiUsersPermissionsPermissionFiltersInput
  or: [StrapiUsersPermissionsPermissionFiltersInput]
  role: StrapiUsersPermissionsRoleFiltersInput
  updatedAt: StrapiDateTimeFilterInput
}

type StrapiUsersPermissionsPermissionRelationResponseCollection {
  data: [StrapiUsersPermissionsPermissionEntity!]!
}

input StrapiUsersPermissionsRegisterInput {
  email: String!
  password: String!
  username: String!
}

type StrapiUsersPermissionsRole {
  createdAt: StrapiDateTime
  description: String
  name: String!
  permissions(filters: StrapiUsersPermissionsPermissionFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiUsersPermissionsPermissionRelationResponseCollection
  type: String
  updatedAt: StrapiDateTime
  users(filters: StrapiUsersPermissionsUserFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiUsersPermissionsUserRelationResponseCollection
}

type StrapiUsersPermissionsRoleEntity {
  attributes: StrapiUsersPermissionsRole
  id: ID
}

type StrapiUsersPermissionsRoleEntityResponse {
  data: StrapiUsersPermissionsRoleEntity
}

type StrapiUsersPermissionsRoleEntityResponseCollection {
  data: [StrapiUsersPermissionsRoleEntity!]!
  meta: StrapiResponseCollectionMeta!
}

input StrapiUsersPermissionsRoleFiltersInput {
  and: [StrapiUsersPermissionsRoleFiltersInput]
  createdAt: StrapiDateTimeFilterInput
  description: StrapiStringFilterInput
  id: StrapiIDFilterInput
  name: StrapiStringFilterInput
  not: StrapiUsersPermissionsRoleFiltersInput
  or: [StrapiUsersPermissionsRoleFiltersInput]
  permissions: StrapiUsersPermissionsPermissionFiltersInput
  type: StrapiStringFilterInput
  updatedAt: StrapiDateTimeFilterInput
  users: StrapiUsersPermissionsUserFiltersInput
}

input StrapiUsersPermissionsRoleInput {
  description: String
  name: String
  permissions: [ID]
  type: String
  users: [ID]
}

type StrapiUsersPermissionsUpdateRolePayload {
  ok: Boolean!
}

type StrapiUsersPermissionsUser {
  blocked: Boolean
  confirmed: Boolean
  createdAt: StrapiDateTime
  email: String!
  provider: String
  role: StrapiUsersPermissionsRoleEntityResponse
  updatedAt: StrapiDateTime
  username: String!
}

type StrapiUsersPermissionsUserEntity {
  attributes: StrapiUsersPermissionsUser
  id: ID
}

type StrapiUsersPermissionsUserEntityResponse {
  data: StrapiUsersPermissionsUserEntity
}

type StrapiUsersPermissionsUserEntityResponseCollection {
  data: [StrapiUsersPermissionsUserEntity!]!
  meta: StrapiResponseCollectionMeta!
}

input StrapiUsersPermissionsUserFiltersInput {
  and: [StrapiUsersPermissionsUserFiltersInput]
  blocked: StrapiBooleanFilterInput
  confirmationToken: StrapiStringFilterInput
  confirmed: StrapiBooleanFilterInput
  createdAt: StrapiDateTimeFilterInput
  email: StrapiStringFilterInput
  id: StrapiIDFilterInput
  not: StrapiUsersPermissionsUserFiltersInput
  or: [StrapiUsersPermissionsUserFiltersInput]
  password: StrapiStringFilterInput
  provider: StrapiStringFilterInput
  resetPasswordToken: StrapiStringFilterInput
  role: StrapiUsersPermissionsRoleFiltersInput
  updatedAt: StrapiDateTimeFilterInput
  username: StrapiStringFilterInput
}

input StrapiUsersPermissionsUserInput {
  blocked: Boolean
  confirmationToken: String
  confirmed: Boolean
  email: String
  password: String
  provider: String
  resetPasswordToken: String
  role: ID
  username: String
}

type StrapiUsersPermissionsUserRelationResponseCollection {
  data: [StrapiUsersPermissionsUserEntity!]!
}

type StreamChatUserTokenResponse {
  token: String
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""The balance for a Stripe connected account."""
type StripeAccountBalance {
  available: BigInt!
  instantAvailable: BigInt!
  pending: BigInt!
}

"""The payout for a Stripe connected account."""
type StripeAccountPayout {
  amount: BigInt!
  arrival: BigInt!
  created: BigInt!
  id: String!
  lastFour: String
  status: String!
  transactionId: String
}

"""The payouts list for a Stripe connected account."""
type StripeAccountPayouts {
  data: [StripeAccountPayout!]!
  hasMore: Boolean!
}

enum StripeAccountStatus {
  Complete
  Other
  RequireUpdateData
  RequireVerification
}

"""The status for a Stripe connected account."""
type StripeAccountStatusResult {
  link: String
  status: StripeAccountStatus!
}

"""Input for updating a Stripe payment method address."""
input StripePaymentMethodAddressUpdate {
  city: String
  country: String
  externalId: String
  state: String
  street1: String
  street2: String
  zip: String
}

"""Input for updating a Stripe payment method."""
input StripePaymentMethodUpdate {
  address: StripePaymentMethodAddressUpdate
  cardHolderName: String
  cardNickname: String
  default: Boolean
}

"""Returns the Stripe setup intent client secret."""
type StripeSetupIntent {
  setupIntentClientSecret: String!
}

"""Whether or not the operation was successful."""
type Success {
  success: Boolean!
}

"""Address suggested by address validation."""
type SuggestedAddress {
  city: String!
  country: String!
  state: String!
  street: String!
  zip: String!
}

"""Trade origin type."""
enum TradeOriginType {
  arbit
}

"""Side State."""
enum TradeSideState {
  BuyerPaid
  CancelledByAdmin
  CancelledByAdminNoFault
  CollectorReviewPassed
  CollectorReviewPending
  CollectorReviewRejected
  CollectorReviewTimedOut
  InboundPackageArrived
  InboundPackageLost
  InboundPackageSent
  InboundPackageTimedOut
  OfferAccepted
  OfferSent
  OutboundPackageTimedOut
  PartnerCancelledByAdmin
  PartnerPaymentFailed
  PaymentFailed
  PaymentOnHold
  TrustedTradeConfirmPending
  TrustedTraderAutoValidated
  ValidatorPassed
  ValidatorPending
  ValidatorRejected
}

type TradeSideStateResponse {
  tradeSideState: TradeSideState!
}

"""Input for updating a Stripe customer"""
input UpdateStripeCustomerInput {
  firstName: String!
  lastName: String!
}

"""Input for verifying otp."""
input VerifyOtpInput {
  otp: String!
  phoneNumber: String
}

"""The status for a Stripe connected account."""
type VerifyPaymentMethodResult {
  clientSecret: String!
  ephemeralKeySecret: String!
  verificationSessionId: String!
}

type Wallet {
  applePay: String
  googlePay: String
  type: WalletType
}

enum WalletType {
  apple_pay
  google_pay
}

"""Addresses associated with a user or offer."""
type addresses {
  city: String!
  country: String!
  created_at: timestamptz!
  deleted_at: Int!
  first_name: String!
  id: uuid!
  is_billing_default: Boolean!
  is_shipping_default: Boolean!
  last_name: String!
  name: String!

  """An array relationship"""
  offerCheckouts(
    """distinct select on columns"""
    distinct_on: [offer_checkouts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_checkouts_order_by!]

    """filter the rows returned"""
    where: offer_checkouts_bool_exp
  ): [offer_checkouts!]!

  """An aggregate relationship"""
  offerCheckouts_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_checkouts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_checkouts_order_by!]

    """filter the rows returned"""
    where: offer_checkouts_bool_exp
  ): offer_checkouts_aggregate!
  state: String
  street1: String!
  street2: String
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
  zip: String!
}

"""
aggregated selection of "addresses"
"""
type addresses_aggregate {
  aggregate: addresses_aggregate_fields
  nodes: [addresses!]!
}

input addresses_aggregate_bool_exp {
  bool_and: addresses_aggregate_bool_exp_bool_and
  bool_or: addresses_aggregate_bool_exp_bool_or
  count: addresses_aggregate_bool_exp_count
}

input addresses_aggregate_bool_exp_bool_and {
  arguments: addresses_select_column_addresses_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: addresses_bool_exp
  predicate: Boolean_comparison_exp!
}

input addresses_aggregate_bool_exp_bool_or {
  arguments: addresses_select_column_addresses_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: addresses_bool_exp
  predicate: Boolean_comparison_exp!
}

input addresses_aggregate_bool_exp_count {
  arguments: [addresses_select_column!]
  distinct: Boolean
  filter: addresses_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "addresses"
"""
type addresses_aggregate_fields {
  avg: addresses_avg_fields
  count(columns: [addresses_select_column!], distinct: Boolean): Int!
  max: addresses_max_fields
  min: addresses_min_fields
  stddev: addresses_stddev_fields
  stddev_pop: addresses_stddev_pop_fields
  stddev_samp: addresses_stddev_samp_fields
  sum: addresses_sum_fields
  var_pop: addresses_var_pop_fields
  var_samp: addresses_var_samp_fields
  variance: addresses_variance_fields
}

"""
order by aggregate values of table "addresses"
"""
input addresses_aggregate_order_by {
  avg: addresses_avg_order_by
  count: order_by
  max: addresses_max_order_by
  min: addresses_min_order_by
  stddev: addresses_stddev_order_by
  stddev_pop: addresses_stddev_pop_order_by
  stddev_samp: addresses_stddev_samp_order_by
  sum: addresses_sum_order_by
  var_pop: addresses_var_pop_order_by
  var_samp: addresses_var_samp_order_by
  variance: addresses_variance_order_by
}

"""
input type for inserting array relation for remote table "addresses"
"""
input addresses_arr_rel_insert_input {
  data: [addresses_insert_input!]!

  """upsert condition"""
  on_conflict: addresses_on_conflict
}

"""aggregate avg on columns"""
type addresses_avg_fields {
  deleted_at: Float
}

"""
order by avg() on columns of table "addresses"
"""
input addresses_avg_order_by {
  deleted_at: order_by
}

"""
Boolean expression to filter rows from the table "addresses". All fields are combined with a logical 'AND'.
"""
input addresses_bool_exp {
  _and: [addresses_bool_exp!]
  _not: addresses_bool_exp
  _or: [addresses_bool_exp!]
  city: String_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  first_name: String_comparison_exp
  id: uuid_comparison_exp
  is_billing_default: Boolean_comparison_exp
  is_shipping_default: Boolean_comparison_exp
  last_name: String_comparison_exp
  name: String_comparison_exp
  offerCheckouts: offer_checkouts_bool_exp
  offerCheckouts_aggregate: offer_checkouts_aggregate_bool_exp
  state: String_comparison_exp
  street1: String_comparison_exp
  street2: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
  zip: String_comparison_exp
}

"""
unique or primary key constraints on table "addresses"
"""
enum addresses_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  addresses_pkey
}

"""
input type for incrementing numeric columns in table "addresses"
"""
input addresses_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "addresses"
"""
input addresses_insert_input {
  city: String
  country: String
  created_at: timestamptz
  deleted_at: Int
  first_name: String
  id: uuid
  is_billing_default: Boolean
  is_shipping_default: Boolean
  last_name: String
  name: String
  offerCheckouts: offer_checkouts_arr_rel_insert_input
  state: String
  street1: String
  street2: String
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
  zip: String
}

"""aggregate max on columns"""
type addresses_max_fields {
  city: String
  country: String
  created_at: timestamptz
  deleted_at: Int
  first_name: String
  id: uuid
  last_name: String
  name: String
  state: String
  street1: String
  street2: String
  updated_at: timestamptz
  user_id: uuid
  zip: String
}

"""
order by max() on columns of table "addresses"
"""
input addresses_max_order_by {
  city: order_by
  country: order_by
  created_at: order_by
  deleted_at: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  name: order_by
  state: order_by
  street1: order_by
  street2: order_by
  updated_at: order_by
  user_id: order_by
  zip: order_by
}

"""aggregate min on columns"""
type addresses_min_fields {
  city: String
  country: String
  created_at: timestamptz
  deleted_at: Int
  first_name: String
  id: uuid
  last_name: String
  name: String
  state: String
  street1: String
  street2: String
  updated_at: timestamptz
  user_id: uuid
  zip: String
}

"""
order by min() on columns of table "addresses"
"""
input addresses_min_order_by {
  city: order_by
  country: order_by
  created_at: order_by
  deleted_at: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  name: order_by
  state: order_by
  street1: order_by
  street2: order_by
  updated_at: order_by
  user_id: order_by
  zip: order_by
}

"""
response of any mutation on the table "addresses"
"""
type addresses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [addresses!]!
}

"""
input type for inserting object relation for remote table "addresses"
"""
input addresses_obj_rel_insert_input {
  data: addresses_insert_input!

  """upsert condition"""
  on_conflict: addresses_on_conflict
}

"""
on_conflict condition type for table "addresses"
"""
input addresses_on_conflict {
  constraint: addresses_constraint!
  update_columns: [addresses_update_column!]! = []
  where: addresses_bool_exp
}

"""Ordering options when selecting data from "addresses"."""
input addresses_order_by {
  city: order_by
  country: order_by
  created_at: order_by
  deleted_at: order_by
  first_name: order_by
  id: order_by
  is_billing_default: order_by
  is_shipping_default: order_by
  last_name: order_by
  name: order_by
  offerCheckouts_aggregate: offer_checkouts_aggregate_order_by
  state: order_by
  street1: order_by
  street2: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
  zip: order_by
}

"""primary key columns input for table: addresses"""
input addresses_pk_columns_input {
  id: uuid!
}

"""
select columns of table "addresses"
"""
enum addresses_select_column {
  """column name"""
  city

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  is_billing_default

  """column name"""
  is_shipping_default

  """column name"""
  last_name

  """column name"""
  name

  """column name"""
  state

  """column name"""
  street1

  """column name"""
  street2

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  zip
}

"""
select "addresses_aggregate_bool_exp_bool_and_arguments_columns" columns of table "addresses"
"""
enum addresses_select_column_addresses_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_billing_default

  """column name"""
  is_shipping_default
}

"""
select "addresses_aggregate_bool_exp_bool_or_arguments_columns" columns of table "addresses"
"""
enum addresses_select_column_addresses_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_billing_default

  """column name"""
  is_shipping_default
}

"""
input type for updating data in table "addresses"
"""
input addresses_set_input {
  city: String
  country: String
  created_at: timestamptz
  deleted_at: Int
  first_name: String
  id: uuid
  is_billing_default: Boolean
  is_shipping_default: Boolean
  last_name: String
  name: String
  state: String
  street1: String
  street2: String
  updated_at: timestamptz
  user_id: uuid
  zip: String
}

"""aggregate stddev on columns"""
type addresses_stddev_fields {
  deleted_at: Float
}

"""
order by stddev() on columns of table "addresses"
"""
input addresses_stddev_order_by {
  deleted_at: order_by
}

"""aggregate stddev_pop on columns"""
type addresses_stddev_pop_fields {
  deleted_at: Float
}

"""
order by stddev_pop() on columns of table "addresses"
"""
input addresses_stddev_pop_order_by {
  deleted_at: order_by
}

"""aggregate stddev_samp on columns"""
type addresses_stddev_samp_fields {
  deleted_at: Float
}

"""
order by stddev_samp() on columns of table "addresses"
"""
input addresses_stddev_samp_order_by {
  deleted_at: order_by
}

"""
Streaming cursor of the table "addresses"
"""
input addresses_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: addresses_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input addresses_stream_cursor_value_input {
  city: String
  country: String
  created_at: timestamptz
  deleted_at: Int
  first_name: String
  id: uuid
  is_billing_default: Boolean
  is_shipping_default: Boolean
  last_name: String
  name: String
  state: String
  street1: String
  street2: String
  updated_at: timestamptz
  user_id: uuid
  zip: String
}

"""aggregate sum on columns"""
type addresses_sum_fields {
  deleted_at: Int
}

"""
order by sum() on columns of table "addresses"
"""
input addresses_sum_order_by {
  deleted_at: order_by
}

"""
update columns of table "addresses"
"""
enum addresses_update_column {
  """column name"""
  city

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  is_billing_default

  """column name"""
  is_shipping_default

  """column name"""
  last_name

  """column name"""
  name

  """column name"""
  state

  """column name"""
  street1

  """column name"""
  street2

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  zip
}

input addresses_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: addresses_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: addresses_set_input

  """filter the rows which have to be updated"""
  where: addresses_bool_exp!
}

"""aggregate var_pop on columns"""
type addresses_var_pop_fields {
  deleted_at: Float
}

"""
order by var_pop() on columns of table "addresses"
"""
input addresses_var_pop_order_by {
  deleted_at: order_by
}

"""aggregate var_samp on columns"""
type addresses_var_samp_fields {
  deleted_at: Float
}

"""
order by var_samp() on columns of table "addresses"
"""
input addresses_var_samp_order_by {
  deleted_at: order_by
}

"""aggregate variance on columns"""
type addresses_variance_fields {
  deleted_at: Float
}

"""
order by variance() on columns of table "addresses"
"""
input addresses_variance_order_by {
  deleted_at: order_by
}

"""
This is a join table for a many-to-many relationship between attributes and attribute_groups.
"""
type attribute_attribute_group {
  """An object relationship"""
  attribute: attributes!

  """An object relationship"""
  attribute_group: attribute_groups!
  attribute_group_id: uuid!
  attribute_id: uuid!
  created_at: timestamptz!
  id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "attribute_attribute_group"
"""
type attribute_attribute_group_aggregate {
  aggregate: attribute_attribute_group_aggregate_fields
  nodes: [attribute_attribute_group!]!
}

input attribute_attribute_group_aggregate_bool_exp {
  count: attribute_attribute_group_aggregate_bool_exp_count
}

input attribute_attribute_group_aggregate_bool_exp_count {
  arguments: [attribute_attribute_group_select_column!]
  distinct: Boolean
  filter: attribute_attribute_group_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "attribute_attribute_group"
"""
type attribute_attribute_group_aggregate_fields {
  count(columns: [attribute_attribute_group_select_column!], distinct: Boolean): Int!
  max: attribute_attribute_group_max_fields
  min: attribute_attribute_group_min_fields
}

"""
order by aggregate values of table "attribute_attribute_group"
"""
input attribute_attribute_group_aggregate_order_by {
  count: order_by
  max: attribute_attribute_group_max_order_by
  min: attribute_attribute_group_min_order_by
}

"""
input type for inserting array relation for remote table "attribute_attribute_group"
"""
input attribute_attribute_group_arr_rel_insert_input {
  data: [attribute_attribute_group_insert_input!]!

  """upsert condition"""
  on_conflict: attribute_attribute_group_on_conflict
}

"""
Boolean expression to filter rows from the table "attribute_attribute_group". All fields are combined with a logical 'AND'.
"""
input attribute_attribute_group_bool_exp {
  _and: [attribute_attribute_group_bool_exp!]
  _not: attribute_attribute_group_bool_exp
  _or: [attribute_attribute_group_bool_exp!]
  attribute: attributes_bool_exp
  attribute_group: attribute_groups_bool_exp
  attribute_group_id: uuid_comparison_exp
  attribute_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "attribute_attribute_group"
"""
enum attribute_attribute_group_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  attribute_attribute_group_pkey
}

"""
input type for inserting data into table "attribute_attribute_group"
"""
input attribute_attribute_group_insert_input {
  attribute: attributes_obj_rel_insert_input
  attribute_group: attribute_groups_obj_rel_insert_input
  attribute_group_id: uuid
  attribute_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type attribute_attribute_group_max_fields {
  attribute_group_id: uuid
  attribute_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "attribute_attribute_group"
"""
input attribute_attribute_group_max_order_by {
  attribute_group_id: order_by
  attribute_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type attribute_attribute_group_min_fields {
  attribute_group_id: uuid
  attribute_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "attribute_attribute_group"
"""
input attribute_attribute_group_min_order_by {
  attribute_group_id: order_by
  attribute_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "attribute_attribute_group"
"""
type attribute_attribute_group_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attribute_attribute_group!]!
}

"""
on_conflict condition type for table "attribute_attribute_group"
"""
input attribute_attribute_group_on_conflict {
  constraint: attribute_attribute_group_constraint!
  update_columns: [attribute_attribute_group_update_column!]! = []
  where: attribute_attribute_group_bool_exp
}

"""Ordering options when selecting data from "attribute_attribute_group"."""
input attribute_attribute_group_order_by {
  attribute: attributes_order_by
  attribute_group: attribute_groups_order_by
  attribute_group_id: order_by
  attribute_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""primary key columns input for table: attribute_attribute_group"""
input attribute_attribute_group_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attribute_attribute_group"
"""
enum attribute_attribute_group_select_column {
  """column name"""
  attribute_group_id

  """column name"""
  attribute_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "attribute_attribute_group"
"""
input attribute_attribute_group_set_input {
  attribute_group_id: uuid
  attribute_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "attribute_attribute_group"
"""
input attribute_attribute_group_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attribute_attribute_group_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attribute_attribute_group_stream_cursor_value_input {
  attribute_group_id: uuid
  attribute_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "attribute_attribute_group"
"""
enum attribute_attribute_group_update_column {
  """column name"""
  attribute_group_id

  """column name"""
  attribute_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at
}

input attribute_attribute_group_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: attribute_attribute_group_set_input

  """filter the rows which have to be updated"""
  where: attribute_attribute_group_bool_exp!
}

"""
Each record represents a grouping of all attributes that apply to specific types of products.
"""
type attribute_groups {
  """An array relationship"""
  attribute_attribute_groups(
    """distinct select on columns"""
    distinct_on: [attribute_attribute_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_attribute_group_order_by!]

    """filter the rows returned"""
    where: attribute_attribute_group_bool_exp
  ): [attribute_attribute_group!]!

  """An aggregate relationship"""
  attribute_attribute_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_attribute_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_attribute_group_order_by!]

    """filter the rows returned"""
    where: attribute_attribute_group_bool_exp
  ): attribute_attribute_group_aggregate!
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!
  name: String!

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): products_aggregate!
  updated_at: timestamptz!
}

"""
aggregated selection of "attribute_groups"
"""
type attribute_groups_aggregate {
  aggregate: attribute_groups_aggregate_fields
  nodes: [attribute_groups!]!
}

"""
aggregate fields of "attribute_groups"
"""
type attribute_groups_aggregate_fields {
  avg: attribute_groups_avg_fields
  count(columns: [attribute_groups_select_column!], distinct: Boolean): Int!
  max: attribute_groups_max_fields
  min: attribute_groups_min_fields
  stddev: attribute_groups_stddev_fields
  stddev_pop: attribute_groups_stddev_pop_fields
  stddev_samp: attribute_groups_stddev_samp_fields
  sum: attribute_groups_sum_fields
  var_pop: attribute_groups_var_pop_fields
  var_samp: attribute_groups_var_samp_fields
  variance: attribute_groups_variance_fields
}

"""aggregate avg on columns"""
type attribute_groups_avg_fields {
  deleted_at: Float
}

"""
Boolean expression to filter rows from the table "attribute_groups". All fields are combined with a logical 'AND'.
"""
input attribute_groups_bool_exp {
  _and: [attribute_groups_bool_exp!]
  _not: attribute_groups_bool_exp
  _or: [attribute_groups_bool_exp!]
  attribute_attribute_groups: attribute_attribute_group_bool_exp
  attribute_attribute_groups_aggregate: attribute_attribute_group_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  products: products_bool_exp
  products_aggregate: products_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "attribute_groups"
"""
enum attribute_groups_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  attribute_groups_name_key

  """
  unique or primary key constraint on columns "id"
  """
  attribute_groups_pkey
}

"""
input type for incrementing numeric columns in table "attribute_groups"
"""
input attribute_groups_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "attribute_groups"
"""
input attribute_groups_insert_input {
  attribute_attribute_groups: attribute_attribute_group_arr_rel_insert_input
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  name: String
  products: products_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type attribute_groups_max_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type attribute_groups_min_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "attribute_groups"
"""
type attribute_groups_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attribute_groups!]!
}

"""
input type for inserting object relation for remote table "attribute_groups"
"""
input attribute_groups_obj_rel_insert_input {
  data: attribute_groups_insert_input!

  """upsert condition"""
  on_conflict: attribute_groups_on_conflict
}

"""
on_conflict condition type for table "attribute_groups"
"""
input attribute_groups_on_conflict {
  constraint: attribute_groups_constraint!
  update_columns: [attribute_groups_update_column!]! = []
  where: attribute_groups_bool_exp
}

"""Ordering options when selecting data from "attribute_groups"."""
input attribute_groups_order_by {
  attribute_attribute_groups_aggregate: attribute_attribute_group_aggregate_order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  products_aggregate: products_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: attribute_groups"""
input attribute_groups_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attribute_groups"
"""
enum attribute_groups_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "attribute_groups"
"""
input attribute_groups_set_input {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type attribute_groups_stddev_fields {
  deleted_at: Float
}

"""aggregate stddev_pop on columns"""
type attribute_groups_stddev_pop_fields {
  deleted_at: Float
}

"""aggregate stddev_samp on columns"""
type attribute_groups_stddev_samp_fields {
  deleted_at: Float
}

"""
Streaming cursor of the table "attribute_groups"
"""
input attribute_groups_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attribute_groups_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attribute_groups_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type attribute_groups_sum_fields {
  deleted_at: Int
}

"""
update columns of table "attribute_groups"
"""
enum attribute_groups_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input attribute_groups_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: attribute_groups_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: attribute_groups_set_input

  """filter the rows which have to be updated"""
  where: attribute_groups_bool_exp!
}

"""aggregate var_pop on columns"""
type attribute_groups_var_pop_fields {
  deleted_at: Float
}

"""aggregate var_samp on columns"""
type attribute_groups_var_samp_fields {
  deleted_at: Float
}

"""aggregate variance on columns"""
type attribute_groups_variance_fields {
  deleted_at: Float
}

"""Attribute preferences associated with user preferences."""
type attribute_preferences {
  """An object relationship"""
  attribute: attributes!
  attribute_id: uuid!

  """An object relationship"""
  attribute_preference: attribute_preferences

  """An object relationship"""
  attribute_value: attribute_values!
  attribute_value_id: uuid!
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!
  preferred: Boolean!
  related_attribute_preference_id: uuid

  """An array relationship"""
  related_attribute_preferences(
    """distinct select on columns"""
    distinct_on: [attribute_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_preferences_order_by!]

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): [attribute_preferences!]!

  """An aggregate relationship"""
  related_attribute_preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_preferences_order_by!]

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): attribute_preferences_aggregate!
  updated_at: timestamptz!

  """An object relationship"""
  user_preference: user_preferences
  user_preference_id: uuid
}

"""
aggregated selection of "attribute_preferences"
"""
type attribute_preferences_aggregate {
  aggregate: attribute_preferences_aggregate_fields
  nodes: [attribute_preferences!]!
}

input attribute_preferences_aggregate_bool_exp {
  bool_and: attribute_preferences_aggregate_bool_exp_bool_and
  bool_or: attribute_preferences_aggregate_bool_exp_bool_or
  count: attribute_preferences_aggregate_bool_exp_count
}

input attribute_preferences_aggregate_bool_exp_bool_and {
  arguments: attribute_preferences_select_column_attribute_preferences_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: attribute_preferences_bool_exp
  predicate: Boolean_comparison_exp!
}

input attribute_preferences_aggregate_bool_exp_bool_or {
  arguments: attribute_preferences_select_column_attribute_preferences_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: attribute_preferences_bool_exp
  predicate: Boolean_comparison_exp!
}

input attribute_preferences_aggregate_bool_exp_count {
  arguments: [attribute_preferences_select_column!]
  distinct: Boolean
  filter: attribute_preferences_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "attribute_preferences"
"""
type attribute_preferences_aggregate_fields {
  avg: attribute_preferences_avg_fields
  count(columns: [attribute_preferences_select_column!], distinct: Boolean): Int!
  max: attribute_preferences_max_fields
  min: attribute_preferences_min_fields
  stddev: attribute_preferences_stddev_fields
  stddev_pop: attribute_preferences_stddev_pop_fields
  stddev_samp: attribute_preferences_stddev_samp_fields
  sum: attribute_preferences_sum_fields
  var_pop: attribute_preferences_var_pop_fields
  var_samp: attribute_preferences_var_samp_fields
  variance: attribute_preferences_variance_fields
}

"""
order by aggregate values of table "attribute_preferences"
"""
input attribute_preferences_aggregate_order_by {
  avg: attribute_preferences_avg_order_by
  count: order_by
  max: attribute_preferences_max_order_by
  min: attribute_preferences_min_order_by
  stddev: attribute_preferences_stddev_order_by
  stddev_pop: attribute_preferences_stddev_pop_order_by
  stddev_samp: attribute_preferences_stddev_samp_order_by
  sum: attribute_preferences_sum_order_by
  var_pop: attribute_preferences_var_pop_order_by
  var_samp: attribute_preferences_var_samp_order_by
  variance: attribute_preferences_variance_order_by
}

"""
input type for inserting array relation for remote table "attribute_preferences"
"""
input attribute_preferences_arr_rel_insert_input {
  data: [attribute_preferences_insert_input!]!

  """upsert condition"""
  on_conflict: attribute_preferences_on_conflict
}

"""aggregate avg on columns"""
type attribute_preferences_avg_fields {
  deleted_at: Float
}

"""
order by avg() on columns of table "attribute_preferences"
"""
input attribute_preferences_avg_order_by {
  deleted_at: order_by
}

"""
Boolean expression to filter rows from the table "attribute_preferences". All fields are combined with a logical 'AND'.
"""
input attribute_preferences_bool_exp {
  _and: [attribute_preferences_bool_exp!]
  _not: attribute_preferences_bool_exp
  _or: [attribute_preferences_bool_exp!]
  attribute: attributes_bool_exp
  attribute_id: uuid_comparison_exp
  attribute_preference: attribute_preferences_bool_exp
  attribute_value: attribute_values_bool_exp
  attribute_value_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  preferred: Boolean_comparison_exp
  related_attribute_preference_id: uuid_comparison_exp
  related_attribute_preferences: attribute_preferences_bool_exp
  related_attribute_preferences_aggregate: attribute_preferences_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  user_preference: user_preferences_bool_exp
  user_preference_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "attribute_preferences"
"""
enum attribute_preferences_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  attribute_preferences_pkey
}

"""
input type for incrementing numeric columns in table "attribute_preferences"
"""
input attribute_preferences_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "attribute_preferences"
"""
input attribute_preferences_insert_input {
  attribute: attributes_obj_rel_insert_input
  attribute_id: uuid
  attribute_preference: attribute_preferences_obj_rel_insert_input
  attribute_value: attribute_values_obj_rel_insert_input
  attribute_value_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  preferred: Boolean
  related_attribute_preference_id: uuid
  related_attribute_preferences: attribute_preferences_arr_rel_insert_input
  updated_at: timestamptz
  user_preference: user_preferences_obj_rel_insert_input
  user_preference_id: uuid
}

"""aggregate max on columns"""
type attribute_preferences_max_fields {
  attribute_id: uuid
  attribute_value_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  related_attribute_preference_id: uuid
  updated_at: timestamptz
  user_preference_id: uuid
}

"""
order by max() on columns of table "attribute_preferences"
"""
input attribute_preferences_max_order_by {
  attribute_id: order_by
  attribute_value_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  related_attribute_preference_id: order_by
  updated_at: order_by
  user_preference_id: order_by
}

"""aggregate min on columns"""
type attribute_preferences_min_fields {
  attribute_id: uuid
  attribute_value_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  related_attribute_preference_id: uuid
  updated_at: timestamptz
  user_preference_id: uuid
}

"""
order by min() on columns of table "attribute_preferences"
"""
input attribute_preferences_min_order_by {
  attribute_id: order_by
  attribute_value_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  related_attribute_preference_id: order_by
  updated_at: order_by
  user_preference_id: order_by
}

"""
response of any mutation on the table "attribute_preferences"
"""
type attribute_preferences_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attribute_preferences!]!
}

"""
input type for inserting object relation for remote table "attribute_preferences"
"""
input attribute_preferences_obj_rel_insert_input {
  data: attribute_preferences_insert_input!

  """upsert condition"""
  on_conflict: attribute_preferences_on_conflict
}

"""
on_conflict condition type for table "attribute_preferences"
"""
input attribute_preferences_on_conflict {
  constraint: attribute_preferences_constraint!
  update_columns: [attribute_preferences_update_column!]! = []
  where: attribute_preferences_bool_exp
}

"""Ordering options when selecting data from "attribute_preferences"."""
input attribute_preferences_order_by {
  attribute: attributes_order_by
  attribute_id: order_by
  attribute_preference: attribute_preferences_order_by
  attribute_value: attribute_values_order_by
  attribute_value_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  preferred: order_by
  related_attribute_preference_id: order_by
  related_attribute_preferences_aggregate: attribute_preferences_aggregate_order_by
  updated_at: order_by
  user_preference: user_preferences_order_by
  user_preference_id: order_by
}

"""primary key columns input for table: attribute_preferences"""
input attribute_preferences_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attribute_preferences"
"""
enum attribute_preferences_select_column {
  """column name"""
  attribute_id

  """column name"""
  attribute_value_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  preferred

  """column name"""
  related_attribute_preference_id

  """column name"""
  updated_at

  """column name"""
  user_preference_id
}

"""
select "attribute_preferences_aggregate_bool_exp_bool_and_arguments_columns" columns of table "attribute_preferences"
"""
enum attribute_preferences_select_column_attribute_preferences_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  preferred
}

"""
select "attribute_preferences_aggregate_bool_exp_bool_or_arguments_columns" columns of table "attribute_preferences"
"""
enum attribute_preferences_select_column_attribute_preferences_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  preferred
}

"""
input type for updating data in table "attribute_preferences"
"""
input attribute_preferences_set_input {
  attribute_id: uuid
  attribute_value_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  preferred: Boolean
  related_attribute_preference_id: uuid
  updated_at: timestamptz
  user_preference_id: uuid
}

"""aggregate stddev on columns"""
type attribute_preferences_stddev_fields {
  deleted_at: Float
}

"""
order by stddev() on columns of table "attribute_preferences"
"""
input attribute_preferences_stddev_order_by {
  deleted_at: order_by
}

"""aggregate stddev_pop on columns"""
type attribute_preferences_stddev_pop_fields {
  deleted_at: Float
}

"""
order by stddev_pop() on columns of table "attribute_preferences"
"""
input attribute_preferences_stddev_pop_order_by {
  deleted_at: order_by
}

"""aggregate stddev_samp on columns"""
type attribute_preferences_stddev_samp_fields {
  deleted_at: Float
}

"""
order by stddev_samp() on columns of table "attribute_preferences"
"""
input attribute_preferences_stddev_samp_order_by {
  deleted_at: order_by
}

"""
Streaming cursor of the table "attribute_preferences"
"""
input attribute_preferences_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attribute_preferences_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attribute_preferences_stream_cursor_value_input {
  attribute_id: uuid
  attribute_value_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  preferred: Boolean
  related_attribute_preference_id: uuid
  updated_at: timestamptz
  user_preference_id: uuid
}

"""aggregate sum on columns"""
type attribute_preferences_sum_fields {
  deleted_at: Int
}

"""
order by sum() on columns of table "attribute_preferences"
"""
input attribute_preferences_sum_order_by {
  deleted_at: order_by
}

"""
update columns of table "attribute_preferences"
"""
enum attribute_preferences_update_column {
  """column name"""
  attribute_id

  """column name"""
  attribute_value_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  preferred

  """column name"""
  related_attribute_preference_id

  """column name"""
  updated_at

  """column name"""
  user_preference_id
}

input attribute_preferences_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: attribute_preferences_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: attribute_preferences_set_input

  """filter the rows which have to be updated"""
  where: attribute_preferences_bool_exp!
}

"""aggregate var_pop on columns"""
type attribute_preferences_var_pop_fields {
  deleted_at: Float
}

"""
order by var_pop() on columns of table "attribute_preferences"
"""
input attribute_preferences_var_pop_order_by {
  deleted_at: order_by
}

"""aggregate var_samp on columns"""
type attribute_preferences_var_samp_fields {
  deleted_at: Float
}

"""
order by var_samp() on columns of table "attribute_preferences"
"""
input attribute_preferences_var_samp_order_by {
  deleted_at: order_by
}

"""aggregate variance on columns"""
type attribute_preferences_variance_fields {
  deleted_at: Float
}

"""
order by variance() on columns of table "attribute_preferences"
"""
input attribute_preferences_variance_order_by {
  deleted_at: order_by
}

"""
Each record specifies an attribute_value for a specific catalog entity.
"""
type attribute_selections {
  """An object relationship"""
  attribute_type: attribute_type!

  """An object relationship"""
  attribute_value: attribute_values!
  attribute_value_id: uuid!
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!

  """An object relationship"""
  inventory_item: inventory_items
  inventory_item_id: uuid

  """An object relationship"""
  product: products
  product_id: uuid

  """An object relationship"""
  product_variant: product_variants
  product_variant_id: uuid
  type: attribute_type_enum!
  updated_at: timestamptz!

  """An object relationship"""
  wishlist_item: wishlist_items
  wishlist_item_id: uuid
}

"""
aggregated selection of "attribute_selections"
"""
type attribute_selections_aggregate {
  aggregate: attribute_selections_aggregate_fields
  nodes: [attribute_selections!]!
}

input attribute_selections_aggregate_bool_exp {
  count: attribute_selections_aggregate_bool_exp_count
}

input attribute_selections_aggregate_bool_exp_count {
  arguments: [attribute_selections_select_column!]
  distinct: Boolean
  filter: attribute_selections_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "attribute_selections"
"""
type attribute_selections_aggregate_fields {
  avg: attribute_selections_avg_fields
  count(columns: [attribute_selections_select_column!], distinct: Boolean): Int!
  max: attribute_selections_max_fields
  min: attribute_selections_min_fields
  stddev: attribute_selections_stddev_fields
  stddev_pop: attribute_selections_stddev_pop_fields
  stddev_samp: attribute_selections_stddev_samp_fields
  sum: attribute_selections_sum_fields
  var_pop: attribute_selections_var_pop_fields
  var_samp: attribute_selections_var_samp_fields
  variance: attribute_selections_variance_fields
}

"""
order by aggregate values of table "attribute_selections"
"""
input attribute_selections_aggregate_order_by {
  avg: attribute_selections_avg_order_by
  count: order_by
  max: attribute_selections_max_order_by
  min: attribute_selections_min_order_by
  stddev: attribute_selections_stddev_order_by
  stddev_pop: attribute_selections_stddev_pop_order_by
  stddev_samp: attribute_selections_stddev_samp_order_by
  sum: attribute_selections_sum_order_by
  var_pop: attribute_selections_var_pop_order_by
  var_samp: attribute_selections_var_samp_order_by
  variance: attribute_selections_variance_order_by
}

"""
input type for inserting array relation for remote table "attribute_selections"
"""
input attribute_selections_arr_rel_insert_input {
  data: [attribute_selections_insert_input!]!

  """upsert condition"""
  on_conflict: attribute_selections_on_conflict
}

"""aggregate avg on columns"""
type attribute_selections_avg_fields {
  deleted_at: Float
}

"""
order by avg() on columns of table "attribute_selections"
"""
input attribute_selections_avg_order_by {
  deleted_at: order_by
}

"""
Boolean expression to filter rows from the table "attribute_selections". All fields are combined with a logical 'AND'.
"""
input attribute_selections_bool_exp {
  _and: [attribute_selections_bool_exp!]
  _not: attribute_selections_bool_exp
  _or: [attribute_selections_bool_exp!]
  attribute_type: attribute_type_bool_exp
  attribute_value: attribute_values_bool_exp
  attribute_value_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  inventory_item: inventory_items_bool_exp
  inventory_item_id: uuid_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  product_variant: product_variants_bool_exp
  product_variant_id: uuid_comparison_exp
  type: attribute_type_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
  wishlist_item: wishlist_items_bool_exp
  wishlist_item_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "attribute_selections"
"""
enum attribute_selections_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  attribute_selections_pkey
}

"""
input type for incrementing numeric columns in table "attribute_selections"
"""
input attribute_selections_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "attribute_selections"
"""
input attribute_selections_insert_input {
  attribute_type: attribute_type_obj_rel_insert_input
  attribute_value: attribute_values_obj_rel_insert_input
  attribute_value_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  inventory_item: inventory_items_obj_rel_insert_input
  inventory_item_id: uuid
  product: products_obj_rel_insert_input
  product_id: uuid
  product_variant: product_variants_obj_rel_insert_input
  product_variant_id: uuid
  type: attribute_type_enum
  updated_at: timestamptz
  wishlist_item: wishlist_items_obj_rel_insert_input
  wishlist_item_id: uuid
}

"""aggregate max on columns"""
type attribute_selections_max_fields {
  attribute_value_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  inventory_item_id: uuid
  product_id: uuid
  product_variant_id: uuid
  updated_at: timestamptz
  wishlist_item_id: uuid
}

"""
order by max() on columns of table "attribute_selections"
"""
input attribute_selections_max_order_by {
  attribute_value_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  inventory_item_id: order_by
  product_id: order_by
  product_variant_id: order_by
  updated_at: order_by
  wishlist_item_id: order_by
}

"""aggregate min on columns"""
type attribute_selections_min_fields {
  attribute_value_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  inventory_item_id: uuid
  product_id: uuid
  product_variant_id: uuid
  updated_at: timestamptz
  wishlist_item_id: uuid
}

"""
order by min() on columns of table "attribute_selections"
"""
input attribute_selections_min_order_by {
  attribute_value_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  inventory_item_id: order_by
  product_id: order_by
  product_variant_id: order_by
  updated_at: order_by
  wishlist_item_id: order_by
}

"""
response of any mutation on the table "attribute_selections"
"""
type attribute_selections_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attribute_selections!]!
}

"""
on_conflict condition type for table "attribute_selections"
"""
input attribute_selections_on_conflict {
  constraint: attribute_selections_constraint!
  update_columns: [attribute_selections_update_column!]! = []
  where: attribute_selections_bool_exp
}

"""Ordering options when selecting data from "attribute_selections"."""
input attribute_selections_order_by {
  attribute_type: attribute_type_order_by
  attribute_value: attribute_values_order_by
  attribute_value_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  inventory_item: inventory_items_order_by
  inventory_item_id: order_by
  product: products_order_by
  product_id: order_by
  product_variant: product_variants_order_by
  product_variant_id: order_by
  type: order_by
  updated_at: order_by
  wishlist_item: wishlist_items_order_by
  wishlist_item_id: order_by
}

"""primary key columns input for table: attribute_selections"""
input attribute_selections_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attribute_selections"
"""
enum attribute_selections_select_column {
  """column name"""
  attribute_value_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  inventory_item_id

  """column name"""
  product_id

  """column name"""
  product_variant_id

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  wishlist_item_id
}

"""
input type for updating data in table "attribute_selections"
"""
input attribute_selections_set_input {
  attribute_value_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  inventory_item_id: uuid
  product_id: uuid
  product_variant_id: uuid
  type: attribute_type_enum
  updated_at: timestamptz
  wishlist_item_id: uuid
}

"""aggregate stddev on columns"""
type attribute_selections_stddev_fields {
  deleted_at: Float
}

"""
order by stddev() on columns of table "attribute_selections"
"""
input attribute_selections_stddev_order_by {
  deleted_at: order_by
}

"""aggregate stddev_pop on columns"""
type attribute_selections_stddev_pop_fields {
  deleted_at: Float
}

"""
order by stddev_pop() on columns of table "attribute_selections"
"""
input attribute_selections_stddev_pop_order_by {
  deleted_at: order_by
}

"""aggregate stddev_samp on columns"""
type attribute_selections_stddev_samp_fields {
  deleted_at: Float
}

"""
order by stddev_samp() on columns of table "attribute_selections"
"""
input attribute_selections_stddev_samp_order_by {
  deleted_at: order_by
}

"""
Streaming cursor of the table "attribute_selections"
"""
input attribute_selections_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attribute_selections_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attribute_selections_stream_cursor_value_input {
  attribute_value_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  inventory_item_id: uuid
  product_id: uuid
  product_variant_id: uuid
  type: attribute_type_enum
  updated_at: timestamptz
  wishlist_item_id: uuid
}

"""aggregate sum on columns"""
type attribute_selections_sum_fields {
  deleted_at: Int
}

"""
order by sum() on columns of table "attribute_selections"
"""
input attribute_selections_sum_order_by {
  deleted_at: order_by
}

"""
update columns of table "attribute_selections"
"""
enum attribute_selections_update_column {
  """column name"""
  attribute_value_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  inventory_item_id

  """column name"""
  product_id

  """column name"""
  product_variant_id

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  wishlist_item_id
}

input attribute_selections_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: attribute_selections_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: attribute_selections_set_input

  """filter the rows which have to be updated"""
  where: attribute_selections_bool_exp!
}

"""aggregate var_pop on columns"""
type attribute_selections_var_pop_fields {
  deleted_at: Float
}

"""
order by var_pop() on columns of table "attribute_selections"
"""
input attribute_selections_var_pop_order_by {
  deleted_at: order_by
}

"""aggregate var_samp on columns"""
type attribute_selections_var_samp_fields {
  deleted_at: Float
}

"""
order by var_samp() on columns of table "attribute_selections"
"""
input attribute_selections_var_samp_order_by {
  deleted_at: order_by
}

"""aggregate variance on columns"""
type attribute_selections_variance_fields {
  deleted_at: Float
}

"""
order by variance() on columns of table "attribute_selections"
"""
input attribute_selections_variance_order_by {
  deleted_at: order_by
}

"""
This is an enum table used for the type of attributes and attribute_selections.
"""
type attribute_type {
  """An array relationship"""
  attribute_selections(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): [attribute_selections!]!

  """An aggregate relationship"""
  attribute_selections_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): attribute_selections_aggregate!

  """An array relationship"""
  attributes(
    """distinct select on columns"""
    distinct_on: [attributes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attributes_order_by!]

    """filter the rows returned"""
    where: attributes_bool_exp
  ): [attributes!]!

  """An aggregate relationship"""
  attributes_aggregate(
    """distinct select on columns"""
    distinct_on: [attributes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attributes_order_by!]

    """filter the rows returned"""
    where: attributes_bool_exp
  ): attributes_aggregate!
  comment: String!
  value: String!
}

"""
aggregated selection of "attribute_type"
"""
type attribute_type_aggregate {
  aggregate: attribute_type_aggregate_fields
  nodes: [attribute_type!]!
}

"""
aggregate fields of "attribute_type"
"""
type attribute_type_aggregate_fields {
  count(columns: [attribute_type_select_column!], distinct: Boolean): Int!
  max: attribute_type_max_fields
  min: attribute_type_min_fields
}

"""
Boolean expression to filter rows from the table "attribute_type". All fields are combined with a logical 'AND'.
"""
input attribute_type_bool_exp {
  _and: [attribute_type_bool_exp!]
  _not: attribute_type_bool_exp
  _or: [attribute_type_bool_exp!]
  attribute_selections: attribute_selections_bool_exp
  attribute_selections_aggregate: attribute_selections_aggregate_bool_exp
  attributes: attributes_bool_exp
  attributes_aggregate: attributes_aggregate_bool_exp
  comment: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "attribute_type"
"""
enum attribute_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  attribute_type_pkey
}

enum attribute_type_enum {
  """Attributes that apply at the inventory item level."""
  INVENTORY

  """Attributes that apply at the product level."""
  PRODUCT

  """Attributes that apply at the product variant level."""
  VARIANT

  """Attributes that apply at the wishlist item level."""
  WISHLIST
}

"""
Boolean expression to compare columns of type "attribute_type_enum". All fields are combined with logical 'AND'.
"""
input attribute_type_enum_comparison_exp {
  _eq: attribute_type_enum
  _in: [attribute_type_enum!]
  _is_null: Boolean
  _neq: attribute_type_enum
  _nin: [attribute_type_enum!]
}

"""
input type for inserting data into table "attribute_type"
"""
input attribute_type_insert_input {
  attribute_selections: attribute_selections_arr_rel_insert_input
  attributes: attributes_arr_rel_insert_input
  comment: String
  value: String
}

"""aggregate max on columns"""
type attribute_type_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type attribute_type_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "attribute_type"
"""
type attribute_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attribute_type!]!
}

"""
input type for inserting object relation for remote table "attribute_type"
"""
input attribute_type_obj_rel_insert_input {
  data: attribute_type_insert_input!

  """upsert condition"""
  on_conflict: attribute_type_on_conflict
}

"""
on_conflict condition type for table "attribute_type"
"""
input attribute_type_on_conflict {
  constraint: attribute_type_constraint!
  update_columns: [attribute_type_update_column!]! = []
  where: attribute_type_bool_exp
}

"""Ordering options when selecting data from "attribute_type"."""
input attribute_type_order_by {
  attribute_selections_aggregate: attribute_selections_aggregate_order_by
  attributes_aggregate: attributes_aggregate_order_by
  comment: order_by
  value: order_by
}

"""primary key columns input for table: attribute_type"""
input attribute_type_pk_columns_input {
  value: String!
}

"""
select columns of table "attribute_type"
"""
enum attribute_type_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "attribute_type"
"""
input attribute_type_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "attribute_type"
"""
input attribute_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attribute_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attribute_type_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "attribute_type"
"""
enum attribute_type_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input attribute_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: attribute_type_set_input

  """filter the rows which have to be updated"""
  where: attribute_type_bool_exp!
}

"""Each record represents the a value of a specific attribute."""
type attribute_values {
  """An object relationship"""
  attribute: attributes!
  attribute_id: uuid!

  """An array relationship"""
  attribute_preferences(
    """distinct select on columns"""
    distinct_on: [attribute_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_preferences_order_by!]

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): [attribute_preferences!]!

  """An aggregate relationship"""
  attribute_preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_preferences_order_by!]

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): attribute_preferences_aggregate!

  """An array relationship"""
  attribute_selections(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): [attribute_selections!]!

  """An aggregate relationship"""
  attribute_selections_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): attribute_selections_aggregate!
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!
  key: String!
  updated_at: timestamptz!
  value: String!
}

"""
aggregated selection of "attribute_values"
"""
type attribute_values_aggregate {
  aggregate: attribute_values_aggregate_fields
  nodes: [attribute_values!]!
}

input attribute_values_aggregate_bool_exp {
  count: attribute_values_aggregate_bool_exp_count
}

input attribute_values_aggregate_bool_exp_count {
  arguments: [attribute_values_select_column!]
  distinct: Boolean
  filter: attribute_values_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "attribute_values"
"""
type attribute_values_aggregate_fields {
  avg: attribute_values_avg_fields
  count(columns: [attribute_values_select_column!], distinct: Boolean): Int!
  max: attribute_values_max_fields
  min: attribute_values_min_fields
  stddev: attribute_values_stddev_fields
  stddev_pop: attribute_values_stddev_pop_fields
  stddev_samp: attribute_values_stddev_samp_fields
  sum: attribute_values_sum_fields
  var_pop: attribute_values_var_pop_fields
  var_samp: attribute_values_var_samp_fields
  variance: attribute_values_variance_fields
}

"""
order by aggregate values of table "attribute_values"
"""
input attribute_values_aggregate_order_by {
  avg: attribute_values_avg_order_by
  count: order_by
  max: attribute_values_max_order_by
  min: attribute_values_min_order_by
  stddev: attribute_values_stddev_order_by
  stddev_pop: attribute_values_stddev_pop_order_by
  stddev_samp: attribute_values_stddev_samp_order_by
  sum: attribute_values_sum_order_by
  var_pop: attribute_values_var_pop_order_by
  var_samp: attribute_values_var_samp_order_by
  variance: attribute_values_variance_order_by
}

"""
input type for inserting array relation for remote table "attribute_values"
"""
input attribute_values_arr_rel_insert_input {
  data: [attribute_values_insert_input!]!

  """upsert condition"""
  on_conflict: attribute_values_on_conflict
}

"""aggregate avg on columns"""
type attribute_values_avg_fields {
  deleted_at: Float
}

"""
order by avg() on columns of table "attribute_values"
"""
input attribute_values_avg_order_by {
  deleted_at: order_by
}

"""
Boolean expression to filter rows from the table "attribute_values". All fields are combined with a logical 'AND'.
"""
input attribute_values_bool_exp {
  _and: [attribute_values_bool_exp!]
  _not: attribute_values_bool_exp
  _or: [attribute_values_bool_exp!]
  attribute: attributes_bool_exp
  attribute_id: uuid_comparison_exp
  attribute_preferences: attribute_preferences_bool_exp
  attribute_preferences_aggregate: attribute_preferences_aggregate_bool_exp
  attribute_selections: attribute_selections_bool_exp
  attribute_selections_aggregate: attribute_selections_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  key: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "attribute_values"
"""
enum attribute_values_constraint {
  """
  unique or primary key constraint on columns "key"
  """
  attribute_values_key_key

  """
  unique or primary key constraint on columns "id"
  """
  attribute_values_pkey

  """
  unique or primary key constraint on columns "value", "attribute_id"
  """
  attribute_values_value_attribute_id_key
}

"""
input type for incrementing numeric columns in table "attribute_values"
"""
input attribute_values_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "attribute_values"
"""
input attribute_values_insert_input {
  attribute: attributes_obj_rel_insert_input
  attribute_id: uuid
  attribute_preferences: attribute_preferences_arr_rel_insert_input
  attribute_selections: attribute_selections_arr_rel_insert_input
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  key: String
  updated_at: timestamptz
  value: String
}

"""aggregate max on columns"""
type attribute_values_max_fields {
  attribute_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  key: String
  updated_at: timestamptz
  value: String
}

"""
order by max() on columns of table "attribute_values"
"""
input attribute_values_max_order_by {
  attribute_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  key: order_by
  updated_at: order_by
  value: order_by
}

"""aggregate min on columns"""
type attribute_values_min_fields {
  attribute_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  key: String
  updated_at: timestamptz
  value: String
}

"""
order by min() on columns of table "attribute_values"
"""
input attribute_values_min_order_by {
  attribute_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  key: order_by
  updated_at: order_by
  value: order_by
}

"""
response of any mutation on the table "attribute_values"
"""
type attribute_values_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attribute_values!]!
}

"""
input type for inserting object relation for remote table "attribute_values"
"""
input attribute_values_obj_rel_insert_input {
  data: attribute_values_insert_input!

  """upsert condition"""
  on_conflict: attribute_values_on_conflict
}

"""
on_conflict condition type for table "attribute_values"
"""
input attribute_values_on_conflict {
  constraint: attribute_values_constraint!
  update_columns: [attribute_values_update_column!]! = []
  where: attribute_values_bool_exp
}

"""Ordering options when selecting data from "attribute_values"."""
input attribute_values_order_by {
  attribute: attributes_order_by
  attribute_id: order_by
  attribute_preferences_aggregate: attribute_preferences_aggregate_order_by
  attribute_selections_aggregate: attribute_selections_aggregate_order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  key: order_by
  updated_at: order_by
  value: order_by
}

"""primary key columns input for table: attribute_values"""
input attribute_values_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attribute_values"
"""
enum attribute_values_select_column {
  """column name"""
  attribute_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  key

  """column name"""
  updated_at

  """column name"""
  value
}

"""
input type for updating data in table "attribute_values"
"""
input attribute_values_set_input {
  attribute_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  key: String
  updated_at: timestamptz
  value: String
}

"""aggregate stddev on columns"""
type attribute_values_stddev_fields {
  deleted_at: Float
}

"""
order by stddev() on columns of table "attribute_values"
"""
input attribute_values_stddev_order_by {
  deleted_at: order_by
}

"""aggregate stddev_pop on columns"""
type attribute_values_stddev_pop_fields {
  deleted_at: Float
}

"""
order by stddev_pop() on columns of table "attribute_values"
"""
input attribute_values_stddev_pop_order_by {
  deleted_at: order_by
}

"""aggregate stddev_samp on columns"""
type attribute_values_stddev_samp_fields {
  deleted_at: Float
}

"""
order by stddev_samp() on columns of table "attribute_values"
"""
input attribute_values_stddev_samp_order_by {
  deleted_at: order_by
}

"""
Streaming cursor of the table "attribute_values"
"""
input attribute_values_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attribute_values_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attribute_values_stream_cursor_value_input {
  attribute_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  key: String
  updated_at: timestamptz
  value: String
}

"""aggregate sum on columns"""
type attribute_values_sum_fields {
  deleted_at: Int
}

"""
order by sum() on columns of table "attribute_values"
"""
input attribute_values_sum_order_by {
  deleted_at: order_by
}

"""
update columns of table "attribute_values"
"""
enum attribute_values_update_column {
  """column name"""
  attribute_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  key

  """column name"""
  updated_at

  """column name"""
  value
}

input attribute_values_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: attribute_values_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: attribute_values_set_input

  """filter the rows which have to be updated"""
  where: attribute_values_bool_exp!
}

"""aggregate var_pop on columns"""
type attribute_values_var_pop_fields {
  deleted_at: Float
}

"""
order by var_pop() on columns of table "attribute_values"
"""
input attribute_values_var_pop_order_by {
  deleted_at: order_by
}

"""aggregate var_samp on columns"""
type attribute_values_var_samp_fields {
  deleted_at: Float
}

"""
order by var_samp() on columns of table "attribute_values"
"""
input attribute_values_var_samp_order_by {
  deleted_at: order_by
}

"""aggregate variance on columns"""
type attribute_values_variance_fields {
  deleted_at: Float
}

"""
order by variance() on columns of table "attribute_values"
"""
input attribute_values_variance_order_by {
  deleted_at: order_by
}

"""Each record represents the name of a single attribute."""
type attributes {
  """An array relationship"""
  attribute_attribute_groups(
    """distinct select on columns"""
    distinct_on: [attribute_attribute_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_attribute_group_order_by!]

    """filter the rows returned"""
    where: attribute_attribute_group_bool_exp
  ): [attribute_attribute_group!]!

  """An aggregate relationship"""
  attribute_attribute_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_attribute_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_attribute_group_order_by!]

    """filter the rows returned"""
    where: attribute_attribute_group_bool_exp
  ): attribute_attribute_group_aggregate!

  """An array relationship"""
  attribute_preferences(
    """distinct select on columns"""
    distinct_on: [attribute_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_preferences_order_by!]

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): [attribute_preferences!]!

  """An aggregate relationship"""
  attribute_preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_preferences_order_by!]

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): attribute_preferences_aggregate!

  """An object relationship"""
  attribute_type: attribute_type!

  """An array relationship"""
  attribute_values(
    """distinct select on columns"""
    distinct_on: [attribute_values_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_values_order_by!]

    """filter the rows returned"""
    where: attribute_values_bool_exp
  ): [attribute_values!]!

  """An aggregate relationship"""
  attribute_values_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_values_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_values_order_by!]

    """filter the rows returned"""
    where: attribute_values_bool_exp
  ): attribute_values_aggregate!
  created_at: timestamptz!
  deleted_at: Int!
  i18n_values_required: Boolean!
  id: uuid!
  name: String!
  required: Boolean!
  type: attribute_type_enum!
  updated_at: timestamptz!
}

"""
aggregated selection of "attributes"
"""
type attributes_aggregate {
  aggregate: attributes_aggregate_fields
  nodes: [attributes!]!
}

input attributes_aggregate_bool_exp {
  bool_and: attributes_aggregate_bool_exp_bool_and
  bool_or: attributes_aggregate_bool_exp_bool_or
  count: attributes_aggregate_bool_exp_count
}

input attributes_aggregate_bool_exp_bool_and {
  arguments: attributes_select_column_attributes_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: attributes_bool_exp
  predicate: Boolean_comparison_exp!
}

input attributes_aggregate_bool_exp_bool_or {
  arguments: attributes_select_column_attributes_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: attributes_bool_exp
  predicate: Boolean_comparison_exp!
}

input attributes_aggregate_bool_exp_count {
  arguments: [attributes_select_column!]
  distinct: Boolean
  filter: attributes_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "attributes"
"""
type attributes_aggregate_fields {
  avg: attributes_avg_fields
  count(columns: [attributes_select_column!], distinct: Boolean): Int!
  max: attributes_max_fields
  min: attributes_min_fields
  stddev: attributes_stddev_fields
  stddev_pop: attributes_stddev_pop_fields
  stddev_samp: attributes_stddev_samp_fields
  sum: attributes_sum_fields
  var_pop: attributes_var_pop_fields
  var_samp: attributes_var_samp_fields
  variance: attributes_variance_fields
}

"""
order by aggregate values of table "attributes"
"""
input attributes_aggregate_order_by {
  avg: attributes_avg_order_by
  count: order_by
  max: attributes_max_order_by
  min: attributes_min_order_by
  stddev: attributes_stddev_order_by
  stddev_pop: attributes_stddev_pop_order_by
  stddev_samp: attributes_stddev_samp_order_by
  sum: attributes_sum_order_by
  var_pop: attributes_var_pop_order_by
  var_samp: attributes_var_samp_order_by
  variance: attributes_variance_order_by
}

"""
input type for inserting array relation for remote table "attributes"
"""
input attributes_arr_rel_insert_input {
  data: [attributes_insert_input!]!

  """upsert condition"""
  on_conflict: attributes_on_conflict
}

"""aggregate avg on columns"""
type attributes_avg_fields {
  deleted_at: Float
}

"""
order by avg() on columns of table "attributes"
"""
input attributes_avg_order_by {
  deleted_at: order_by
}

"""
Boolean expression to filter rows from the table "attributes". All fields are combined with a logical 'AND'.
"""
input attributes_bool_exp {
  _and: [attributes_bool_exp!]
  _not: attributes_bool_exp
  _or: [attributes_bool_exp!]
  attribute_attribute_groups: attribute_attribute_group_bool_exp
  attribute_attribute_groups_aggregate: attribute_attribute_group_aggregate_bool_exp
  attribute_preferences: attribute_preferences_bool_exp
  attribute_preferences_aggregate: attribute_preferences_aggregate_bool_exp
  attribute_type: attribute_type_bool_exp
  attribute_values: attribute_values_bool_exp
  attribute_values_aggregate: attribute_values_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  i18n_values_required: Boolean_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  required: Boolean_comparison_exp
  type: attribute_type_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "attributes"
"""
enum attributes_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  attributes_name_key

  """
  unique or primary key constraint on columns "id"
  """
  attributes_pkey
}

"""
input type for incrementing numeric columns in table "attributes"
"""
input attributes_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "attributes"
"""
input attributes_insert_input {
  attribute_attribute_groups: attribute_attribute_group_arr_rel_insert_input
  attribute_preferences: attribute_preferences_arr_rel_insert_input
  attribute_type: attribute_type_obj_rel_insert_input
  attribute_values: attribute_values_arr_rel_insert_input
  created_at: timestamptz
  deleted_at: Int
  i18n_values_required: Boolean
  id: uuid
  name: String
  required: Boolean
  type: attribute_type_enum
  updated_at: timestamptz
}

"""aggregate max on columns"""
type attributes_max_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "attributes"
"""
input attributes_max_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type attributes_min_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "attributes"
"""
input attributes_min_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "attributes"
"""
type attributes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attributes!]!
}

"""
input type for inserting object relation for remote table "attributes"
"""
input attributes_obj_rel_insert_input {
  data: attributes_insert_input!

  """upsert condition"""
  on_conflict: attributes_on_conflict
}

"""
on_conflict condition type for table "attributes"
"""
input attributes_on_conflict {
  constraint: attributes_constraint!
  update_columns: [attributes_update_column!]! = []
  where: attributes_bool_exp
}

"""Ordering options when selecting data from "attributes"."""
input attributes_order_by {
  attribute_attribute_groups_aggregate: attribute_attribute_group_aggregate_order_by
  attribute_preferences_aggregate: attribute_preferences_aggregate_order_by
  attribute_type: attribute_type_order_by
  attribute_values_aggregate: attribute_values_aggregate_order_by
  created_at: order_by
  deleted_at: order_by
  i18n_values_required: order_by
  id: order_by
  name: order_by
  required: order_by
  type: order_by
  updated_at: order_by
}

"""primary key columns input for table: attributes"""
input attributes_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attributes"
"""
enum attributes_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  i18n_values_required

  """column name"""
  id

  """column name"""
  name

  """column name"""
  required

  """column name"""
  type

  """column name"""
  updated_at
}

"""
select "attributes_aggregate_bool_exp_bool_and_arguments_columns" columns of table "attributes"
"""
enum attributes_select_column_attributes_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  i18n_values_required

  """column name"""
  required
}

"""
select "attributes_aggregate_bool_exp_bool_or_arguments_columns" columns of table "attributes"
"""
enum attributes_select_column_attributes_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  i18n_values_required

  """column name"""
  required
}

"""
input type for updating data in table "attributes"
"""
input attributes_set_input {
  created_at: timestamptz
  deleted_at: Int
  i18n_values_required: Boolean
  id: uuid
  name: String
  required: Boolean
  type: attribute_type_enum
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type attributes_stddev_fields {
  deleted_at: Float
}

"""
order by stddev() on columns of table "attributes"
"""
input attributes_stddev_order_by {
  deleted_at: order_by
}

"""aggregate stddev_pop on columns"""
type attributes_stddev_pop_fields {
  deleted_at: Float
}

"""
order by stddev_pop() on columns of table "attributes"
"""
input attributes_stddev_pop_order_by {
  deleted_at: order_by
}

"""aggregate stddev_samp on columns"""
type attributes_stddev_samp_fields {
  deleted_at: Float
}

"""
order by stddev_samp() on columns of table "attributes"
"""
input attributes_stddev_samp_order_by {
  deleted_at: order_by
}

"""
Streaming cursor of the table "attributes"
"""
input attributes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attributes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attributes_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: Int
  i18n_values_required: Boolean
  id: uuid
  name: String
  required: Boolean
  type: attribute_type_enum
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type attributes_sum_fields {
  deleted_at: Int
}

"""
order by sum() on columns of table "attributes"
"""
input attributes_sum_order_by {
  deleted_at: order_by
}

"""
update columns of table "attributes"
"""
enum attributes_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  i18n_values_required

  """column name"""
  id

  """column name"""
  name

  """column name"""
  required

  """column name"""
  type

  """column name"""
  updated_at
}

input attributes_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: attributes_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: attributes_set_input

  """filter the rows which have to be updated"""
  where: attributes_bool_exp!
}

"""aggregate var_pop on columns"""
type attributes_var_pop_fields {
  deleted_at: Float
}

"""
order by var_pop() on columns of table "attributes"
"""
input attributes_var_pop_order_by {
  deleted_at: order_by
}

"""aggregate var_samp on columns"""
type attributes_var_samp_fields {
  deleted_at: Float
}

"""
order by var_samp() on columns of table "attributes"
"""
input attributes_var_samp_order_by {
  deleted_at: order_by
}

"""aggregate variance on columns"""
type attributes_variance_fields {
  deleted_at: Float
}

"""
order by variance() on columns of table "attributes"
"""
input attributes_variance_order_by {
  deleted_at: order_by
}

"""
columns and relationships of "badges"
"""
type badges {
  name: String!
}

"""
aggregated selection of "badges"
"""
type badges_aggregate {
  aggregate: badges_aggregate_fields
  nodes: [badges!]!
}

"""
aggregate fields of "badges"
"""
type badges_aggregate_fields {
  count(columns: [badges_select_column!], distinct: Boolean): Int!
  max: badges_max_fields
  min: badges_min_fields
}

"""
Boolean expression to filter rows from the table "badges". All fields are combined with a logical 'AND'.
"""
input badges_bool_exp {
  _and: [badges_bool_exp!]
  _not: badges_bool_exp
  _or: [badges_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "badges"
"""
enum badges_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  badges_pkey
}

enum badges_enum {
  RELIABLE
  SHIPS_FAST
}

"""
Boolean expression to compare columns of type "badges_enum". All fields are combined with logical 'AND'.
"""
input badges_enum_comparison_exp {
  _eq: badges_enum
  _in: [badges_enum!]
  _is_null: Boolean
  _neq: badges_enum
  _nin: [badges_enum!]
}

"""
input type for inserting data into table "badges"
"""
input badges_insert_input {
  name: String
}

"""aggregate max on columns"""
type badges_max_fields {
  name: String
}

"""aggregate min on columns"""
type badges_min_fields {
  name: String
}

"""
response of any mutation on the table "badges"
"""
type badges_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [badges!]!
}

"""
input type for inserting object relation for remote table "badges"
"""
input badges_obj_rel_insert_input {
  data: badges_insert_input!

  """upsert condition"""
  on_conflict: badges_on_conflict
}

"""
on_conflict condition type for table "badges"
"""
input badges_on_conflict {
  constraint: badges_constraint!
  update_columns: [badges_update_column!]! = []
  where: badges_bool_exp
}

"""Ordering options when selecting data from "badges"."""
input badges_order_by {
  name: order_by
}

"""primary key columns input for table: badges"""
input badges_pk_columns_input {
  name: String!
}

"""
select columns of table "badges"
"""
enum badges_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "badges"
"""
input badges_set_input {
  name: String
}

"""
Streaming cursor of the table "badges"
"""
input badges_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: badges_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input badges_stream_cursor_value_input {
  name: String
}

"""
update columns of table "badges"
"""
enum badges_update_column {
  """column name"""
  name
}

input badges_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: badges_set_input

  """filter the rows which have to be updated"""
  where: badges_bool_exp!
}

"""Holds blocked users and their blockers."""
type blocks {
  """An object relationship"""
  blockedUser: users!
  blocked_id: uuid!

  """An object relationship"""
  blockerUser: users!
  blocker_id: uuid!
}

"""
aggregated selection of "blocks"
"""
type blocks_aggregate {
  aggregate: blocks_aggregate_fields
  nodes: [blocks!]!
}

input blocks_aggregate_bool_exp {
  count: blocks_aggregate_bool_exp_count
}

input blocks_aggregate_bool_exp_count {
  arguments: [blocks_select_column!]
  distinct: Boolean
  filter: blocks_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "blocks"
"""
type blocks_aggregate_fields {
  count(columns: [blocks_select_column!], distinct: Boolean): Int!
  max: blocks_max_fields
  min: blocks_min_fields
}

"""
order by aggregate values of table "blocks"
"""
input blocks_aggregate_order_by {
  count: order_by
  max: blocks_max_order_by
  min: blocks_min_order_by
}

"""
input type for inserting array relation for remote table "blocks"
"""
input blocks_arr_rel_insert_input {
  data: [blocks_insert_input!]!

  """upsert condition"""
  on_conflict: blocks_on_conflict
}

"""
Boolean expression to filter rows from the table "blocks". All fields are combined with a logical 'AND'.
"""
input blocks_bool_exp {
  _and: [blocks_bool_exp!]
  _not: blocks_bool_exp
  _or: [blocks_bool_exp!]
  blockedUser: users_bool_exp
  blocked_id: uuid_comparison_exp
  blockerUser: users_bool_exp
  blocker_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "blocks"
"""
enum blocks_constraint {
  """
  unique or primary key constraint on columns "blocker_id", "blocked_id"
  """
  blocks_pkey
}

"""
input type for inserting data into table "blocks"
"""
input blocks_insert_input {
  blockedUser: users_obj_rel_insert_input
  blocked_id: uuid
  blockerUser: users_obj_rel_insert_input
  blocker_id: uuid
}

"""aggregate max on columns"""
type blocks_max_fields {
  blocked_id: uuid
  blocker_id: uuid
}

"""
order by max() on columns of table "blocks"
"""
input blocks_max_order_by {
  blocked_id: order_by
  blocker_id: order_by
}

"""aggregate min on columns"""
type blocks_min_fields {
  blocked_id: uuid
  blocker_id: uuid
}

"""
order by min() on columns of table "blocks"
"""
input blocks_min_order_by {
  blocked_id: order_by
  blocker_id: order_by
}

"""
response of any mutation on the table "blocks"
"""
type blocks_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [blocks!]!
}

"""
on_conflict condition type for table "blocks"
"""
input blocks_on_conflict {
  constraint: blocks_constraint!
  update_columns: [blocks_update_column!]! = []
  where: blocks_bool_exp
}

"""Ordering options when selecting data from "blocks"."""
input blocks_order_by {
  blockedUser: users_order_by
  blocked_id: order_by
  blockerUser: users_order_by
  blocker_id: order_by
}

"""primary key columns input for table: blocks"""
input blocks_pk_columns_input {
  blocked_id: uuid!
  blocker_id: uuid!
}

"""
select columns of table "blocks"
"""
enum blocks_select_column {
  """column name"""
  blocked_id

  """column name"""
  blocker_id
}

"""
input type for updating data in table "blocks"
"""
input blocks_set_input {
  blocked_id: uuid
  blocker_id: uuid
}

"""
Streaming cursor of the table "blocks"
"""
input blocks_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: blocks_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input blocks_stream_cursor_value_input {
  blocked_id: uuid
  blocker_id: uuid
}

"""
update columns of table "blocks"
"""
enum blocks_update_column {
  """column name"""
  blocked_id

  """column name"""
  blocker_id
}

input blocks_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: blocks_set_input

  """filter the rows which have to be updated"""
  where: blocks_bool_exp!
}

scalar bpchar

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input bpchar_comparison_exp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar

  """does the column match the given case-insensitive pattern"""
  _ilike: bpchar
  _in: [bpchar!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: bpchar
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: bpchar
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: bpchar
  _nin: [bpchar!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: bpchar

  """does the column NOT match the given pattern"""
  _nlike: bpchar

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: bpchar

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: bpchar

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: bpchar

  """does the column match the given SQL regular expression"""
  _similar: bpchar
}

"""
columns and relationships of "communication_preference_groups"
"""
type communication_preference_groups {
  """An array relationship"""
  communication_preferences(
    """distinct select on columns"""
    distinct_on: [communication_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_preferences_order_by!]

    """filter the rows returned"""
    where: communication_preferences_bool_exp
  ): [communication_preferences!]!

  """An aggregate relationship"""
  communication_preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [communication_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_preferences_order_by!]

    """filter the rows returned"""
    where: communication_preferences_bool_exp
  ): communication_preferences_aggregate!

  """An array relationship"""
  communication_templates(
    """distinct select on columns"""
    distinct_on: [communication_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_templates_order_by!]

    """filter the rows returned"""
    where: communication_templates_bool_exp
  ): [communication_templates!]!

  """An aggregate relationship"""
  communication_templates_aggregate(
    """distinct select on columns"""
    distinct_on: [communication_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_templates_order_by!]

    """filter the rows returned"""
    where: communication_templates_bool_exp
  ): communication_templates_aggregate!
  key: String!
}

"""
aggregated selection of "communication_preference_groups"
"""
type communication_preference_groups_aggregate {
  aggregate: communication_preference_groups_aggregate_fields
  nodes: [communication_preference_groups!]!
}

"""
aggregate fields of "communication_preference_groups"
"""
type communication_preference_groups_aggregate_fields {
  count(columns: [communication_preference_groups_select_column!], distinct: Boolean): Int!
  max: communication_preference_groups_max_fields
  min: communication_preference_groups_min_fields
}

"""
Boolean expression to filter rows from the table "communication_preference_groups". All fields are combined with a logical 'AND'.
"""
input communication_preference_groups_bool_exp {
  _and: [communication_preference_groups_bool_exp!]
  _not: communication_preference_groups_bool_exp
  _or: [communication_preference_groups_bool_exp!]
  communication_preferences: communication_preferences_bool_exp
  communication_preferences_aggregate: communication_preferences_aggregate_bool_exp
  communication_templates: communication_templates_bool_exp
  communication_templates_aggregate: communication_templates_aggregate_bool_exp
  key: String_comparison_exp
}

"""
unique or primary key constraints on table "communication_preference_groups"
"""
enum communication_preference_groups_constraint {
  """
  unique or primary key constraint on columns "key"
  """
  communication_preference_groups_pkey
}

"""
input type for inserting data into table "communication_preference_groups"
"""
input communication_preference_groups_insert_input {
  communication_preferences: communication_preferences_arr_rel_insert_input
  communication_templates: communication_templates_arr_rel_insert_input
  key: String
}

"""aggregate max on columns"""
type communication_preference_groups_max_fields {
  key: String
}

"""aggregate min on columns"""
type communication_preference_groups_min_fields {
  key: String
}

"""
response of any mutation on the table "communication_preference_groups"
"""
type communication_preference_groups_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [communication_preference_groups!]!
}

"""
input type for inserting object relation for remote table "communication_preference_groups"
"""
input communication_preference_groups_obj_rel_insert_input {
  data: communication_preference_groups_insert_input!

  """upsert condition"""
  on_conflict: communication_preference_groups_on_conflict
}

"""
on_conflict condition type for table "communication_preference_groups"
"""
input communication_preference_groups_on_conflict {
  constraint: communication_preference_groups_constraint!
  update_columns: [communication_preference_groups_update_column!]! = []
  where: communication_preference_groups_bool_exp
}

"""
Ordering options when selecting data from "communication_preference_groups".
"""
input communication_preference_groups_order_by {
  communication_preferences_aggregate: communication_preferences_aggregate_order_by
  communication_templates_aggregate: communication_templates_aggregate_order_by
  key: order_by
}

"""primary key columns input for table: communication_preference_groups"""
input communication_preference_groups_pk_columns_input {
  key: String!
}

"""
select columns of table "communication_preference_groups"
"""
enum communication_preference_groups_select_column {
  """column name"""
  key
}

"""
input type for updating data in table "communication_preference_groups"
"""
input communication_preference_groups_set_input {
  key: String
}

"""
Streaming cursor of the table "communication_preference_groups"
"""
input communication_preference_groups_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: communication_preference_groups_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input communication_preference_groups_stream_cursor_value_input {
  key: String
}

"""
update columns of table "communication_preference_groups"
"""
enum communication_preference_groups_update_column {
  """column name"""
  key
}

input communication_preference_groups_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: communication_preference_groups_set_input

  """filter the rows which have to be updated"""
  where: communication_preference_groups_bool_exp!
}

"""SMS and push communication preferences."""
type communication_preferences {
  """An object relationship"""
  communication_preference_group: communication_preference_groups!
  communication_preference_group_key: String!
  receive_email: Boolean!
  receive_push_notification: Boolean!

  """An object relationship"""
  user_preference: user_preferences!
  user_preference_id: uuid!
}

"""
aggregated selection of "communication_preferences"
"""
type communication_preferences_aggregate {
  aggregate: communication_preferences_aggregate_fields
  nodes: [communication_preferences!]!
}

input communication_preferences_aggregate_bool_exp {
  bool_and: communication_preferences_aggregate_bool_exp_bool_and
  bool_or: communication_preferences_aggregate_bool_exp_bool_or
  count: communication_preferences_aggregate_bool_exp_count
}

input communication_preferences_aggregate_bool_exp_bool_and {
  arguments: communication_preferences_select_column_communication_preferences_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: communication_preferences_bool_exp
  predicate: Boolean_comparison_exp!
}

input communication_preferences_aggregate_bool_exp_bool_or {
  arguments: communication_preferences_select_column_communication_preferences_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: communication_preferences_bool_exp
  predicate: Boolean_comparison_exp!
}

input communication_preferences_aggregate_bool_exp_count {
  arguments: [communication_preferences_select_column!]
  distinct: Boolean
  filter: communication_preferences_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "communication_preferences"
"""
type communication_preferences_aggregate_fields {
  count(columns: [communication_preferences_select_column!], distinct: Boolean): Int!
  max: communication_preferences_max_fields
  min: communication_preferences_min_fields
}

"""
order by aggregate values of table "communication_preferences"
"""
input communication_preferences_aggregate_order_by {
  count: order_by
  max: communication_preferences_max_order_by
  min: communication_preferences_min_order_by
}

"""
input type for inserting array relation for remote table "communication_preferences"
"""
input communication_preferences_arr_rel_insert_input {
  data: [communication_preferences_insert_input!]!

  """upsert condition"""
  on_conflict: communication_preferences_on_conflict
}

"""
Boolean expression to filter rows from the table "communication_preferences". All fields are combined with a logical 'AND'.
"""
input communication_preferences_bool_exp {
  _and: [communication_preferences_bool_exp!]
  _not: communication_preferences_bool_exp
  _or: [communication_preferences_bool_exp!]
  communication_preference_group: communication_preference_groups_bool_exp
  communication_preference_group_key: String_comparison_exp
  receive_email: Boolean_comparison_exp
  receive_push_notification: Boolean_comparison_exp
  user_preference: user_preferences_bool_exp
  user_preference_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "communication_preferences"
"""
enum communication_preferences_constraint {
  """
  unique or primary key constraint on columns "user_preference_id", "communication_preference_group_key"
  """
  communication_preferences_pkey
}

"""
input type for inserting data into table "communication_preferences"
"""
input communication_preferences_insert_input {
  communication_preference_group: communication_preference_groups_obj_rel_insert_input
  communication_preference_group_key: String
  receive_email: Boolean
  receive_push_notification: Boolean
  user_preference: user_preferences_obj_rel_insert_input
  user_preference_id: uuid
}

"""aggregate max on columns"""
type communication_preferences_max_fields {
  communication_preference_group_key: String
  user_preference_id: uuid
}

"""
order by max() on columns of table "communication_preferences"
"""
input communication_preferences_max_order_by {
  communication_preference_group_key: order_by
  user_preference_id: order_by
}

"""aggregate min on columns"""
type communication_preferences_min_fields {
  communication_preference_group_key: String
  user_preference_id: uuid
}

"""
order by min() on columns of table "communication_preferences"
"""
input communication_preferences_min_order_by {
  communication_preference_group_key: order_by
  user_preference_id: order_by
}

"""
response of any mutation on the table "communication_preferences"
"""
type communication_preferences_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [communication_preferences!]!
}

"""
on_conflict condition type for table "communication_preferences"
"""
input communication_preferences_on_conflict {
  constraint: communication_preferences_constraint!
  update_columns: [communication_preferences_update_column!]! = []
  where: communication_preferences_bool_exp
}

"""Ordering options when selecting data from "communication_preferences"."""
input communication_preferences_order_by {
  communication_preference_group: communication_preference_groups_order_by
  communication_preference_group_key: order_by
  receive_email: order_by
  receive_push_notification: order_by
  user_preference: user_preferences_order_by
  user_preference_id: order_by
}

"""primary key columns input for table: communication_preferences"""
input communication_preferences_pk_columns_input {
  communication_preference_group_key: String!
  user_preference_id: uuid!
}

"""
select columns of table "communication_preferences"
"""
enum communication_preferences_select_column {
  """column name"""
  communication_preference_group_key

  """column name"""
  receive_email

  """column name"""
  receive_push_notification

  """column name"""
  user_preference_id
}

"""
select "communication_preferences_aggregate_bool_exp_bool_and_arguments_columns" columns of table "communication_preferences"
"""
enum communication_preferences_select_column_communication_preferences_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  receive_email

  """column name"""
  receive_push_notification
}

"""
select "communication_preferences_aggregate_bool_exp_bool_or_arguments_columns" columns of table "communication_preferences"
"""
enum communication_preferences_select_column_communication_preferences_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  receive_email

  """column name"""
  receive_push_notification
}

"""
input type for updating data in table "communication_preferences"
"""
input communication_preferences_set_input {
  communication_preference_group_key: String
  receive_email: Boolean
  receive_push_notification: Boolean
  user_preference_id: uuid
}

"""
Streaming cursor of the table "communication_preferences"
"""
input communication_preferences_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: communication_preferences_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input communication_preferences_stream_cursor_value_input {
  communication_preference_group_key: String
  receive_email: Boolean
  receive_push_notification: Boolean
  user_preference_id: uuid
}

"""
update columns of table "communication_preferences"
"""
enum communication_preferences_update_column {
  """column name"""
  communication_preference_group_key

  """column name"""
  receive_email

  """column name"""
  receive_push_notification

  """column name"""
  user_preference_id
}

input communication_preferences_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: communication_preferences_set_input

  """filter the rows which have to be updated"""
  where: communication_preferences_bool_exp!
}

"""All available communication types."""
type communication_templates {
  """An object relationship"""
  communication_preference_group: communication_preference_groups
  communication_preference_group_key: String
  deep_link_path: String
  key: String!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!
  push_text: String
  push_title: String
}

"""
aggregated selection of "communication_templates"
"""
type communication_templates_aggregate {
  aggregate: communication_templates_aggregate_fields
  nodes: [communication_templates!]!
}

input communication_templates_aggregate_bool_exp {
  count: communication_templates_aggregate_bool_exp_count
}

input communication_templates_aggregate_bool_exp_count {
  arguments: [communication_templates_select_column!]
  distinct: Boolean
  filter: communication_templates_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "communication_templates"
"""
type communication_templates_aggregate_fields {
  count(columns: [communication_templates_select_column!], distinct: Boolean): Int!
  max: communication_templates_max_fields
  min: communication_templates_min_fields
}

"""
order by aggregate values of table "communication_templates"
"""
input communication_templates_aggregate_order_by {
  count: order_by
  max: communication_templates_max_order_by
  min: communication_templates_min_order_by
}

"""
input type for inserting array relation for remote table "communication_templates"
"""
input communication_templates_arr_rel_insert_input {
  data: [communication_templates_insert_input!]!

  """upsert condition"""
  on_conflict: communication_templates_on_conflict
}

"""
Boolean expression to filter rows from the table "communication_templates". All fields are combined with a logical 'AND'.
"""
input communication_templates_bool_exp {
  _and: [communication_templates_bool_exp!]
  _not: communication_templates_bool_exp
  _or: [communication_templates_bool_exp!]
  communication_preference_group: communication_preference_groups_bool_exp
  communication_preference_group_key: String_comparison_exp
  deep_link_path: String_comparison_exp
  key: String_comparison_exp
  notifications: notifications_bool_exp
  notifications_aggregate: notifications_aggregate_bool_exp
  push_text: String_comparison_exp
  push_title: String_comparison_exp
}

"""
unique or primary key constraints on table "communication_templates"
"""
enum communication_templates_constraint {
  """
  unique or primary key constraint on columns "key"
  """
  communication_templates_pkey
}

"""
input type for inserting data into table "communication_templates"
"""
input communication_templates_insert_input {
  communication_preference_group: communication_preference_groups_obj_rel_insert_input
  communication_preference_group_key: String
  deep_link_path: String
  key: String
  notifications: notifications_arr_rel_insert_input
  push_text: String
  push_title: String
}

"""aggregate max on columns"""
type communication_templates_max_fields {
  communication_preference_group_key: String
  deep_link_path: String
  key: String
  push_text: String
  push_title: String
}

"""
order by max() on columns of table "communication_templates"
"""
input communication_templates_max_order_by {
  communication_preference_group_key: order_by
  deep_link_path: order_by
  key: order_by
  push_text: order_by
  push_title: order_by
}

"""aggregate min on columns"""
type communication_templates_min_fields {
  communication_preference_group_key: String
  deep_link_path: String
  key: String
  push_text: String
  push_title: String
}

"""
order by min() on columns of table "communication_templates"
"""
input communication_templates_min_order_by {
  communication_preference_group_key: order_by
  deep_link_path: order_by
  key: order_by
  push_text: order_by
  push_title: order_by
}

"""
response of any mutation on the table "communication_templates"
"""
type communication_templates_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [communication_templates!]!
}

"""
input type for inserting object relation for remote table "communication_templates"
"""
input communication_templates_obj_rel_insert_input {
  data: communication_templates_insert_input!

  """upsert condition"""
  on_conflict: communication_templates_on_conflict
}

"""
on_conflict condition type for table "communication_templates"
"""
input communication_templates_on_conflict {
  constraint: communication_templates_constraint!
  update_columns: [communication_templates_update_column!]! = []
  where: communication_templates_bool_exp
}

"""Ordering options when selecting data from "communication_templates"."""
input communication_templates_order_by {
  communication_preference_group: communication_preference_groups_order_by
  communication_preference_group_key: order_by
  deep_link_path: order_by
  key: order_by
  notifications_aggregate: notifications_aggregate_order_by
  push_text: order_by
  push_title: order_by
}

"""primary key columns input for table: communication_templates"""
input communication_templates_pk_columns_input {
  key: String!
}

"""
select columns of table "communication_templates"
"""
enum communication_templates_select_column {
  """column name"""
  communication_preference_group_key

  """column name"""
  deep_link_path

  """column name"""
  key

  """column name"""
  push_text

  """column name"""
  push_title
}

"""
input type for updating data in table "communication_templates"
"""
input communication_templates_set_input {
  communication_preference_group_key: String
  deep_link_path: String
  key: String
  push_text: String
  push_title: String
}

"""
Streaming cursor of the table "communication_templates"
"""
input communication_templates_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: communication_templates_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input communication_templates_stream_cursor_value_input {
  communication_preference_group_key: String
  deep_link_path: String
  key: String
  push_text: String
  push_title: String
}

"""
update columns of table "communication_templates"
"""
enum communication_templates_update_column {
  """column name"""
  communication_preference_group_key

  """column name"""
  deep_link_path

  """column name"""
  key

  """column name"""
  push_text

  """column name"""
  push_title
}

input communication_templates_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: communication_templates_set_input

  """filter the rows which have to be updated"""
  where: communication_templates_bool_exp!
}

"""Available currencies."""
type currencies {
  currency: String!
}

"""
aggregated selection of "currencies"
"""
type currencies_aggregate {
  aggregate: currencies_aggregate_fields
  nodes: [currencies!]!
}

"""
aggregate fields of "currencies"
"""
type currencies_aggregate_fields {
  count(columns: [currencies_select_column!], distinct: Boolean): Int!
  max: currencies_max_fields
  min: currencies_min_fields
}

"""
Boolean expression to filter rows from the table "currencies". All fields are combined with a logical 'AND'.
"""
input currencies_bool_exp {
  _and: [currencies_bool_exp!]
  _not: currencies_bool_exp
  _or: [currencies_bool_exp!]
  currency: String_comparison_exp
}

"""
unique or primary key constraints on table "currencies"
"""
enum currencies_constraint {
  """
  unique or primary key constraint on columns "currency"
  """
  currencies_pkey
}

enum currencies_enum {
  USD
}

"""
Boolean expression to compare columns of type "currencies_enum". All fields are combined with logical 'AND'.
"""
input currencies_enum_comparison_exp {
  _eq: currencies_enum
  _in: [currencies_enum!]
  _is_null: Boolean
  _neq: currencies_enum
  _nin: [currencies_enum!]
}

"""
input type for inserting data into table "currencies"
"""
input currencies_insert_input {
  currency: String
}

"""aggregate max on columns"""
type currencies_max_fields {
  currency: String
}

"""aggregate min on columns"""
type currencies_min_fields {
  currency: String
}

"""
response of any mutation on the table "currencies"
"""
type currencies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [currencies!]!
}

"""
on_conflict condition type for table "currencies"
"""
input currencies_on_conflict {
  constraint: currencies_constraint!
  update_columns: [currencies_update_column!]! = []
  where: currencies_bool_exp
}

"""Ordering options when selecting data from "currencies"."""
input currencies_order_by {
  currency: order_by
}

"""primary key columns input for table: currencies"""
input currencies_pk_columns_input {
  currency: String!
}

"""
select columns of table "currencies"
"""
enum currencies_select_column {
  """column name"""
  currency
}

"""
input type for updating data in table "currencies"
"""
input currencies_set_input {
  currency: String
}

"""
Streaming cursor of the table "currencies"
"""
input currencies_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: currencies_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input currencies_stream_cursor_value_input {
  currency: String
}

"""
update columns of table "currencies"
"""
enum currencies_update_column {
  """column name"""
  currency
}

input currencies_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: currencies_set_input

  """filter the rows which have to be updated"""
  where: currencies_bool_exp!
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""Devices associated with users."""
type devices {
  created_at: timestamptz!
  fingerprint: String!
  id: uuid!
  token: String
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "devices"
"""
type devices_aggregate {
  aggregate: devices_aggregate_fields
  nodes: [devices!]!
}

input devices_aggregate_bool_exp {
  count: devices_aggregate_bool_exp_count
}

input devices_aggregate_bool_exp_count {
  arguments: [devices_select_column!]
  distinct: Boolean
  filter: devices_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "devices"
"""
type devices_aggregate_fields {
  count(columns: [devices_select_column!], distinct: Boolean): Int!
  max: devices_max_fields
  min: devices_min_fields
}

"""
order by aggregate values of table "devices"
"""
input devices_aggregate_order_by {
  count: order_by
  max: devices_max_order_by
  min: devices_min_order_by
}

"""
input type for inserting array relation for remote table "devices"
"""
input devices_arr_rel_insert_input {
  data: [devices_insert_input!]!

  """upsert condition"""
  on_conflict: devices_on_conflict
}

"""
Boolean expression to filter rows from the table "devices". All fields are combined with a logical 'AND'.
"""
input devices_bool_exp {
  _and: [devices_bool_exp!]
  _not: devices_bool_exp
  _or: [devices_bool_exp!]
  created_at: timestamptz_comparison_exp
  fingerprint: String_comparison_exp
  id: uuid_comparison_exp
  token: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "devices"
"""
enum devices_constraint {
  """
  unique or primary key constraint on columns "user_id", "fingerprint"
  """
  devices_fingerprint_user_id_key

  """
  unique or primary key constraint on columns "id"
  """
  devices_pkey
}

"""
input type for inserting data into table "devices"
"""
input devices_insert_input {
  created_at: timestamptz
  fingerprint: String
  id: uuid
  token: String
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type devices_max_fields {
  created_at: timestamptz
  fingerprint: String
  id: uuid
  token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "devices"
"""
input devices_max_order_by {
  created_at: order_by
  fingerprint: order_by
  id: order_by
  token: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type devices_min_fields {
  created_at: timestamptz
  fingerprint: String
  id: uuid
  token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "devices"
"""
input devices_min_order_by {
  created_at: order_by
  fingerprint: order_by
  id: order_by
  token: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "devices"
"""
type devices_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [devices!]!
}

"""
on_conflict condition type for table "devices"
"""
input devices_on_conflict {
  constraint: devices_constraint!
  update_columns: [devices_update_column!]! = []
  where: devices_bool_exp
}

"""Ordering options when selecting data from "devices"."""
input devices_order_by {
  created_at: order_by
  fingerprint: order_by
  id: order_by
  token: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: devices"""
input devices_pk_columns_input {
  id: uuid!
}

"""
select columns of table "devices"
"""
enum devices_select_column {
  """column name"""
  created_at

  """column name"""
  fingerprint

  """column name"""
  id

  """column name"""
  token

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "devices"
"""
input devices_set_input {
  created_at: timestamptz
  fingerprint: String
  id: uuid
  token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "devices"
"""
input devices_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: devices_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input devices_stream_cursor_value_input {
  created_at: timestamptz
  fingerprint: String
  id: uuid
  token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "devices"
"""
enum devices_update_column {
  """column name"""
  created_at

  """column name"""
  fingerprint

  """column name"""
  id

  """column name"""
  token

  """column name"""
  updated_at

  """column name"""
  user_id
}

input devices_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: devices_set_input

  """filter the rows which have to be updated"""
  where: devices_bool_exp!
}

"""Metadata for files stored externally."""
type files {
  created_at: timestamptz!
  deleted_at: Int!
  filename: String!
  id: uuid!
  inventory_item_id: uuid
  offer_item_issue_id: uuid
  order: Int
  owner_id: uuid
  path: String!
  product_id: uuid
  shipmentId: uuid
  type: String
  updated_at: timestamptz!
}

"""
aggregated selection of "files"
"""
type files_aggregate {
  aggregate: files_aggregate_fields
  nodes: [files!]!
}

input files_aggregate_bool_exp {
  count: files_aggregate_bool_exp_count
}

input files_aggregate_bool_exp_count {
  arguments: [files_select_column!]
  distinct: Boolean
  filter: files_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "files"
"""
type files_aggregate_fields {
  avg: files_avg_fields
  count(columns: [files_select_column!], distinct: Boolean): Int!
  max: files_max_fields
  min: files_min_fields
  stddev: files_stddev_fields
  stddev_pop: files_stddev_pop_fields
  stddev_samp: files_stddev_samp_fields
  sum: files_sum_fields
  var_pop: files_var_pop_fields
  var_samp: files_var_samp_fields
  variance: files_variance_fields
}

"""
order by aggregate values of table "files"
"""
input files_aggregate_order_by {
  avg: files_avg_order_by
  count: order_by
  max: files_max_order_by
  min: files_min_order_by
  stddev: files_stddev_order_by
  stddev_pop: files_stddev_pop_order_by
  stddev_samp: files_stddev_samp_order_by
  sum: files_sum_order_by
  var_pop: files_var_pop_order_by
  var_samp: files_var_samp_order_by
  variance: files_variance_order_by
}

"""
input type for inserting array relation for remote table "files"
"""
input files_arr_rel_insert_input {
  data: [files_insert_input!]!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""aggregate avg on columns"""
type files_avg_fields {
  deleted_at: Float
  order: Float
}

"""
order by avg() on columns of table "files"
"""
input files_avg_order_by {
  deleted_at: order_by
  order: order_by
}

"""
Boolean expression to filter rows from the table "files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp!]
  _not: files_bool_exp
  _or: [files_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  filename: String_comparison_exp
  id: uuid_comparison_exp
  inventory_item_id: uuid_comparison_exp
  offer_item_issue_id: uuid_comparison_exp
  order: Int_comparison_exp
  owner_id: uuid_comparison_exp
  path: String_comparison_exp
  product_id: uuid_comparison_exp
  shipmentId: uuid_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "files"
"""
enum files_constraint {
  """
  unique or primary key constraint on columns "path"
  """
  files_path_key

  """
  unique or primary key constraint on columns "id"
  """
  files_pkey
}

"""
input type for incrementing numeric columns in table "files"
"""
input files_inc_input {
  deleted_at: Int
  order: Int
}

"""
input type for inserting data into table "files"
"""
input files_insert_input {
  created_at: timestamptz
  deleted_at: Int
  filename: String
  id: uuid
  inventory_item_id: uuid
  offer_item_issue_id: uuid
  order: Int
  owner_id: uuid
  path: String
  product_id: uuid
  shipmentId: uuid
  type: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type files_max_fields {
  created_at: timestamptz
  deleted_at: Int
  filename: String
  id: uuid
  inventory_item_id: uuid
  offer_item_issue_id: uuid
  order: Int
  owner_id: uuid
  path: String
  product_id: uuid
  shipmentId: uuid
  type: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "files"
"""
input files_max_order_by {
  created_at: order_by
  deleted_at: order_by
  filename: order_by
  id: order_by
  inventory_item_id: order_by
  offer_item_issue_id: order_by
  order: order_by
  owner_id: order_by
  path: order_by
  product_id: order_by
  shipmentId: order_by
  type: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type files_min_fields {
  created_at: timestamptz
  deleted_at: Int
  filename: String
  id: uuid
  inventory_item_id: uuid
  offer_item_issue_id: uuid
  order: Int
  owner_id: uuid
  path: String
  product_id: uuid
  shipmentId: uuid
  type: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "files"
"""
input files_min_order_by {
  created_at: order_by
  deleted_at: order_by
  filename: order_by
  id: order_by
  inventory_item_id: order_by
  offer_item_issue_id: order_by
  order: order_by
  owner_id: order_by
  path: order_by
  product_id: order_by
  shipmentId: order_by
  type: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "files"
"""
type files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [files!]!
}

"""
input type for inserting object relation for remote table "files"
"""
input files_obj_rel_insert_input {
  data: files_insert_input!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""
on_conflict condition type for table "files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]! = []
  where: files_bool_exp
}

"""Ordering options when selecting data from "files"."""
input files_order_by {
  created_at: order_by
  deleted_at: order_by
  filename: order_by
  id: order_by
  inventory_item_id: order_by
  offer_item_issue_id: order_by
  order: order_by
  owner_id: order_by
  path: order_by
  product_id: order_by
  shipmentId: order_by
  type: order_by
  updated_at: order_by
}

"""primary key columns input for table: files"""
input files_pk_columns_input {
  id: uuid!
}

"""
select columns of table "files"
"""
enum files_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  filename

  """column name"""
  id

  """column name"""
  inventory_item_id

  """column name"""
  offer_item_issue_id

  """column name"""
  order

  """column name"""
  owner_id

  """column name"""
  path

  """column name"""
  product_id

  """column name"""
  shipmentId

  """column name"""
  type

  """column name"""
  updated_at
}

"""
input type for updating data in table "files"
"""
input files_set_input {
  created_at: timestamptz
  deleted_at: Int
  filename: String
  id: uuid
  inventory_item_id: uuid
  offer_item_issue_id: uuid
  order: Int
  owner_id: uuid
  path: String
  product_id: uuid
  shipmentId: uuid
  type: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type files_stddev_fields {
  deleted_at: Float
  order: Float
}

"""
order by stddev() on columns of table "files"
"""
input files_stddev_order_by {
  deleted_at: order_by
  order: order_by
}

"""aggregate stddev_pop on columns"""
type files_stddev_pop_fields {
  deleted_at: Float
  order: Float
}

"""
order by stddev_pop() on columns of table "files"
"""
input files_stddev_pop_order_by {
  deleted_at: order_by
  order: order_by
}

"""aggregate stddev_samp on columns"""
type files_stddev_samp_fields {
  deleted_at: Float
  order: Float
}

"""
order by stddev_samp() on columns of table "files"
"""
input files_stddev_samp_order_by {
  deleted_at: order_by
  order: order_by
}

"""
Streaming cursor of the table "files"
"""
input files_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: files_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input files_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: Int
  filename: String
  id: uuid
  inventory_item_id: uuid
  offer_item_issue_id: uuid
  order: Int
  owner_id: uuid
  path: String
  product_id: uuid
  shipmentId: uuid
  type: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type files_sum_fields {
  deleted_at: Int
  order: Int
}

"""
order by sum() on columns of table "files"
"""
input files_sum_order_by {
  deleted_at: order_by
  order: order_by
}

"""
update columns of table "files"
"""
enum files_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  filename

  """column name"""
  id

  """column name"""
  inventory_item_id

  """column name"""
  offer_item_issue_id

  """column name"""
  order

  """column name"""
  owner_id

  """column name"""
  path

  """column name"""
  product_id

  """column name"""
  shipmentId

  """column name"""
  type

  """column name"""
  updated_at
}

input files_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: files_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: files_set_input

  """filter the rows which have to be updated"""
  where: files_bool_exp!
}

"""aggregate var_pop on columns"""
type files_var_pop_fields {
  deleted_at: Float
  order: Float
}

"""
order by var_pop() on columns of table "files"
"""
input files_var_pop_order_by {
  deleted_at: order_by
  order: order_by
}

"""aggregate var_samp on columns"""
type files_var_samp_fields {
  deleted_at: Float
  order: Float
}

"""
order by var_samp() on columns of table "files"
"""
input files_var_samp_order_by {
  deleted_at: order_by
  order: order_by
}

"""aggregate variance on columns"""
type files_variance_fields {
  deleted_at: Float
  order: Float
}

"""
order by variance() on columns of table "files"
"""
input files_variance_order_by {
  deleted_at: order_by
  order: order_by
}

"""Holds followers and their following."""
type follows {
  """An object relationship"""
  followerUser: users!
  follower_id: uuid!

  """An object relationship"""
  followingUser: users!
  following_id: uuid!
}

"""
aggregated selection of "follows"
"""
type follows_aggregate {
  aggregate: follows_aggregate_fields
  nodes: [follows!]!
}

input follows_aggregate_bool_exp {
  count: follows_aggregate_bool_exp_count
}

input follows_aggregate_bool_exp_count {
  arguments: [follows_select_column!]
  distinct: Boolean
  filter: follows_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "follows"
"""
type follows_aggregate_fields {
  count(columns: [follows_select_column!], distinct: Boolean): Int!
  max: follows_max_fields
  min: follows_min_fields
}

"""
order by aggregate values of table "follows"
"""
input follows_aggregate_order_by {
  count: order_by
  max: follows_max_order_by
  min: follows_min_order_by
}

"""
input type for inserting array relation for remote table "follows"
"""
input follows_arr_rel_insert_input {
  data: [follows_insert_input!]!

  """upsert condition"""
  on_conflict: follows_on_conflict
}

"""
Boolean expression to filter rows from the table "follows". All fields are combined with a logical 'AND'.
"""
input follows_bool_exp {
  _and: [follows_bool_exp!]
  _not: follows_bool_exp
  _or: [follows_bool_exp!]
  followerUser: users_bool_exp
  follower_id: uuid_comparison_exp
  followingUser: users_bool_exp
  following_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "follows"
"""
enum follows_constraint {
  """
  unique or primary key constraint on columns "follower_id", "following_id"
  """
  follows_pkey
}

"""
input type for inserting data into table "follows"
"""
input follows_insert_input {
  followerUser: users_obj_rel_insert_input
  follower_id: uuid
  followingUser: users_obj_rel_insert_input
  following_id: uuid
}

"""aggregate max on columns"""
type follows_max_fields {
  follower_id: uuid
  following_id: uuid
}

"""
order by max() on columns of table "follows"
"""
input follows_max_order_by {
  follower_id: order_by
  following_id: order_by
}

"""aggregate min on columns"""
type follows_min_fields {
  follower_id: uuid
  following_id: uuid
}

"""
order by min() on columns of table "follows"
"""
input follows_min_order_by {
  follower_id: order_by
  following_id: order_by
}

"""
response of any mutation on the table "follows"
"""
type follows_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [follows!]!
}

"""
on_conflict condition type for table "follows"
"""
input follows_on_conflict {
  constraint: follows_constraint!
  update_columns: [follows_update_column!]! = []
  where: follows_bool_exp
}

"""Ordering options when selecting data from "follows"."""
input follows_order_by {
  followerUser: users_order_by
  follower_id: order_by
  followingUser: users_order_by
  following_id: order_by
}

"""primary key columns input for table: follows"""
input follows_pk_columns_input {
  follower_id: uuid!
  following_id: uuid!
}

"""
select columns of table "follows"
"""
enum follows_select_column {
  """column name"""
  follower_id

  """column name"""
  following_id
}

"""
input type for updating data in table "follows"
"""
input follows_set_input {
  follower_id: uuid
  following_id: uuid
}

"""
Streaming cursor of the table "follows"
"""
input follows_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: follows_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input follows_stream_cursor_value_input {
  follower_id: uuid
  following_id: uuid
}

"""
update columns of table "follows"
"""
enum follows_update_column {
  """column name"""
  follower_id

  """column name"""
  following_id
}

input follows_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: follows_set_input

  """filter the rows which have to be updated"""
  where: follows_bool_exp!
}

"""
columns and relationships of "free_shipping_configuration"
"""
type free_shipping_configuration {
  created_at: timestamptz!
  deleted_at: Int!
  end_date: timestamptz!
  id: uuid!
  is_for_offer_ideas: Boolean!
  start_date: timestamptz!
  updated_at: timestamptz!
}

"""
aggregated selection of "free_shipping_configuration"
"""
type free_shipping_configuration_aggregate {
  aggregate: free_shipping_configuration_aggregate_fields
  nodes: [free_shipping_configuration!]!
}

"""
aggregate fields of "free_shipping_configuration"
"""
type free_shipping_configuration_aggregate_fields {
  avg: free_shipping_configuration_avg_fields
  count(columns: [free_shipping_configuration_select_column!], distinct: Boolean): Int!
  max: free_shipping_configuration_max_fields
  min: free_shipping_configuration_min_fields
  stddev: free_shipping_configuration_stddev_fields
  stddev_pop: free_shipping_configuration_stddev_pop_fields
  stddev_samp: free_shipping_configuration_stddev_samp_fields
  sum: free_shipping_configuration_sum_fields
  var_pop: free_shipping_configuration_var_pop_fields
  var_samp: free_shipping_configuration_var_samp_fields
  variance: free_shipping_configuration_variance_fields
}

"""aggregate avg on columns"""
type free_shipping_configuration_avg_fields {
  deleted_at: Float
}

"""
Boolean expression to filter rows from the table "free_shipping_configuration". All fields are combined with a logical 'AND'.
"""
input free_shipping_configuration_bool_exp {
  _and: [free_shipping_configuration_bool_exp!]
  _not: free_shipping_configuration_bool_exp
  _or: [free_shipping_configuration_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  end_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_for_offer_ideas: Boolean_comparison_exp
  start_date: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "free_shipping_configuration"
"""
enum free_shipping_configuration_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  free_shipping_configuration_pkey
}

"""
input type for incrementing numeric columns in table "free_shipping_configuration"
"""
input free_shipping_configuration_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "free_shipping_configuration"
"""
input free_shipping_configuration_insert_input {
  created_at: timestamptz
  deleted_at: Int
  end_date: timestamptz
  id: uuid
  is_for_offer_ideas: Boolean
  start_date: timestamptz
  updated_at: timestamptz
}

"""aggregate max on columns"""
type free_shipping_configuration_max_fields {
  created_at: timestamptz
  deleted_at: Int
  end_date: timestamptz
  id: uuid
  start_date: timestamptz
  updated_at: timestamptz
}

"""aggregate min on columns"""
type free_shipping_configuration_min_fields {
  created_at: timestamptz
  deleted_at: Int
  end_date: timestamptz
  id: uuid
  start_date: timestamptz
  updated_at: timestamptz
}

"""
response of any mutation on the table "free_shipping_configuration"
"""
type free_shipping_configuration_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [free_shipping_configuration!]!
}

"""
on_conflict condition type for table "free_shipping_configuration"
"""
input free_shipping_configuration_on_conflict {
  constraint: free_shipping_configuration_constraint!
  update_columns: [free_shipping_configuration_update_column!]! = []
  where: free_shipping_configuration_bool_exp
}

"""
Ordering options when selecting data from "free_shipping_configuration".
"""
input free_shipping_configuration_order_by {
  created_at: order_by
  deleted_at: order_by
  end_date: order_by
  id: order_by
  is_for_offer_ideas: order_by
  start_date: order_by
  updated_at: order_by
}

"""primary key columns input for table: free_shipping_configuration"""
input free_shipping_configuration_pk_columns_input {
  id: uuid!
}

"""
select columns of table "free_shipping_configuration"
"""
enum free_shipping_configuration_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  is_for_offer_ideas

  """column name"""
  start_date

  """column name"""
  updated_at
}

"""
input type for updating data in table "free_shipping_configuration"
"""
input free_shipping_configuration_set_input {
  created_at: timestamptz
  deleted_at: Int
  end_date: timestamptz
  id: uuid
  is_for_offer_ideas: Boolean
  start_date: timestamptz
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type free_shipping_configuration_stddev_fields {
  deleted_at: Float
}

"""aggregate stddev_pop on columns"""
type free_shipping_configuration_stddev_pop_fields {
  deleted_at: Float
}

"""aggregate stddev_samp on columns"""
type free_shipping_configuration_stddev_samp_fields {
  deleted_at: Float
}

"""
Streaming cursor of the table "free_shipping_configuration"
"""
input free_shipping_configuration_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: free_shipping_configuration_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input free_shipping_configuration_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: Int
  end_date: timestamptz
  id: uuid
  is_for_offer_ideas: Boolean
  start_date: timestamptz
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type free_shipping_configuration_sum_fields {
  deleted_at: Int
}

"""
update columns of table "free_shipping_configuration"
"""
enum free_shipping_configuration_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  is_for_offer_ideas

  """column name"""
  start_date

  """column name"""
  updated_at
}

input free_shipping_configuration_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: free_shipping_configuration_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: free_shipping_configuration_set_input

  """filter the rows which have to be updated"""
  where: free_shipping_configuration_bool_exp!
}

"""aggregate var_pop on columns"""
type free_shipping_configuration_var_pop_fields {
  deleted_at: Float
}

"""aggregate var_samp on columns"""
type free_shipping_configuration_var_samp_fields {
  deleted_at: Float
}

"""aggregate variance on columns"""
type free_shipping_configuration_variance_fields {
  deleted_at: Float
}

"""Product inventory a user has added to their closet"""
type inventory_items {
  """An array relationship"""
  attribute_selections(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): [attribute_selections!]!

  """An aggregate relationship"""
  attribute_selections_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): attribute_selections_aggregate!
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!
  index_cache(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  inventory_status: inventory_status!
  note: String

  """An array relationship"""
  offer_items(
    """distinct select on columns"""
    distinct_on: [offer_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_order_by!]

    """filter the rows returned"""
    where: offer_items_bool_exp
  ): [offer_items!]!

  """An aggregate relationship"""
  offer_items_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_order_by!]

    """filter the rows returned"""
    where: offer_items_bool_exp
  ): offer_items_aggregate!

  """An array relationship"""
  pictures(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  pictures_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!
  previous_inventory_item_id: uuid

  """An object relationship"""
  product_variant: product_variants!
  product_variant_id: uuid!
  status: inventory_status_enum!
  trade_willingness: Int
  update_index: Boolean!
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
  was_previously_authenticated: Boolean!
}

"""
aggregated selection of "inventory_items"
"""
type inventory_items_aggregate {
  aggregate: inventory_items_aggregate_fields
  nodes: [inventory_items!]!
}

input inventory_items_aggregate_bool_exp {
  bool_and: inventory_items_aggregate_bool_exp_bool_and
  bool_or: inventory_items_aggregate_bool_exp_bool_or
  count: inventory_items_aggregate_bool_exp_count
}

input inventory_items_aggregate_bool_exp_bool_and {
  arguments: inventory_items_select_column_inventory_items_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: inventory_items_bool_exp
  predicate: Boolean_comparison_exp!
}

input inventory_items_aggregate_bool_exp_bool_or {
  arguments: inventory_items_select_column_inventory_items_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: inventory_items_bool_exp
  predicate: Boolean_comparison_exp!
}

input inventory_items_aggregate_bool_exp_count {
  arguments: [inventory_items_select_column!]
  distinct: Boolean
  filter: inventory_items_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "inventory_items"
"""
type inventory_items_aggregate_fields {
  avg: inventory_items_avg_fields
  count(columns: [inventory_items_select_column!], distinct: Boolean): Int!
  max: inventory_items_max_fields
  min: inventory_items_min_fields
  stddev: inventory_items_stddev_fields
  stddev_pop: inventory_items_stddev_pop_fields
  stddev_samp: inventory_items_stddev_samp_fields
  sum: inventory_items_sum_fields
  var_pop: inventory_items_var_pop_fields
  var_samp: inventory_items_var_samp_fields
  variance: inventory_items_variance_fields
}

"""
order by aggregate values of table "inventory_items"
"""
input inventory_items_aggregate_order_by {
  avg: inventory_items_avg_order_by
  count: order_by
  max: inventory_items_max_order_by
  min: inventory_items_min_order_by
  stddev: inventory_items_stddev_order_by
  stddev_pop: inventory_items_stddev_pop_order_by
  stddev_samp: inventory_items_stddev_samp_order_by
  sum: inventory_items_sum_order_by
  var_pop: inventory_items_var_pop_order_by
  var_samp: inventory_items_var_samp_order_by
  variance: inventory_items_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input inventory_items_append_input {
  index_cache: jsonb
}

"""
input type for inserting array relation for remote table "inventory_items"
"""
input inventory_items_arr_rel_insert_input {
  data: [inventory_items_insert_input!]!

  """upsert condition"""
  on_conflict: inventory_items_on_conflict
}

"""aggregate avg on columns"""
type inventory_items_avg_fields {
  deleted_at: Float
  trade_willingness: Float
}

"""
order by avg() on columns of table "inventory_items"
"""
input inventory_items_avg_order_by {
  deleted_at: order_by
  trade_willingness: order_by
}

"""
Boolean expression to filter rows from the table "inventory_items". All fields are combined with a logical 'AND'.
"""
input inventory_items_bool_exp {
  _and: [inventory_items_bool_exp!]
  _not: inventory_items_bool_exp
  _or: [inventory_items_bool_exp!]
  attribute_selections: attribute_selections_bool_exp
  attribute_selections_aggregate: attribute_selections_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  index_cache: jsonb_comparison_exp
  inventory_status: inventory_status_bool_exp
  note: String_comparison_exp
  offer_items: offer_items_bool_exp
  offer_items_aggregate: offer_items_aggregate_bool_exp
  pictures: files_bool_exp
  pictures_aggregate: files_aggregate_bool_exp
  previous_inventory_item_id: uuid_comparison_exp
  product_variant: product_variants_bool_exp
  product_variant_id: uuid_comparison_exp
  status: inventory_status_enum_comparison_exp
  trade_willingness: Int_comparison_exp
  update_index: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
  was_previously_authenticated: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "inventory_items"
"""
enum inventory_items_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  inventory_items_pkey

  """
  unique or primary key constraint on columns "previous_inventory_item_id"
  """
  inventory_items_previous_inventory_item_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input inventory_items_delete_at_path_input {
  index_cache: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input inventory_items_delete_elem_input {
  index_cache: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input inventory_items_delete_key_input {
  index_cache: String
}

"""
input type for incrementing numeric columns in table "inventory_items"
"""
input inventory_items_inc_input {
  deleted_at: Int
  trade_willingness: Int
}

"""
input type for inserting data into table "inventory_items"
"""
input inventory_items_insert_input {
  attribute_selections: attribute_selections_arr_rel_insert_input
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  index_cache: jsonb
  inventory_status: inventory_status_obj_rel_insert_input
  note: String
  offer_items: offer_items_arr_rel_insert_input
  pictures: files_arr_rel_insert_input
  previous_inventory_item_id: uuid
  product_variant: product_variants_obj_rel_insert_input
  product_variant_id: uuid
  status: inventory_status_enum
  trade_willingness: Int
  update_index: Boolean
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
  was_previously_authenticated: Boolean
}

"""aggregate max on columns"""
type inventory_items_max_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  note: String
  previous_inventory_item_id: uuid
  product_variant_id: uuid
  trade_willingness: Int
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "inventory_items"
"""
input inventory_items_max_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  note: order_by
  previous_inventory_item_id: order_by
  product_variant_id: order_by
  trade_willingness: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type inventory_items_min_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  note: String
  previous_inventory_item_id: uuid
  product_variant_id: uuid
  trade_willingness: Int
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "inventory_items"
"""
input inventory_items_min_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  note: order_by
  previous_inventory_item_id: order_by
  product_variant_id: order_by
  trade_willingness: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "inventory_items"
"""
type inventory_items_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [inventory_items!]!
}

"""
input type for inserting object relation for remote table "inventory_items"
"""
input inventory_items_obj_rel_insert_input {
  data: inventory_items_insert_input!

  """upsert condition"""
  on_conflict: inventory_items_on_conflict
}

"""
on_conflict condition type for table "inventory_items"
"""
input inventory_items_on_conflict {
  constraint: inventory_items_constraint!
  update_columns: [inventory_items_update_column!]! = []
  where: inventory_items_bool_exp
}

"""Ordering options when selecting data from "inventory_items"."""
input inventory_items_order_by {
  attribute_selections_aggregate: attribute_selections_aggregate_order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  index_cache: order_by
  inventory_status: inventory_status_order_by
  note: order_by
  offer_items_aggregate: offer_items_aggregate_order_by
  pictures_aggregate: files_aggregate_order_by
  previous_inventory_item_id: order_by
  product_variant: product_variants_order_by
  product_variant_id: order_by
  status: order_by
  trade_willingness: order_by
  update_index: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
  was_previously_authenticated: order_by
}

"""primary key columns input for table: inventory_items"""
input inventory_items_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input inventory_items_prepend_input {
  index_cache: jsonb
}

"""
select columns of table "inventory_items"
"""
enum inventory_items_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  index_cache

  """column name"""
  note

  """column name"""
  previous_inventory_item_id

  """column name"""
  product_variant_id

  """column name"""
  status

  """column name"""
  trade_willingness

  """column name"""
  update_index

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  was_previously_authenticated
}

"""
select "inventory_items_aggregate_bool_exp_bool_and_arguments_columns" columns of table "inventory_items"
"""
enum inventory_items_select_column_inventory_items_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  update_index

  """column name"""
  was_previously_authenticated
}

"""
select "inventory_items_aggregate_bool_exp_bool_or_arguments_columns" columns of table "inventory_items"
"""
enum inventory_items_select_column_inventory_items_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  update_index

  """column name"""
  was_previously_authenticated
}

"""
input type for updating data in table "inventory_items"
"""
input inventory_items_set_input {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  index_cache: jsonb
  note: String
  previous_inventory_item_id: uuid
  product_variant_id: uuid
  status: inventory_status_enum
  trade_willingness: Int
  update_index: Boolean
  updated_at: timestamptz
  user_id: uuid
  was_previously_authenticated: Boolean
}

"""aggregate stddev on columns"""
type inventory_items_stddev_fields {
  deleted_at: Float
  trade_willingness: Float
}

"""
order by stddev() on columns of table "inventory_items"
"""
input inventory_items_stddev_order_by {
  deleted_at: order_by
  trade_willingness: order_by
}

"""aggregate stddev_pop on columns"""
type inventory_items_stddev_pop_fields {
  deleted_at: Float
  trade_willingness: Float
}

"""
order by stddev_pop() on columns of table "inventory_items"
"""
input inventory_items_stddev_pop_order_by {
  deleted_at: order_by
  trade_willingness: order_by
}

"""aggregate stddev_samp on columns"""
type inventory_items_stddev_samp_fields {
  deleted_at: Float
  trade_willingness: Float
}

"""
order by stddev_samp() on columns of table "inventory_items"
"""
input inventory_items_stddev_samp_order_by {
  deleted_at: order_by
  trade_willingness: order_by
}

"""
Streaming cursor of the table "inventory_items"
"""
input inventory_items_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: inventory_items_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input inventory_items_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  index_cache: jsonb
  note: String
  previous_inventory_item_id: uuid
  product_variant_id: uuid
  status: inventory_status_enum
  trade_willingness: Int
  update_index: Boolean
  updated_at: timestamptz
  user_id: uuid
  was_previously_authenticated: Boolean
}

"""aggregate sum on columns"""
type inventory_items_sum_fields {
  deleted_at: Int
  trade_willingness: Int
}

"""
order by sum() on columns of table "inventory_items"
"""
input inventory_items_sum_order_by {
  deleted_at: order_by
  trade_willingness: order_by
}

"""
update columns of table "inventory_items"
"""
enum inventory_items_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  index_cache

  """column name"""
  note

  """column name"""
  previous_inventory_item_id

  """column name"""
  product_variant_id

  """column name"""
  status

  """column name"""
  trade_willingness

  """column name"""
  update_index

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  was_previously_authenticated
}

input inventory_items_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: inventory_items_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: inventory_items_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: inventory_items_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: inventory_items_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: inventory_items_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: inventory_items_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: inventory_items_set_input

  """filter the rows which have to be updated"""
  where: inventory_items_bool_exp!
}

"""aggregate var_pop on columns"""
type inventory_items_var_pop_fields {
  deleted_at: Float
  trade_willingness: Float
}

"""
order by var_pop() on columns of table "inventory_items"
"""
input inventory_items_var_pop_order_by {
  deleted_at: order_by
  trade_willingness: order_by
}

"""aggregate var_samp on columns"""
type inventory_items_var_samp_fields {
  deleted_at: Float
  trade_willingness: Float
}

"""
order by var_samp() on columns of table "inventory_items"
"""
input inventory_items_var_samp_order_by {
  deleted_at: order_by
  trade_willingness: order_by
}

"""aggregate variance on columns"""
type inventory_items_variance_fields {
  deleted_at: Float
  trade_willingness: Float
}

"""
order by variance() on columns of table "inventory_items"
"""
input inventory_items_variance_order_by {
  deleted_at: order_by
  trade_willingness: order_by
}

"""
columns and relationships of "inventory_status"
"""
type inventory_status {
  comment: String!

  """An array relationship"""
  inventory_items(
    """distinct select on columns"""
    distinct_on: [inventory_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_items_order_by!]

    """filter the rows returned"""
    where: inventory_items_bool_exp
  ): [inventory_items!]!

  """An aggregate relationship"""
  inventory_items_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_items_order_by!]

    """filter the rows returned"""
    where: inventory_items_bool_exp
  ): inventory_items_aggregate!
  value: String!
}

"""
aggregated selection of "inventory_status"
"""
type inventory_status_aggregate {
  aggregate: inventory_status_aggregate_fields
  nodes: [inventory_status!]!
}

"""
aggregate fields of "inventory_status"
"""
type inventory_status_aggregate_fields {
  count(columns: [inventory_status_select_column!], distinct: Boolean): Int!
  max: inventory_status_max_fields
  min: inventory_status_min_fields
}

"""
Boolean expression to filter rows from the table "inventory_status". All fields are combined with a logical 'AND'.
"""
input inventory_status_bool_exp {
  _and: [inventory_status_bool_exp!]
  _not: inventory_status_bool_exp
  _or: [inventory_status_bool_exp!]
  comment: String_comparison_exp
  inventory_items: inventory_items_bool_exp
  inventory_items_aggregate: inventory_items_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "inventory_status"
"""
enum inventory_status_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  inventory_status_pkey
}

enum inventory_status_enum {
  """
  The default status for an inventory item until it has been approved for trading.
  """
  DRAFT

  """
  An inventory item with this status was traded away and replaced by the associated next inventory item.
  """
  HAS_NEW_OWNER

  """An inventory item with this status is currently involved in a trade."""
  LOCKED_IN_TRADE

  """
  An inventory item with this status is eligible to be included in new offers.
  """
  OPEN_FOR_TRADE

  """An inventory item with this status was removed by the user."""
  REMOVED
}

"""
Boolean expression to compare columns of type "inventory_status_enum". All fields are combined with logical 'AND'.
"""
input inventory_status_enum_comparison_exp {
  _eq: inventory_status_enum
  _in: [inventory_status_enum!]
  _is_null: Boolean
  _neq: inventory_status_enum
  _nin: [inventory_status_enum!]
}

"""
input type for inserting data into table "inventory_status"
"""
input inventory_status_insert_input {
  comment: String
  inventory_items: inventory_items_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type inventory_status_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type inventory_status_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "inventory_status"
"""
type inventory_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [inventory_status!]!
}

"""
input type for inserting object relation for remote table "inventory_status"
"""
input inventory_status_obj_rel_insert_input {
  data: inventory_status_insert_input!

  """upsert condition"""
  on_conflict: inventory_status_on_conflict
}

"""
on_conflict condition type for table "inventory_status"
"""
input inventory_status_on_conflict {
  constraint: inventory_status_constraint!
  update_columns: [inventory_status_update_column!]! = []
  where: inventory_status_bool_exp
}

"""Ordering options when selecting data from "inventory_status"."""
input inventory_status_order_by {
  comment: order_by
  inventory_items_aggregate: inventory_items_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: inventory_status"""
input inventory_status_pk_columns_input {
  value: String!
}

"""
select columns of table "inventory_status"
"""
enum inventory_status_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "inventory_status"
"""
input inventory_status_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "inventory_status"
"""
input inventory_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: inventory_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input inventory_status_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "inventory_status"
"""
enum inventory_status_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input inventory_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: inventory_status_set_input

  """filter the rows which have to be updated"""
  where: inventory_status_bool_exp!
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""Languages supported by the app."""
type languages {
  code: String!
}

"""
aggregated selection of "languages"
"""
type languages_aggregate {
  aggregate: languages_aggregate_fields
  nodes: [languages!]!
}

"""
aggregate fields of "languages"
"""
type languages_aggregate_fields {
  count(columns: [languages_select_column!], distinct: Boolean): Int!
  max: languages_max_fields
  min: languages_min_fields
}

"""
Boolean expression to filter rows from the table "languages". All fields are combined with a logical 'AND'.
"""
input languages_bool_exp {
  _and: [languages_bool_exp!]
  _not: languages_bool_exp
  _or: [languages_bool_exp!]
  code: String_comparison_exp
}

"""
unique or primary key constraints on table "languages"
"""
enum languages_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  languages_pkey
}

"""
input type for inserting data into table "languages"
"""
input languages_insert_input {
  code: String
}

"""aggregate max on columns"""
type languages_max_fields {
  code: String
}

"""aggregate min on columns"""
type languages_min_fields {
  code: String
}

"""
response of any mutation on the table "languages"
"""
type languages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [languages!]!
}

"""
input type for inserting object relation for remote table "languages"
"""
input languages_obj_rel_insert_input {
  data: languages_insert_input!

  """upsert condition"""
  on_conflict: languages_on_conflict
}

"""
on_conflict condition type for table "languages"
"""
input languages_on_conflict {
  constraint: languages_constraint!
  update_columns: [languages_update_column!]! = []
  where: languages_bool_exp
}

"""Ordering options when selecting data from "languages"."""
input languages_order_by {
  code: order_by
}

"""primary key columns input for table: languages"""
input languages_pk_columns_input {
  code: String!
}

"""
select columns of table "languages"
"""
enum languages_select_column {
  """column name"""
  code
}

"""
input type for updating data in table "languages"
"""
input languages_set_input {
  code: String
}

"""
Streaming cursor of the table "languages"
"""
input languages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: languages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input languages_stream_cursor_value_input {
  code: String
}

"""
update columns of table "languages"
"""
enum languages_update_column {
  """column name"""
  code
}

input languages_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: languages_set_input

  """filter the rows which have to be updated"""
  where: languages_bool_exp!
}

"""
columns and relationships of "march_mania_bracket"
"""
type march_mania_bracket {
  bracket_index: Int!
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!
  key: String!
  product_id: uuid
  round_index: Int!
  round_key: String!
  selected_shoe_index: Int!
  updated_at: timestamptz!
  user_id: uuid
}

"""
aggregated selection of "march_mania_bracket"
"""
type march_mania_bracket_aggregate {
  aggregate: march_mania_bracket_aggregate_fields
  nodes: [march_mania_bracket!]!
}

input march_mania_bracket_aggregate_bool_exp {
  count: march_mania_bracket_aggregate_bool_exp_count
}

input march_mania_bracket_aggregate_bool_exp_count {
  arguments: [march_mania_bracket_select_column!]
  distinct: Boolean
  filter: march_mania_bracket_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "march_mania_bracket"
"""
type march_mania_bracket_aggregate_fields {
  avg: march_mania_bracket_avg_fields
  count(columns: [march_mania_bracket_select_column!], distinct: Boolean): Int!
  max: march_mania_bracket_max_fields
  min: march_mania_bracket_min_fields
  stddev: march_mania_bracket_stddev_fields
  stddev_pop: march_mania_bracket_stddev_pop_fields
  stddev_samp: march_mania_bracket_stddev_samp_fields
  sum: march_mania_bracket_sum_fields
  var_pop: march_mania_bracket_var_pop_fields
  var_samp: march_mania_bracket_var_samp_fields
  variance: march_mania_bracket_variance_fields
}

"""
order by aggregate values of table "march_mania_bracket"
"""
input march_mania_bracket_aggregate_order_by {
  avg: march_mania_bracket_avg_order_by
  count: order_by
  max: march_mania_bracket_max_order_by
  min: march_mania_bracket_min_order_by
  stddev: march_mania_bracket_stddev_order_by
  stddev_pop: march_mania_bracket_stddev_pop_order_by
  stddev_samp: march_mania_bracket_stddev_samp_order_by
  sum: march_mania_bracket_sum_order_by
  var_pop: march_mania_bracket_var_pop_order_by
  var_samp: march_mania_bracket_var_samp_order_by
  variance: march_mania_bracket_variance_order_by
}

"""
input type for inserting array relation for remote table "march_mania_bracket"
"""
input march_mania_bracket_arr_rel_insert_input {
  data: [march_mania_bracket_insert_input!]!

  """upsert condition"""
  on_conflict: march_mania_bracket_on_conflict
}

"""aggregate avg on columns"""
type march_mania_bracket_avg_fields {
  bracket_index: Float
  deleted_at: Float
  round_index: Float
  selected_shoe_index: Float
}

"""
order by avg() on columns of table "march_mania_bracket"
"""
input march_mania_bracket_avg_order_by {
  bracket_index: order_by
  deleted_at: order_by
  round_index: order_by
  selected_shoe_index: order_by
}

"""
Boolean expression to filter rows from the table "march_mania_bracket". All fields are combined with a logical 'AND'.
"""
input march_mania_bracket_bool_exp {
  _and: [march_mania_bracket_bool_exp!]
  _not: march_mania_bracket_bool_exp
  _or: [march_mania_bracket_bool_exp!]
  bracket_index: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  key: String_comparison_exp
  product_id: uuid_comparison_exp
  round_index: Int_comparison_exp
  round_key: String_comparison_exp
  selected_shoe_index: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "march_mania_bracket"
"""
enum march_mania_bracket_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  march_mania_bracket_pkey
}

"""
input type for incrementing numeric columns in table "march_mania_bracket"
"""
input march_mania_bracket_inc_input {
  bracket_index: Int
  deleted_at: Int
  round_index: Int
  selected_shoe_index: Int
}

"""
input type for inserting data into table "march_mania_bracket"
"""
input march_mania_bracket_insert_input {
  bracket_index: Int
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  key: String
  product_id: uuid
  round_index: Int
  round_key: String
  selected_shoe_index: Int
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type march_mania_bracket_max_fields {
  bracket_index: Int
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  key: String
  product_id: uuid
  round_index: Int
  round_key: String
  selected_shoe_index: Int
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "march_mania_bracket"
"""
input march_mania_bracket_max_order_by {
  bracket_index: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  key: order_by
  product_id: order_by
  round_index: order_by
  round_key: order_by
  selected_shoe_index: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type march_mania_bracket_min_fields {
  bracket_index: Int
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  key: String
  product_id: uuid
  round_index: Int
  round_key: String
  selected_shoe_index: Int
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "march_mania_bracket"
"""
input march_mania_bracket_min_order_by {
  bracket_index: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  key: order_by
  product_id: order_by
  round_index: order_by
  round_key: order_by
  selected_shoe_index: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "march_mania_bracket"
"""
type march_mania_bracket_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [march_mania_bracket!]!
}

"""
on_conflict condition type for table "march_mania_bracket"
"""
input march_mania_bracket_on_conflict {
  constraint: march_mania_bracket_constraint!
  update_columns: [march_mania_bracket_update_column!]! = []
  where: march_mania_bracket_bool_exp
}

"""Ordering options when selecting data from "march_mania_bracket"."""
input march_mania_bracket_order_by {
  bracket_index: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  key: order_by
  product_id: order_by
  round_index: order_by
  round_key: order_by
  selected_shoe_index: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: march_mania_bracket"""
input march_mania_bracket_pk_columns_input {
  id: uuid!
}

"""
select columns of table "march_mania_bracket"
"""
enum march_mania_bracket_select_column {
  """column name"""
  bracket_index

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  key

  """column name"""
  product_id

  """column name"""
  round_index

  """column name"""
  round_key

  """column name"""
  selected_shoe_index

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "march_mania_bracket"
"""
input march_mania_bracket_set_input {
  bracket_index: Int
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  key: String
  product_id: uuid
  round_index: Int
  round_key: String
  selected_shoe_index: Int
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type march_mania_bracket_stddev_fields {
  bracket_index: Float
  deleted_at: Float
  round_index: Float
  selected_shoe_index: Float
}

"""
order by stddev() on columns of table "march_mania_bracket"
"""
input march_mania_bracket_stddev_order_by {
  bracket_index: order_by
  deleted_at: order_by
  round_index: order_by
  selected_shoe_index: order_by
}

"""aggregate stddev_pop on columns"""
type march_mania_bracket_stddev_pop_fields {
  bracket_index: Float
  deleted_at: Float
  round_index: Float
  selected_shoe_index: Float
}

"""
order by stddev_pop() on columns of table "march_mania_bracket"
"""
input march_mania_bracket_stddev_pop_order_by {
  bracket_index: order_by
  deleted_at: order_by
  round_index: order_by
  selected_shoe_index: order_by
}

"""aggregate stddev_samp on columns"""
type march_mania_bracket_stddev_samp_fields {
  bracket_index: Float
  deleted_at: Float
  round_index: Float
  selected_shoe_index: Float
}

"""
order by stddev_samp() on columns of table "march_mania_bracket"
"""
input march_mania_bracket_stddev_samp_order_by {
  bracket_index: order_by
  deleted_at: order_by
  round_index: order_by
  selected_shoe_index: order_by
}

"""
Streaming cursor of the table "march_mania_bracket"
"""
input march_mania_bracket_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: march_mania_bracket_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input march_mania_bracket_stream_cursor_value_input {
  bracket_index: Int
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  key: String
  product_id: uuid
  round_index: Int
  round_key: String
  selected_shoe_index: Int
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate sum on columns"""
type march_mania_bracket_sum_fields {
  bracket_index: Int
  deleted_at: Int
  round_index: Int
  selected_shoe_index: Int
}

"""
order by sum() on columns of table "march_mania_bracket"
"""
input march_mania_bracket_sum_order_by {
  bracket_index: order_by
  deleted_at: order_by
  round_index: order_by
  selected_shoe_index: order_by
}

"""
update columns of table "march_mania_bracket"
"""
enum march_mania_bracket_update_column {
  """column name"""
  bracket_index

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  key

  """column name"""
  product_id

  """column name"""
  round_index

  """column name"""
  round_key

  """column name"""
  selected_shoe_index

  """column name"""
  updated_at

  """column name"""
  user_id
}

input march_mania_bracket_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: march_mania_bracket_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: march_mania_bracket_set_input

  """filter the rows which have to be updated"""
  where: march_mania_bracket_bool_exp!
}

"""aggregate var_pop on columns"""
type march_mania_bracket_var_pop_fields {
  bracket_index: Float
  deleted_at: Float
  round_index: Float
  selected_shoe_index: Float
}

"""
order by var_pop() on columns of table "march_mania_bracket"
"""
input march_mania_bracket_var_pop_order_by {
  bracket_index: order_by
  deleted_at: order_by
  round_index: order_by
  selected_shoe_index: order_by
}

"""aggregate var_samp on columns"""
type march_mania_bracket_var_samp_fields {
  bracket_index: Float
  deleted_at: Float
  round_index: Float
  selected_shoe_index: Float
}

"""
order by var_samp() on columns of table "march_mania_bracket"
"""
input march_mania_bracket_var_samp_order_by {
  bracket_index: order_by
  deleted_at: order_by
  round_index: order_by
  selected_shoe_index: order_by
}

"""aggregate variance on columns"""
type march_mania_bracket_variance_fields {
  bracket_index: Float
  deleted_at: Float
  round_index: Float
  selected_shoe_index: Float
}

"""
order by variance() on columns of table "march_mania_bracket"
"""
input march_mania_bracket_variance_order_by {
  bracket_index: order_by
  deleted_at: order_by
  round_index: order_by
  selected_shoe_index: order_by
}

"""mutation root"""
type mutation_root {
  acceptBuyOffer(offerId: String!, receiverCheckoutDetails: CheckoutDetails!, tradeOrigin: TradeOriginType): Offer
  acceptOffer(creatorItems: [AcceptOfferInventoryItem!], creatorUserId: String, isPartnerTrustedTrader: Boolean, offerId: String!, receiverCheckoutDetails: CheckoutDetails!, receiverItems: [AcceptOfferInventoryItem!], tradeOrigin: TradeOriginType): Offer
  acceptPublicOffer(creatorItems: [AcceptOfferInventoryItem!], creatorUserId: String, isPartnerTrustedTrader: Boolean, offerId: String!, receiverCheckoutDetails: CheckoutDetails!, receiverItems: [OfferInventoryItem!], tradeOrigin: TradeOriginType): Offer
  acceptSellOffer(offerId: String!, receiverCheckoutDetails: CheckoutDetails!, tradeOrigin: TradeOriginType): Offer
  addBankAccount(bankAccountNumber: String!, bankRoutingNumber: String!, default: Boolean): AddBankAccountResult
  addPhoneAccount(verifyOtpInput: VerifyOtpInput!): Success
  addPriceReport(dataPoint: String!, price: Float!, source: String!, variantId: String!): Success
  addSocialAccount(newLoginAuthToken: String!): Success
  adminVerifyPaymentMethod(paymentMethodId: String!): Success
  blockUser(blockedGetStreamUserId: String!, blockedUserId: String!): Success
  boxUpShipment(shipmentId: String!): Success
  cancelTrade(atFault: Boolean!, collectorId: String!, offerId: String!): Success
  changeEmail(currentEmail: String!, newEmail: String!, password: String!): Success
  changePassword(newPassword: String!, password: String!): Success
  checkInShipment(shipmentId: String!): TradeSideStateResponse
  collectorSubmitReview(offerId: String!): TradeSideStateResponse
  collectorValidateOfferItem(isAccepted: Boolean!, offerItemId: String!): Success
  confirmTrustedTrader: Success
  createAddress(
    addressInput: AddressInput!

    """Set to true to ignore any address suggestion."""
    force: Boolean
    previousResponseId: String
  ): AddressResponse
  createBuyOffer(creatorCash: Float!, creatorCheckoutDetails: CheckoutDetails!, editedOfferId: String, offerType: OfferTypeInput!, originalOfferId: String, receiverItems: [OfferItemForSell!]!, receiverUserId: String): Offer
  createConnectedAccountPayout(amount: Int!, externalAccountId: String, verifyOtpInput: VerifyOtpInput): StripeAccountPayout
  createEmailLoginForSocialAccount(email: String!, password: String!): Success
  createOffer(creatorCash: Float!, creatorCheckoutDetails: CheckoutDetails!, isPartnerTrustedTrader: Boolean, items: [PrivateOfferItem!]!, offerIdeaSignature: String, originalOfferId: String, postAsPublicOffer: Boolean!, receiverCash: Float!, receiverUserId: String!): Offer
  createPresignedUploadPost(filename: String!): PresignedUploadPost
  createPublicOffer(creatorCash: Float!, creatorCheckoutDetails: CheckoutDetails!, creatorItems: [OfferInventoryItem!]!, editedOfferId: String, offerIdeaSignature: String, receiverCash: Float!, receiverItems: [PublicOfferVariantItem!]!, skipDuplicateOfferCheck: Boolean): Offer
  createPublicOffers(offerInputs: [PublicOfferInput!]!): [Offer]!
  createSellOffer(creatorCheckoutDetails: CheckoutDetails!, creatorItems: [OfferItemForSell!]!, editedOfferId: String, offerType: OfferTypeInput!, originalOfferId: String, receiverCash: Float!, receiverUserId: String): Offer
  createSetupIntent: StripeSetupIntent
  createShipments(offerId: String!): Success
  createStreamChatUserToken: StreamChatUserTokenResponse
  createValidator(email: String!, password: String!, phoneNumber: String!): Success
  deleteAccount: Success
  deleteAccountByAdmin(userId: String!): Success

  """<p>Deletes an ExternalAccount for a given Connected Account</p>"""
  deleteExternalAccount(externalAccountId: String!): DeletedExternalAccount

  """
  delete data from the table: "addresses"
  """
  delete_addresses(
    """filter the rows which have to be deleted"""
    where: addresses_bool_exp!
  ): addresses_mutation_response

  """
  delete single row from the table: "addresses"
  """
  delete_addresses_by_pk(id: uuid!): addresses

  """
  delete data from the table: "attribute_attribute_group"
  """
  delete_attribute_attribute_group(
    """filter the rows which have to be deleted"""
    where: attribute_attribute_group_bool_exp!
  ): attribute_attribute_group_mutation_response

  """
  delete single row from the table: "attribute_attribute_group"
  """
  delete_attribute_attribute_group_by_pk(id: uuid!): attribute_attribute_group

  """
  delete data from the table: "attribute_groups"
  """
  delete_attribute_groups(
    """filter the rows which have to be deleted"""
    where: attribute_groups_bool_exp!
  ): attribute_groups_mutation_response

  """
  delete single row from the table: "attribute_groups"
  """
  delete_attribute_groups_by_pk(id: uuid!): attribute_groups

  """
  delete data from the table: "attribute_preferences"
  """
  delete_attribute_preferences(
    """filter the rows which have to be deleted"""
    where: attribute_preferences_bool_exp!
  ): attribute_preferences_mutation_response

  """
  delete single row from the table: "attribute_preferences"
  """
  delete_attribute_preferences_by_pk(id: uuid!): attribute_preferences

  """
  delete data from the table: "attribute_selections"
  """
  delete_attribute_selections(
    """filter the rows which have to be deleted"""
    where: attribute_selections_bool_exp!
  ): attribute_selections_mutation_response

  """
  delete single row from the table: "attribute_selections"
  """
  delete_attribute_selections_by_pk(id: uuid!): attribute_selections

  """
  delete data from the table: "attribute_type"
  """
  delete_attribute_type(
    """filter the rows which have to be deleted"""
    where: attribute_type_bool_exp!
  ): attribute_type_mutation_response

  """
  delete single row from the table: "attribute_type"
  """
  delete_attribute_type_by_pk(value: String!): attribute_type

  """
  delete data from the table: "attribute_values"
  """
  delete_attribute_values(
    """filter the rows which have to be deleted"""
    where: attribute_values_bool_exp!
  ): attribute_values_mutation_response

  """
  delete single row from the table: "attribute_values"
  """
  delete_attribute_values_by_pk(id: uuid!): attribute_values

  """
  delete data from the table: "attributes"
  """
  delete_attributes(
    """filter the rows which have to be deleted"""
    where: attributes_bool_exp!
  ): attributes_mutation_response

  """
  delete single row from the table: "attributes"
  """
  delete_attributes_by_pk(id: uuid!): attributes

  """
  delete data from the table: "badges"
  """
  delete_badges(
    """filter the rows which have to be deleted"""
    where: badges_bool_exp!
  ): badges_mutation_response

  """
  delete single row from the table: "badges"
  """
  delete_badges_by_pk(name: String!): badges

  """
  delete data from the table: "blocks"
  """
  delete_blocks(
    """filter the rows which have to be deleted"""
    where: blocks_bool_exp!
  ): blocks_mutation_response

  """
  delete single row from the table: "blocks"
  """
  delete_blocks_by_pk(blocked_id: uuid!, blocker_id: uuid!): blocks

  """
  delete data from the table: "communication_preference_groups"
  """
  delete_communication_preference_groups(
    """filter the rows which have to be deleted"""
    where: communication_preference_groups_bool_exp!
  ): communication_preference_groups_mutation_response

  """
  delete single row from the table: "communication_preference_groups"
  """
  delete_communication_preference_groups_by_pk(key: String!): communication_preference_groups

  """
  delete data from the table: "communication_preferences"
  """
  delete_communication_preferences(
    """filter the rows which have to be deleted"""
    where: communication_preferences_bool_exp!
  ): communication_preferences_mutation_response

  """
  delete single row from the table: "communication_preferences"
  """
  delete_communication_preferences_by_pk(communication_preference_group_key: String!, user_preference_id: uuid!): communication_preferences

  """
  delete data from the table: "communication_templates"
  """
  delete_communication_templates(
    """filter the rows which have to be deleted"""
    where: communication_templates_bool_exp!
  ): communication_templates_mutation_response

  """
  delete single row from the table: "communication_templates"
  """
  delete_communication_templates_by_pk(key: String!): communication_templates

  """
  delete data from the table: "currencies"
  """
  delete_currencies(
    """filter the rows which have to be deleted"""
    where: currencies_bool_exp!
  ): currencies_mutation_response

  """
  delete single row from the table: "currencies"
  """
  delete_currencies_by_pk(currency: String!): currencies

  """
  delete data from the table: "devices"
  """
  delete_devices(
    """filter the rows which have to be deleted"""
    where: devices_bool_exp!
  ): devices_mutation_response

  """
  delete single row from the table: "devices"
  """
  delete_devices_by_pk(id: uuid!): devices

  """
  delete data from the table: "files"
  """
  delete_files(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete single row from the table: "files"
  """
  delete_files_by_pk(id: uuid!): files

  """
  delete data from the table: "follows"
  """
  delete_follows(
    """filter the rows which have to be deleted"""
    where: follows_bool_exp!
  ): follows_mutation_response

  """
  delete single row from the table: "follows"
  """
  delete_follows_by_pk(follower_id: uuid!, following_id: uuid!): follows

  """
  delete data from the table: "free_shipping_configuration"
  """
  delete_free_shipping_configuration(
    """filter the rows which have to be deleted"""
    where: free_shipping_configuration_bool_exp!
  ): free_shipping_configuration_mutation_response

  """
  delete single row from the table: "free_shipping_configuration"
  """
  delete_free_shipping_configuration_by_pk(id: uuid!): free_shipping_configuration

  """
  delete data from the table: "inventory_items"
  """
  delete_inventory_items(
    """filter the rows which have to be deleted"""
    where: inventory_items_bool_exp!
  ): inventory_items_mutation_response

  """
  delete single row from the table: "inventory_items"
  """
  delete_inventory_items_by_pk(id: uuid!): inventory_items

  """
  delete data from the table: "inventory_status"
  """
  delete_inventory_status(
    """filter the rows which have to be deleted"""
    where: inventory_status_bool_exp!
  ): inventory_status_mutation_response

  """
  delete single row from the table: "inventory_status"
  """
  delete_inventory_status_by_pk(value: String!): inventory_status

  """
  delete data from the table: "languages"
  """
  delete_languages(
    """filter the rows which have to be deleted"""
    where: languages_bool_exp!
  ): languages_mutation_response

  """
  delete single row from the table: "languages"
  """
  delete_languages_by_pk(code: String!): languages

  """
  delete data from the table: "march_mania_bracket"
  """
  delete_march_mania_bracket(
    """filter the rows which have to be deleted"""
    where: march_mania_bracket_bool_exp!
  ): march_mania_bracket_mutation_response

  """
  delete single row from the table: "march_mania_bracket"
  """
  delete_march_mania_bracket_by_pk(id: uuid!): march_mania_bracket

  """
  delete data from the table: "notifications"
  """
  delete_notifications(
    """filter the rows which have to be deleted"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  delete single row from the table: "notifications"
  """
  delete_notifications_by_pk(id: uuid!): notifications

  """
  delete data from the table: "offer_checkouts"
  """
  delete_offer_checkouts(
    """filter the rows which have to be deleted"""
    where: offer_checkouts_bool_exp!
  ): offer_checkouts_mutation_response

  """
  delete single row from the table: "offer_checkouts"
  """
  delete_offer_checkouts_by_pk(id: uuid!): offer_checkouts

  """
  delete data from the table: "offer_item_issue_offer_item_issue_types"
  """
  delete_offer_item_issue_offer_item_issue_types(
    """filter the rows which have to be deleted"""
    where: offer_item_issue_offer_item_issue_types_bool_exp!
  ): offer_item_issue_offer_item_issue_types_mutation_response

  """
  delete single row from the table: "offer_item_issue_offer_item_issue_types"
  """
  delete_offer_item_issue_offer_item_issue_types_by_pk(issue_id: uuid!, issue_type: String!): offer_item_issue_offer_item_issue_types

  """
  delete data from the table: "offer_item_owners"
  """
  delete_offer_item_owners(
    """filter the rows which have to be deleted"""
    where: offer_item_owners_bool_exp!
  ): offer_item_owners_mutation_response

  """
  delete single row from the table: "offer_item_owners"
  """
  delete_offer_item_owners_by_pk(owner: String!): offer_item_owners

  """
  delete data from the table: "offer_item_shipments"
  """
  delete_offer_item_shipments(
    """filter the rows which have to be deleted"""
    where: offer_item_shipments_bool_exp!
  ): offer_item_shipments_mutation_response

  """
  delete single row from the table: "offer_item_shipments"
  """
  delete_offer_item_shipments_by_pk(offer_item_id: uuid!, shipment_id: uuid!): offer_item_shipments

  """
  delete data from the table: "offer_items"
  """
  delete_offer_items(
    """filter the rows which have to be deleted"""
    where: offer_items_bool_exp!
  ): offer_items_mutation_response

  """
  delete single row from the table: "offer_items"
  """
  delete_offer_items_by_pk(id: uuid!): offer_items

  """
  delete data from the table: "offer_items_issues"
  """
  delete_offer_items_issues(
    """filter the rows which have to be deleted"""
    where: offer_items_issues_bool_exp!
  ): offer_items_issues_mutation_response

  """
  delete single row from the table: "offer_items_issues"
  """
  delete_offer_items_issues_by_pk(id: uuid!): offer_items_issues

  """
  delete data from the table: "offer_statuses"
  """
  delete_offer_statuses(
    """filter the rows which have to be deleted"""
    where: offer_statuses_bool_exp!
  ): offer_statuses_mutation_response

  """
  delete single row from the table: "offer_statuses"
  """
  delete_offer_statuses_by_pk(status: String!): offer_statuses

  """
  delete data from the table: "offer_transaction_types"
  """
  delete_offer_transaction_types(
    """filter the rows which have to be deleted"""
    where: offer_transaction_types_bool_exp!
  ): offer_transaction_types_mutation_response

  """
  delete single row from the table: "offer_transaction_types"
  """
  delete_offer_transaction_types_by_pk(transaction_type: String!): offer_transaction_types

  """
  delete data from the table: "offer_types"
  """
  delete_offer_types(
    """filter the rows which have to be deleted"""
    where: offer_types_bool_exp!
  ): offer_types_mutation_response

  """
  delete single row from the table: "offer_types"
  """
  delete_offer_types_by_pk(type: String!): offer_types

  """
  delete data from the table: "offers"
  """
  delete_offers(
    """filter the rows which have to be deleted"""
    where: offers_bool_exp!
  ): offers_mutation_response

  """
  delete single row from the table: "offers"
  """
  delete_offers_by_pk(id: uuid!): offers

  """
  delete data from the table: "payment_transactions"
  """
  delete_payment_transactions(
    """filter the rows which have to be deleted"""
    where: payment_transactions_bool_exp!
  ): payment_transactions_mutation_response

  """
  delete single row from the table: "payment_transactions"
  """
  delete_payment_transactions_by_pk(id: uuid!): payment_transactions

  """
  delete data from the table: "price_report"
  """
  delete_price_report(
    """filter the rows which have to be deleted"""
    where: price_report_bool_exp!
  ): price_report_mutation_response

  """
  delete single row from the table: "price_report"
  """
  delete_price_report_by_pk(id: uuid!): price_report

  """
  delete data from the table: "product_promo_configuration"
  """
  delete_product_promo_configuration(
    """filter the rows which have to be deleted"""
    where: product_promo_configuration_bool_exp!
  ): product_promo_configuration_mutation_response

  """
  delete single row from the table: "product_promo_configuration"
  """
  delete_product_promo_configuration_by_pk(product_id: uuid!, promo_configuration_id: uuid!): product_promo_configuration

  """
  delete data from the table: "product_variants"
  """
  delete_product_variants(
    """filter the rows which have to be deleted"""
    where: product_variants_bool_exp!
  ): product_variants_mutation_response

  """
  delete single row from the table: "product_variants"
  """
  delete_product_variants_by_pk(id: uuid!): product_variants

  """
  delete data from the table: "products"
  """
  delete_products(
    """filter the rows which have to be deleted"""
    where: products_bool_exp!
  ): products_mutation_response

  """
  delete single row from the table: "products"
  """
  delete_products_by_pk(id: uuid!): products

  """
  delete data from the table: "promo_configuration"
  """
  delete_promo_configuration(
    """filter the rows which have to be deleted"""
    where: promo_configuration_bool_exp!
  ): promo_configuration_mutation_response

  """
  delete single row from the table: "promo_configuration"
  """
  delete_promo_configuration_by_pk(id: uuid!): promo_configuration

  """
  delete data from the table: "promo_configuration_name"
  """
  delete_promo_configuration_name(
    """filter the rows which have to be deleted"""
    where: promo_configuration_name_bool_exp!
  ): promo_configuration_name_mutation_response

  """
  delete single row from the table: "promo_configuration_name"
  """
  delete_promo_configuration_name_by_pk(name: String!): promo_configuration_name

  """
  delete data from the table: "report_categories"
  """
  delete_report_categories(
    """filter the rows which have to be deleted"""
    where: report_categories_bool_exp!
  ): report_categories_mutation_response

  """
  delete single row from the table: "report_categories"
  """
  delete_report_categories_by_pk(key: String!): report_categories

  """
  delete data from the table: "reports"
  """
  delete_reports(
    """filter the rows which have to be deleted"""
    where: reports_bool_exp!
  ): reports_mutation_response

  """
  delete single row from the table: "reports"
  """
  delete_reports_by_pk(categoryKey: report_categories_enum!, reported_id: uuid!, reporter_id: uuid!): reports

  """
  delete data from the table: "roles"
  """
  delete_roles(
    """filter the rows which have to be deleted"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  delete single row from the table: "roles"
  """
  delete_roles_by_pk(name: String!): roles

  """
  delete data from the table: "shipments"
  """
  delete_shipments(
    """filter the rows which have to be deleted"""
    where: shipments_bool_exp!
  ): shipments_mutation_response

  """
  delete single row from the table: "shipments"
  """
  delete_shipments_by_pk(id: uuid!): shipments

  """
  delete data from the table: "trade_state_updates"
  """
  delete_trade_state_updates(
    """filter the rows which have to be deleted"""
    where: trade_state_updates_bool_exp!
  ): trade_state_updates_mutation_response

  """
  delete single row from the table: "trade_state_updates"
  """
  delete_trade_state_updates_by_pk(id: uuid!): trade_state_updates

  """
  delete data from the table: "trades"
  """
  delete_trades(
    """filter the rows which have to be deleted"""
    where: trades_bool_exp!
  ): trades_mutation_response

  """
  delete single row from the table: "trades"
  """
  delete_trades_by_pk(id: uuid!): trades

  """
  delete data from the table: "user_activities"
  """
  delete_user_activities(
    """filter the rows which have to be deleted"""
    where: user_activities_bool_exp!
  ): user_activities_mutation_response

  """
  delete single row from the table: "user_activities"
  """
  delete_user_activities_by_pk(id: uuid!): user_activities

  """
  delete data from the table: "user_admin_informations"
  """
  delete_user_admin_informations(
    """filter the rows which have to be deleted"""
    where: user_admin_informations_bool_exp!
  ): user_admin_informations_mutation_response

  """
  delete single row from the table: "user_admin_informations"
  """
  delete_user_admin_informations_by_pk(id: uuid!): user_admin_informations

  """
  delete data from the table: "user_badges"
  """
  delete_user_badges(
    """filter the rows which have to be deleted"""
    where: user_badges_bool_exp!
  ): user_badges_mutation_response

  """
  delete single row from the table: "user_badges"
  """
  delete_user_badges_by_pk(badge_name: badges_enum!, user_id: uuid!): user_badges

  """
  delete data from the table: "user_notifications"
  """
  delete_user_notifications(
    """filter the rows which have to be deleted"""
    where: user_notifications_bool_exp!
  ): user_notifications_mutation_response

  """
  delete single row from the table: "user_notifications"
  """
  delete_user_notifications_by_pk(notification_id: uuid!, notified_id: uuid!): user_notifications

  """
  delete data from the table: "user_preferences"
  """
  delete_user_preferences(
    """filter the rows which have to be deleted"""
    where: user_preferences_bool_exp!
  ): user_preferences_mutation_response

  """
  delete single row from the table: "user_preferences"
  """
  delete_user_preferences_by_pk(id: uuid!): user_preferences

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: uuid!): users

  """
  delete data from the table: "validators"
  """
  delete_validators(
    """filter the rows which have to be deleted"""
    where: validators_bool_exp!
  ): validators_mutation_response

  """
  delete single row from the table: "validators"
  """
  delete_validators_by_pk(id: uuid!): validators

  """
  delete data from the table: "wishlist_items"
  """
  delete_wishlist_items(
    """filter the rows which have to be deleted"""
    where: wishlist_items_bool_exp!
  ): wishlist_items_mutation_response

  """
  delete single row from the table: "wishlist_items"
  """
  delete_wishlist_items_by_pk(id: uuid!): wishlist_items
  forceTrustedTraderCandidate(userId: String!, value: Boolean!): Success
  freezeUser(reason: String!, userId: String!): Success
  handleStripeEvent(api_version: JSON, authorization_token: String!, created: JSON, data: JSON, id: JSON, livemode: JSON, object: JSON, pending_webhooks: JSON, request: JSON, type: JSON): Success

  """
  insert data into the table: "addresses"
  """
  insert_addresses(
    """the rows to be inserted"""
    objects: [addresses_insert_input!]!

    """upsert condition"""
    on_conflict: addresses_on_conflict
  ): addresses_mutation_response

  """
  insert a single row into the table: "addresses"
  """
  insert_addresses_one(
    """the row to be inserted"""
    object: addresses_insert_input!

    """upsert condition"""
    on_conflict: addresses_on_conflict
  ): addresses

  """
  insert data into the table: "attribute_attribute_group"
  """
  insert_attribute_attribute_group(
    """the rows to be inserted"""
    objects: [attribute_attribute_group_insert_input!]!

    """upsert condition"""
    on_conflict: attribute_attribute_group_on_conflict
  ): attribute_attribute_group_mutation_response

  """
  insert a single row into the table: "attribute_attribute_group"
  """
  insert_attribute_attribute_group_one(
    """the row to be inserted"""
    object: attribute_attribute_group_insert_input!

    """upsert condition"""
    on_conflict: attribute_attribute_group_on_conflict
  ): attribute_attribute_group

  """
  insert data into the table: "attribute_groups"
  """
  insert_attribute_groups(
    """the rows to be inserted"""
    objects: [attribute_groups_insert_input!]!

    """upsert condition"""
    on_conflict: attribute_groups_on_conflict
  ): attribute_groups_mutation_response

  """
  insert a single row into the table: "attribute_groups"
  """
  insert_attribute_groups_one(
    """the row to be inserted"""
    object: attribute_groups_insert_input!

    """upsert condition"""
    on_conflict: attribute_groups_on_conflict
  ): attribute_groups

  """
  insert data into the table: "attribute_preferences"
  """
  insert_attribute_preferences(
    """the rows to be inserted"""
    objects: [attribute_preferences_insert_input!]!

    """upsert condition"""
    on_conflict: attribute_preferences_on_conflict
  ): attribute_preferences_mutation_response

  """
  insert a single row into the table: "attribute_preferences"
  """
  insert_attribute_preferences_one(
    """the row to be inserted"""
    object: attribute_preferences_insert_input!

    """upsert condition"""
    on_conflict: attribute_preferences_on_conflict
  ): attribute_preferences

  """
  insert data into the table: "attribute_selections"
  """
  insert_attribute_selections(
    """the rows to be inserted"""
    objects: [attribute_selections_insert_input!]!

    """upsert condition"""
    on_conflict: attribute_selections_on_conflict
  ): attribute_selections_mutation_response

  """
  insert a single row into the table: "attribute_selections"
  """
  insert_attribute_selections_one(
    """the row to be inserted"""
    object: attribute_selections_insert_input!

    """upsert condition"""
    on_conflict: attribute_selections_on_conflict
  ): attribute_selections

  """
  insert data into the table: "attribute_type"
  """
  insert_attribute_type(
    """the rows to be inserted"""
    objects: [attribute_type_insert_input!]!

    """upsert condition"""
    on_conflict: attribute_type_on_conflict
  ): attribute_type_mutation_response

  """
  insert a single row into the table: "attribute_type"
  """
  insert_attribute_type_one(
    """the row to be inserted"""
    object: attribute_type_insert_input!

    """upsert condition"""
    on_conflict: attribute_type_on_conflict
  ): attribute_type

  """
  insert data into the table: "attribute_values"
  """
  insert_attribute_values(
    """the rows to be inserted"""
    objects: [attribute_values_insert_input!]!

    """upsert condition"""
    on_conflict: attribute_values_on_conflict
  ): attribute_values_mutation_response

  """
  insert a single row into the table: "attribute_values"
  """
  insert_attribute_values_one(
    """the row to be inserted"""
    object: attribute_values_insert_input!

    """upsert condition"""
    on_conflict: attribute_values_on_conflict
  ): attribute_values

  """
  insert data into the table: "attributes"
  """
  insert_attributes(
    """the rows to be inserted"""
    objects: [attributes_insert_input!]!

    """upsert condition"""
    on_conflict: attributes_on_conflict
  ): attributes_mutation_response

  """
  insert a single row into the table: "attributes"
  """
  insert_attributes_one(
    """the row to be inserted"""
    object: attributes_insert_input!

    """upsert condition"""
    on_conflict: attributes_on_conflict
  ): attributes

  """
  insert data into the table: "badges"
  """
  insert_badges(
    """the rows to be inserted"""
    objects: [badges_insert_input!]!

    """upsert condition"""
    on_conflict: badges_on_conflict
  ): badges_mutation_response

  """
  insert a single row into the table: "badges"
  """
  insert_badges_one(
    """the row to be inserted"""
    object: badges_insert_input!

    """upsert condition"""
    on_conflict: badges_on_conflict
  ): badges

  """
  insert data into the table: "blocks"
  """
  insert_blocks(
    """the rows to be inserted"""
    objects: [blocks_insert_input!]!

    """upsert condition"""
    on_conflict: blocks_on_conflict
  ): blocks_mutation_response

  """
  insert a single row into the table: "blocks"
  """
  insert_blocks_one(
    """the row to be inserted"""
    object: blocks_insert_input!

    """upsert condition"""
    on_conflict: blocks_on_conflict
  ): blocks

  """
  insert data into the table: "communication_preference_groups"
  """
  insert_communication_preference_groups(
    """the rows to be inserted"""
    objects: [communication_preference_groups_insert_input!]!

    """upsert condition"""
    on_conflict: communication_preference_groups_on_conflict
  ): communication_preference_groups_mutation_response

  """
  insert a single row into the table: "communication_preference_groups"
  """
  insert_communication_preference_groups_one(
    """the row to be inserted"""
    object: communication_preference_groups_insert_input!

    """upsert condition"""
    on_conflict: communication_preference_groups_on_conflict
  ): communication_preference_groups

  """
  insert data into the table: "communication_preferences"
  """
  insert_communication_preferences(
    """the rows to be inserted"""
    objects: [communication_preferences_insert_input!]!

    """upsert condition"""
    on_conflict: communication_preferences_on_conflict
  ): communication_preferences_mutation_response

  """
  insert a single row into the table: "communication_preferences"
  """
  insert_communication_preferences_one(
    """the row to be inserted"""
    object: communication_preferences_insert_input!

    """upsert condition"""
    on_conflict: communication_preferences_on_conflict
  ): communication_preferences

  """
  insert data into the table: "communication_templates"
  """
  insert_communication_templates(
    """the rows to be inserted"""
    objects: [communication_templates_insert_input!]!

    """upsert condition"""
    on_conflict: communication_templates_on_conflict
  ): communication_templates_mutation_response

  """
  insert a single row into the table: "communication_templates"
  """
  insert_communication_templates_one(
    """the row to be inserted"""
    object: communication_templates_insert_input!

    """upsert condition"""
    on_conflict: communication_templates_on_conflict
  ): communication_templates

  """
  insert data into the table: "currencies"
  """
  insert_currencies(
    """the rows to be inserted"""
    objects: [currencies_insert_input!]!

    """upsert condition"""
    on_conflict: currencies_on_conflict
  ): currencies_mutation_response

  """
  insert a single row into the table: "currencies"
  """
  insert_currencies_one(
    """the row to be inserted"""
    object: currencies_insert_input!

    """upsert condition"""
    on_conflict: currencies_on_conflict
  ): currencies

  """
  insert data into the table: "devices"
  """
  insert_devices(
    """the rows to be inserted"""
    objects: [devices_insert_input!]!

    """upsert condition"""
    on_conflict: devices_on_conflict
  ): devices_mutation_response

  """
  insert a single row into the table: "devices"
  """
  insert_devices_one(
    """the row to be inserted"""
    object: devices_insert_input!

    """upsert condition"""
    on_conflict: devices_on_conflict
  ): devices

  """
  insert data into the table: "files"
  """
  insert_files(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert a single row into the table: "files"
  """
  insert_files_one(
    """the row to be inserted"""
    object: files_insert_input!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "follows"
  """
  insert_follows(
    """the rows to be inserted"""
    objects: [follows_insert_input!]!

    """upsert condition"""
    on_conflict: follows_on_conflict
  ): follows_mutation_response

  """
  insert a single row into the table: "follows"
  """
  insert_follows_one(
    """the row to be inserted"""
    object: follows_insert_input!

    """upsert condition"""
    on_conflict: follows_on_conflict
  ): follows

  """
  insert data into the table: "free_shipping_configuration"
  """
  insert_free_shipping_configuration(
    """the rows to be inserted"""
    objects: [free_shipping_configuration_insert_input!]!

    """upsert condition"""
    on_conflict: free_shipping_configuration_on_conflict
  ): free_shipping_configuration_mutation_response

  """
  insert a single row into the table: "free_shipping_configuration"
  """
  insert_free_shipping_configuration_one(
    """the row to be inserted"""
    object: free_shipping_configuration_insert_input!

    """upsert condition"""
    on_conflict: free_shipping_configuration_on_conflict
  ): free_shipping_configuration

  """
  insert data into the table: "inventory_items"
  """
  insert_inventory_items(
    """the rows to be inserted"""
    objects: [inventory_items_insert_input!]!

    """upsert condition"""
    on_conflict: inventory_items_on_conflict
  ): inventory_items_mutation_response

  """
  insert a single row into the table: "inventory_items"
  """
  insert_inventory_items_one(
    """the row to be inserted"""
    object: inventory_items_insert_input!

    """upsert condition"""
    on_conflict: inventory_items_on_conflict
  ): inventory_items

  """
  insert data into the table: "inventory_status"
  """
  insert_inventory_status(
    """the rows to be inserted"""
    objects: [inventory_status_insert_input!]!

    """upsert condition"""
    on_conflict: inventory_status_on_conflict
  ): inventory_status_mutation_response

  """
  insert a single row into the table: "inventory_status"
  """
  insert_inventory_status_one(
    """the row to be inserted"""
    object: inventory_status_insert_input!

    """upsert condition"""
    on_conflict: inventory_status_on_conflict
  ): inventory_status

  """
  insert data into the table: "languages"
  """
  insert_languages(
    """the rows to be inserted"""
    objects: [languages_insert_input!]!

    """upsert condition"""
    on_conflict: languages_on_conflict
  ): languages_mutation_response

  """
  insert a single row into the table: "languages"
  """
  insert_languages_one(
    """the row to be inserted"""
    object: languages_insert_input!

    """upsert condition"""
    on_conflict: languages_on_conflict
  ): languages

  """
  insert data into the table: "march_mania_bracket"
  """
  insert_march_mania_bracket(
    """the rows to be inserted"""
    objects: [march_mania_bracket_insert_input!]!

    """upsert condition"""
    on_conflict: march_mania_bracket_on_conflict
  ): march_mania_bracket_mutation_response

  """
  insert a single row into the table: "march_mania_bracket"
  """
  insert_march_mania_bracket_one(
    """the row to be inserted"""
    object: march_mania_bracket_insert_input!

    """upsert condition"""
    on_conflict: march_mania_bracket_on_conflict
  ): march_mania_bracket

  """
  insert data into the table: "notifications"
  """
  insert_notifications(
    """the rows to be inserted"""
    objects: [notifications_insert_input!]!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications_mutation_response

  """
  insert a single row into the table: "notifications"
  """
  insert_notifications_one(
    """the row to be inserted"""
    object: notifications_insert_input!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications

  """
  insert data into the table: "offer_checkouts"
  """
  insert_offer_checkouts(
    """the rows to be inserted"""
    objects: [offer_checkouts_insert_input!]!

    """upsert condition"""
    on_conflict: offer_checkouts_on_conflict
  ): offer_checkouts_mutation_response

  """
  insert a single row into the table: "offer_checkouts"
  """
  insert_offer_checkouts_one(
    """the row to be inserted"""
    object: offer_checkouts_insert_input!

    """upsert condition"""
    on_conflict: offer_checkouts_on_conflict
  ): offer_checkouts

  """
  insert data into the table: "offer_item_issue_offer_item_issue_types"
  """
  insert_offer_item_issue_offer_item_issue_types(
    """the rows to be inserted"""
    objects: [offer_item_issue_offer_item_issue_types_insert_input!]!

    """upsert condition"""
    on_conflict: offer_item_issue_offer_item_issue_types_on_conflict
  ): offer_item_issue_offer_item_issue_types_mutation_response

  """
  insert a single row into the table: "offer_item_issue_offer_item_issue_types"
  """
  insert_offer_item_issue_offer_item_issue_types_one(
    """the row to be inserted"""
    object: offer_item_issue_offer_item_issue_types_insert_input!

    """upsert condition"""
    on_conflict: offer_item_issue_offer_item_issue_types_on_conflict
  ): offer_item_issue_offer_item_issue_types

  """
  insert data into the table: "offer_item_owners"
  """
  insert_offer_item_owners(
    """the rows to be inserted"""
    objects: [offer_item_owners_insert_input!]!

    """upsert condition"""
    on_conflict: offer_item_owners_on_conflict
  ): offer_item_owners_mutation_response

  """
  insert a single row into the table: "offer_item_owners"
  """
  insert_offer_item_owners_one(
    """the row to be inserted"""
    object: offer_item_owners_insert_input!

    """upsert condition"""
    on_conflict: offer_item_owners_on_conflict
  ): offer_item_owners

  """
  insert data into the table: "offer_item_shipments"
  """
  insert_offer_item_shipments(
    """the rows to be inserted"""
    objects: [offer_item_shipments_insert_input!]!

    """upsert condition"""
    on_conflict: offer_item_shipments_on_conflict
  ): offer_item_shipments_mutation_response

  """
  insert a single row into the table: "offer_item_shipments"
  """
  insert_offer_item_shipments_one(
    """the row to be inserted"""
    object: offer_item_shipments_insert_input!

    """upsert condition"""
    on_conflict: offer_item_shipments_on_conflict
  ): offer_item_shipments

  """
  insert data into the table: "offer_items"
  """
  insert_offer_items(
    """the rows to be inserted"""
    objects: [offer_items_insert_input!]!

    """upsert condition"""
    on_conflict: offer_items_on_conflict
  ): offer_items_mutation_response

  """
  insert data into the table: "offer_items_issues"
  """
  insert_offer_items_issues(
    """the rows to be inserted"""
    objects: [offer_items_issues_insert_input!]!

    """upsert condition"""
    on_conflict: offer_items_issues_on_conflict
  ): offer_items_issues_mutation_response

  """
  insert a single row into the table: "offer_items_issues"
  """
  insert_offer_items_issues_one(
    """the row to be inserted"""
    object: offer_items_issues_insert_input!

    """upsert condition"""
    on_conflict: offer_items_issues_on_conflict
  ): offer_items_issues

  """
  insert a single row into the table: "offer_items"
  """
  insert_offer_items_one(
    """the row to be inserted"""
    object: offer_items_insert_input!

    """upsert condition"""
    on_conflict: offer_items_on_conflict
  ): offer_items

  """
  insert data into the table: "offer_statuses"
  """
  insert_offer_statuses(
    """the rows to be inserted"""
    objects: [offer_statuses_insert_input!]!

    """upsert condition"""
    on_conflict: offer_statuses_on_conflict
  ): offer_statuses_mutation_response

  """
  insert a single row into the table: "offer_statuses"
  """
  insert_offer_statuses_one(
    """the row to be inserted"""
    object: offer_statuses_insert_input!

    """upsert condition"""
    on_conflict: offer_statuses_on_conflict
  ): offer_statuses

  """
  insert data into the table: "offer_transaction_types"
  """
  insert_offer_transaction_types(
    """the rows to be inserted"""
    objects: [offer_transaction_types_insert_input!]!

    """upsert condition"""
    on_conflict: offer_transaction_types_on_conflict
  ): offer_transaction_types_mutation_response

  """
  insert a single row into the table: "offer_transaction_types"
  """
  insert_offer_transaction_types_one(
    """the row to be inserted"""
    object: offer_transaction_types_insert_input!

    """upsert condition"""
    on_conflict: offer_transaction_types_on_conflict
  ): offer_transaction_types

  """
  insert data into the table: "offer_types"
  """
  insert_offer_types(
    """the rows to be inserted"""
    objects: [offer_types_insert_input!]!

    """upsert condition"""
    on_conflict: offer_types_on_conflict
  ): offer_types_mutation_response

  """
  insert a single row into the table: "offer_types"
  """
  insert_offer_types_one(
    """the row to be inserted"""
    object: offer_types_insert_input!

    """upsert condition"""
    on_conflict: offer_types_on_conflict
  ): offer_types

  """
  insert data into the table: "offers"
  """
  insert_offers(
    """the rows to be inserted"""
    objects: [offers_insert_input!]!

    """upsert condition"""
    on_conflict: offers_on_conflict
  ): offers_mutation_response

  """
  insert a single row into the table: "offers"
  """
  insert_offers_one(
    """the row to be inserted"""
    object: offers_insert_input!

    """upsert condition"""
    on_conflict: offers_on_conflict
  ): offers

  """
  insert data into the table: "payment_transactions"
  """
  insert_payment_transactions(
    """the rows to be inserted"""
    objects: [payment_transactions_insert_input!]!

    """upsert condition"""
    on_conflict: payment_transactions_on_conflict
  ): payment_transactions_mutation_response

  """
  insert a single row into the table: "payment_transactions"
  """
  insert_payment_transactions_one(
    """the row to be inserted"""
    object: payment_transactions_insert_input!

    """upsert condition"""
    on_conflict: payment_transactions_on_conflict
  ): payment_transactions

  """
  insert data into the table: "price_report"
  """
  insert_price_report(
    """the rows to be inserted"""
    objects: [price_report_insert_input!]!

    """upsert condition"""
    on_conflict: price_report_on_conflict
  ): price_report_mutation_response

  """
  insert a single row into the table: "price_report"
  """
  insert_price_report_one(
    """the row to be inserted"""
    object: price_report_insert_input!

    """upsert condition"""
    on_conflict: price_report_on_conflict
  ): price_report

  """
  insert data into the table: "product_promo_configuration"
  """
  insert_product_promo_configuration(
    """the rows to be inserted"""
    objects: [product_promo_configuration_insert_input!]!

    """upsert condition"""
    on_conflict: product_promo_configuration_on_conflict
  ): product_promo_configuration_mutation_response

  """
  insert a single row into the table: "product_promo_configuration"
  """
  insert_product_promo_configuration_one(
    """the row to be inserted"""
    object: product_promo_configuration_insert_input!

    """upsert condition"""
    on_conflict: product_promo_configuration_on_conflict
  ): product_promo_configuration

  """
  insert data into the table: "product_variants"
  """
  insert_product_variants(
    """the rows to be inserted"""
    objects: [product_variants_insert_input!]!

    """upsert condition"""
    on_conflict: product_variants_on_conflict
  ): product_variants_mutation_response

  """
  insert a single row into the table: "product_variants"
  """
  insert_product_variants_one(
    """the row to be inserted"""
    object: product_variants_insert_input!

    """upsert condition"""
    on_conflict: product_variants_on_conflict
  ): product_variants

  """
  insert data into the table: "products"
  """
  insert_products(
    """the rows to be inserted"""
    objects: [products_insert_input!]!

    """upsert condition"""
    on_conflict: products_on_conflict
  ): products_mutation_response

  """
  insert a single row into the table: "products"
  """
  insert_products_one(
    """the row to be inserted"""
    object: products_insert_input!

    """upsert condition"""
    on_conflict: products_on_conflict
  ): products

  """
  insert data into the table: "promo_configuration"
  """
  insert_promo_configuration(
    """the rows to be inserted"""
    objects: [promo_configuration_insert_input!]!

    """upsert condition"""
    on_conflict: promo_configuration_on_conflict
  ): promo_configuration_mutation_response

  """
  insert data into the table: "promo_configuration_name"
  """
  insert_promo_configuration_name(
    """the rows to be inserted"""
    objects: [promo_configuration_name_insert_input!]!

    """upsert condition"""
    on_conflict: promo_configuration_name_on_conflict
  ): promo_configuration_name_mutation_response

  """
  insert a single row into the table: "promo_configuration_name"
  """
  insert_promo_configuration_name_one(
    """the row to be inserted"""
    object: promo_configuration_name_insert_input!

    """upsert condition"""
    on_conflict: promo_configuration_name_on_conflict
  ): promo_configuration_name

  """
  insert a single row into the table: "promo_configuration"
  """
  insert_promo_configuration_one(
    """the row to be inserted"""
    object: promo_configuration_insert_input!

    """upsert condition"""
    on_conflict: promo_configuration_on_conflict
  ): promo_configuration

  """
  insert data into the table: "report_categories"
  """
  insert_report_categories(
    """the rows to be inserted"""
    objects: [report_categories_insert_input!]!

    """upsert condition"""
    on_conflict: report_categories_on_conflict
  ): report_categories_mutation_response

  """
  insert a single row into the table: "report_categories"
  """
  insert_report_categories_one(
    """the row to be inserted"""
    object: report_categories_insert_input!

    """upsert condition"""
    on_conflict: report_categories_on_conflict
  ): report_categories

  """
  insert data into the table: "reports"
  """
  insert_reports(
    """the rows to be inserted"""
    objects: [reports_insert_input!]!

    """upsert condition"""
    on_conflict: reports_on_conflict
  ): reports_mutation_response

  """
  insert a single row into the table: "reports"
  """
  insert_reports_one(
    """the row to be inserted"""
    object: reports_insert_input!

    """upsert condition"""
    on_conflict: reports_on_conflict
  ): reports

  """
  insert data into the table: "roles"
  """
  insert_roles(
    """the rows to be inserted"""
    objects: [roles_insert_input!]!

    """upsert condition"""
    on_conflict: roles_on_conflict
  ): roles_mutation_response

  """
  insert a single row into the table: "roles"
  """
  insert_roles_one(
    """the row to be inserted"""
    object: roles_insert_input!

    """upsert condition"""
    on_conflict: roles_on_conflict
  ): roles

  """
  insert data into the table: "shipments"
  """
  insert_shipments(
    """the rows to be inserted"""
    objects: [shipments_insert_input!]!

    """upsert condition"""
    on_conflict: shipments_on_conflict
  ): shipments_mutation_response

  """
  insert a single row into the table: "shipments"
  """
  insert_shipments_one(
    """the row to be inserted"""
    object: shipments_insert_input!

    """upsert condition"""
    on_conflict: shipments_on_conflict
  ): shipments

  """
  insert data into the table: "trade_state_updates"
  """
  insert_trade_state_updates(
    """the rows to be inserted"""
    objects: [trade_state_updates_insert_input!]!

    """upsert condition"""
    on_conflict: trade_state_updates_on_conflict
  ): trade_state_updates_mutation_response

  """
  insert a single row into the table: "trade_state_updates"
  """
  insert_trade_state_updates_one(
    """the row to be inserted"""
    object: trade_state_updates_insert_input!

    """upsert condition"""
    on_conflict: trade_state_updates_on_conflict
  ): trade_state_updates

  """
  insert data into the table: "trades"
  """
  insert_trades(
    """the rows to be inserted"""
    objects: [trades_insert_input!]!

    """upsert condition"""
    on_conflict: trades_on_conflict
  ): trades_mutation_response

  """
  insert a single row into the table: "trades"
  """
  insert_trades_one(
    """the row to be inserted"""
    object: trades_insert_input!

    """upsert condition"""
    on_conflict: trades_on_conflict
  ): trades

  """
  insert data into the table: "user_activities"
  """
  insert_user_activities(
    """the rows to be inserted"""
    objects: [user_activities_insert_input!]!

    """upsert condition"""
    on_conflict: user_activities_on_conflict
  ): user_activities_mutation_response

  """
  insert a single row into the table: "user_activities"
  """
  insert_user_activities_one(
    """the row to be inserted"""
    object: user_activities_insert_input!

    """upsert condition"""
    on_conflict: user_activities_on_conflict
  ): user_activities

  """
  insert data into the table: "user_admin_informations"
  """
  insert_user_admin_informations(
    """the rows to be inserted"""
    objects: [user_admin_informations_insert_input!]!

    """upsert condition"""
    on_conflict: user_admin_informations_on_conflict
  ): user_admin_informations_mutation_response

  """
  insert a single row into the table: "user_admin_informations"
  """
  insert_user_admin_informations_one(
    """the row to be inserted"""
    object: user_admin_informations_insert_input!

    """upsert condition"""
    on_conflict: user_admin_informations_on_conflict
  ): user_admin_informations

  """
  insert data into the table: "user_badges"
  """
  insert_user_badges(
    """the rows to be inserted"""
    objects: [user_badges_insert_input!]!

    """upsert condition"""
    on_conflict: user_badges_on_conflict
  ): user_badges_mutation_response

  """
  insert a single row into the table: "user_badges"
  """
  insert_user_badges_one(
    """the row to be inserted"""
    object: user_badges_insert_input!

    """upsert condition"""
    on_conflict: user_badges_on_conflict
  ): user_badges

  """
  insert data into the table: "user_notifications"
  """
  insert_user_notifications(
    """the rows to be inserted"""
    objects: [user_notifications_insert_input!]!

    """upsert condition"""
    on_conflict: user_notifications_on_conflict
  ): user_notifications_mutation_response

  """
  insert a single row into the table: "user_notifications"
  """
  insert_user_notifications_one(
    """the row to be inserted"""
    object: user_notifications_insert_input!

    """upsert condition"""
    on_conflict: user_notifications_on_conflict
  ): user_notifications

  """
  insert data into the table: "user_preferences"
  """
  insert_user_preferences(
    """the rows to be inserted"""
    objects: [user_preferences_insert_input!]!

    """upsert condition"""
    on_conflict: user_preferences_on_conflict
  ): user_preferences_mutation_response

  """
  insert a single row into the table: "user_preferences"
  """
  insert_user_preferences_one(
    """the row to be inserted"""
    object: user_preferences_insert_input!

    """upsert condition"""
    on_conflict: user_preferences_on_conflict
  ): user_preferences

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "validators"
  """
  insert_validators(
    """the rows to be inserted"""
    objects: [validators_insert_input!]!

    """upsert condition"""
    on_conflict: validators_on_conflict
  ): validators_mutation_response

  """
  insert a single row into the table: "validators"
  """
  insert_validators_one(
    """the row to be inserted"""
    object: validators_insert_input!

    """upsert condition"""
    on_conflict: validators_on_conflict
  ): validators

  """
  insert data into the table: "wishlist_items"
  """
  insert_wishlist_items(
    """the rows to be inserted"""
    objects: [wishlist_items_insert_input!]!

    """upsert condition"""
    on_conflict: wishlist_items_on_conflict
  ): wishlist_items_mutation_response

  """
  insert a single row into the table: "wishlist_items"
  """
  insert_wishlist_items_one(
    """the row to be inserted"""
    object: wishlist_items_insert_input!

    """upsert condition"""
    on_conflict: wishlist_items_on_conflict
  ): wishlist_items
  markMessagesAsRead(userId: String): Success
  markShipmentAsLost(offerId: String!, shipmentId: String!): Success
  notifyUploadedFile(filename: String!, path: String!, shipmentId: String): NotifyUploadedFileResult
  pickUp(shipmentId: String!): Success
  processReview(offerId: String!): Success
  registerUserActivity: Success
  removePaymentMethod(paymentMethodId: String!): Success
  removeSocialAccount(socialProvider: SocialAuthProvider!): Success
  resetPassword(email: String!, password: String!, resetCode: String!): Success
  revertTrade(offerCheckoutId: String!, offerId: String!, revertTradeStep: RevertTradeStepType!): Success
  sendOtp(phoneNumber: String): SendOtpResponse
  setCollectorTrustedTradesDate(date: DateTime!, userId: String!): Success
  signUp(email: String!, firstName: String, lastName: String, password: String!): Success
  signUpUser: Success
  socialSignUp: Success
  strapi: strapiMutation
  syncProductPrices(fileUrl: String!): Success
  timeoutCollectorReviews: Success
  timeoutOnHoldTrades: Success
  timeoutShipments: Success
  unblockUser(blockedGetStreamUserId: String!, blockedUserId: String!): Success
  undoShipmentTimeout(shipmentId: String!): Success
  unfreezeUser(userId: String!): Success
  updateAddress(
    addressId: String!
    addressInput: AddressInput!

    """User ID for the address. Only supported for admins."""
    addressUserId: String

    """Set to true to ignore any address suggestion."""
    force: Boolean
    previousResponseId: String
  ): AddressResponse

  """<p>Updates an ExternalAccount for a given Connected Account</p>"""
  updateExternalAccount(default: Boolean!, externalAccountId: String!): ExternalAccount
  updateInsurance(inboundInsurance: Boolean!, offerId: String!, outboundInsurance: Boolean!): Success
  updateOfferPaymentMethod(offerId: String, paymentMethodId: String!): Success
  updatePaymentMethod(paymentMethodId: String!, paymentMethodUpdate: StripePaymentMethodUpdate!): Success
  updatePriorityShoes(productIds: [String!]): Success
  updateProductVariantPrices: Success
  updateShipment(authorizationToken: String!, carrier: String, data: JSON!, event: String!, metadata: String, test: Boolean): Success
  updateShippingAddress(offerId: String, shippingAddressId: String!): Success
  updateSkippedShoes(productIds: [String!]): Success
  updateStripeCustomer(input: UpdateStripeCustomerInput!): Success
  updateTrustedTraderCandidates: Success

  """
  update data of the table: "addresses"
  """
  update_addresses(
    """increments the numeric columns with given value of the filtered values"""
    _inc: addresses_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: addresses_set_input

    """filter the rows which have to be updated"""
    where: addresses_bool_exp!
  ): addresses_mutation_response

  """
  update single row of the table: "addresses"
  """
  update_addresses_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: addresses_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: addresses_set_input
    pk_columns: addresses_pk_columns_input!
  ): addresses

  """
  update multiples rows of table: "addresses"
  """
  update_addresses_many(
    """updates to execute, in order"""
    updates: [addresses_updates!]!
  ): [addresses_mutation_response]

  """
  update data of the table: "attribute_attribute_group"
  """
  update_attribute_attribute_group(
    """sets the columns of the filtered rows to the given values"""
    _set: attribute_attribute_group_set_input

    """filter the rows which have to be updated"""
    where: attribute_attribute_group_bool_exp!
  ): attribute_attribute_group_mutation_response

  """
  update single row of the table: "attribute_attribute_group"
  """
  update_attribute_attribute_group_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: attribute_attribute_group_set_input
    pk_columns: attribute_attribute_group_pk_columns_input!
  ): attribute_attribute_group

  """
  update multiples rows of table: "attribute_attribute_group"
  """
  update_attribute_attribute_group_many(
    """updates to execute, in order"""
    updates: [attribute_attribute_group_updates!]!
  ): [attribute_attribute_group_mutation_response]

  """
  update data of the table: "attribute_groups"
  """
  update_attribute_groups(
    """increments the numeric columns with given value of the filtered values"""
    _inc: attribute_groups_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: attribute_groups_set_input

    """filter the rows which have to be updated"""
    where: attribute_groups_bool_exp!
  ): attribute_groups_mutation_response

  """
  update single row of the table: "attribute_groups"
  """
  update_attribute_groups_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: attribute_groups_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: attribute_groups_set_input
    pk_columns: attribute_groups_pk_columns_input!
  ): attribute_groups

  """
  update multiples rows of table: "attribute_groups"
  """
  update_attribute_groups_many(
    """updates to execute, in order"""
    updates: [attribute_groups_updates!]!
  ): [attribute_groups_mutation_response]

  """
  update data of the table: "attribute_preferences"
  """
  update_attribute_preferences(
    """increments the numeric columns with given value of the filtered values"""
    _inc: attribute_preferences_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: attribute_preferences_set_input

    """filter the rows which have to be updated"""
    where: attribute_preferences_bool_exp!
  ): attribute_preferences_mutation_response

  """
  update single row of the table: "attribute_preferences"
  """
  update_attribute_preferences_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: attribute_preferences_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: attribute_preferences_set_input
    pk_columns: attribute_preferences_pk_columns_input!
  ): attribute_preferences

  """
  update multiples rows of table: "attribute_preferences"
  """
  update_attribute_preferences_many(
    """updates to execute, in order"""
    updates: [attribute_preferences_updates!]!
  ): [attribute_preferences_mutation_response]

  """
  update data of the table: "attribute_selections"
  """
  update_attribute_selections(
    """increments the numeric columns with given value of the filtered values"""
    _inc: attribute_selections_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: attribute_selections_set_input

    """filter the rows which have to be updated"""
    where: attribute_selections_bool_exp!
  ): attribute_selections_mutation_response

  """
  update single row of the table: "attribute_selections"
  """
  update_attribute_selections_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: attribute_selections_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: attribute_selections_set_input
    pk_columns: attribute_selections_pk_columns_input!
  ): attribute_selections

  """
  update multiples rows of table: "attribute_selections"
  """
  update_attribute_selections_many(
    """updates to execute, in order"""
    updates: [attribute_selections_updates!]!
  ): [attribute_selections_mutation_response]

  """
  update data of the table: "attribute_type"
  """
  update_attribute_type(
    """sets the columns of the filtered rows to the given values"""
    _set: attribute_type_set_input

    """filter the rows which have to be updated"""
    where: attribute_type_bool_exp!
  ): attribute_type_mutation_response

  """
  update single row of the table: "attribute_type"
  """
  update_attribute_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: attribute_type_set_input
    pk_columns: attribute_type_pk_columns_input!
  ): attribute_type

  """
  update multiples rows of table: "attribute_type"
  """
  update_attribute_type_many(
    """updates to execute, in order"""
    updates: [attribute_type_updates!]!
  ): [attribute_type_mutation_response]

  """
  update data of the table: "attribute_values"
  """
  update_attribute_values(
    """increments the numeric columns with given value of the filtered values"""
    _inc: attribute_values_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: attribute_values_set_input

    """filter the rows which have to be updated"""
    where: attribute_values_bool_exp!
  ): attribute_values_mutation_response

  """
  update single row of the table: "attribute_values"
  """
  update_attribute_values_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: attribute_values_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: attribute_values_set_input
    pk_columns: attribute_values_pk_columns_input!
  ): attribute_values

  """
  update multiples rows of table: "attribute_values"
  """
  update_attribute_values_many(
    """updates to execute, in order"""
    updates: [attribute_values_updates!]!
  ): [attribute_values_mutation_response]

  """
  update data of the table: "attributes"
  """
  update_attributes(
    """increments the numeric columns with given value of the filtered values"""
    _inc: attributes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: attributes_set_input

    """filter the rows which have to be updated"""
    where: attributes_bool_exp!
  ): attributes_mutation_response

  """
  update single row of the table: "attributes"
  """
  update_attributes_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: attributes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: attributes_set_input
    pk_columns: attributes_pk_columns_input!
  ): attributes

  """
  update multiples rows of table: "attributes"
  """
  update_attributes_many(
    """updates to execute, in order"""
    updates: [attributes_updates!]!
  ): [attributes_mutation_response]

  """
  update data of the table: "badges"
  """
  update_badges(
    """sets the columns of the filtered rows to the given values"""
    _set: badges_set_input

    """filter the rows which have to be updated"""
    where: badges_bool_exp!
  ): badges_mutation_response

  """
  update single row of the table: "badges"
  """
  update_badges_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: badges_set_input
    pk_columns: badges_pk_columns_input!
  ): badges

  """
  update multiples rows of table: "badges"
  """
  update_badges_many(
    """updates to execute, in order"""
    updates: [badges_updates!]!
  ): [badges_mutation_response]

  """
  update data of the table: "blocks"
  """
  update_blocks(
    """sets the columns of the filtered rows to the given values"""
    _set: blocks_set_input

    """filter the rows which have to be updated"""
    where: blocks_bool_exp!
  ): blocks_mutation_response

  """
  update single row of the table: "blocks"
  """
  update_blocks_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: blocks_set_input
    pk_columns: blocks_pk_columns_input!
  ): blocks

  """
  update multiples rows of table: "blocks"
  """
  update_blocks_many(
    """updates to execute, in order"""
    updates: [blocks_updates!]!
  ): [blocks_mutation_response]

  """
  update data of the table: "communication_preference_groups"
  """
  update_communication_preference_groups(
    """sets the columns of the filtered rows to the given values"""
    _set: communication_preference_groups_set_input

    """filter the rows which have to be updated"""
    where: communication_preference_groups_bool_exp!
  ): communication_preference_groups_mutation_response

  """
  update single row of the table: "communication_preference_groups"
  """
  update_communication_preference_groups_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: communication_preference_groups_set_input
    pk_columns: communication_preference_groups_pk_columns_input!
  ): communication_preference_groups

  """
  update multiples rows of table: "communication_preference_groups"
  """
  update_communication_preference_groups_many(
    """updates to execute, in order"""
    updates: [communication_preference_groups_updates!]!
  ): [communication_preference_groups_mutation_response]

  """
  update data of the table: "communication_preferences"
  """
  update_communication_preferences(
    """sets the columns of the filtered rows to the given values"""
    _set: communication_preferences_set_input

    """filter the rows which have to be updated"""
    where: communication_preferences_bool_exp!
  ): communication_preferences_mutation_response

  """
  update single row of the table: "communication_preferences"
  """
  update_communication_preferences_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: communication_preferences_set_input
    pk_columns: communication_preferences_pk_columns_input!
  ): communication_preferences

  """
  update multiples rows of table: "communication_preferences"
  """
  update_communication_preferences_many(
    """updates to execute, in order"""
    updates: [communication_preferences_updates!]!
  ): [communication_preferences_mutation_response]

  """
  update data of the table: "communication_templates"
  """
  update_communication_templates(
    """sets the columns of the filtered rows to the given values"""
    _set: communication_templates_set_input

    """filter the rows which have to be updated"""
    where: communication_templates_bool_exp!
  ): communication_templates_mutation_response

  """
  update single row of the table: "communication_templates"
  """
  update_communication_templates_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: communication_templates_set_input
    pk_columns: communication_templates_pk_columns_input!
  ): communication_templates

  """
  update multiples rows of table: "communication_templates"
  """
  update_communication_templates_many(
    """updates to execute, in order"""
    updates: [communication_templates_updates!]!
  ): [communication_templates_mutation_response]

  """
  update data of the table: "currencies"
  """
  update_currencies(
    """sets the columns of the filtered rows to the given values"""
    _set: currencies_set_input

    """filter the rows which have to be updated"""
    where: currencies_bool_exp!
  ): currencies_mutation_response

  """
  update single row of the table: "currencies"
  """
  update_currencies_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: currencies_set_input
    pk_columns: currencies_pk_columns_input!
  ): currencies

  """
  update multiples rows of table: "currencies"
  """
  update_currencies_many(
    """updates to execute, in order"""
    updates: [currencies_updates!]!
  ): [currencies_mutation_response]

  """
  update data of the table: "devices"
  """
  update_devices(
    """sets the columns of the filtered rows to the given values"""
    _set: devices_set_input

    """filter the rows which have to be updated"""
    where: devices_bool_exp!
  ): devices_mutation_response

  """
  update single row of the table: "devices"
  """
  update_devices_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: devices_set_input
    pk_columns: devices_pk_columns_input!
  ): devices

  """
  update multiples rows of table: "devices"
  """
  update_devices_many(
    """updates to execute, in order"""
    updates: [devices_updates!]!
  ): [devices_mutation_response]

  """
  update data of the table: "files"
  """
  update_files(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input

    """filter the rows which have to be updated"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  update single row of the table: "files"
  """
  update_files_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input
    pk_columns: files_pk_columns_input!
  ): files

  """
  update multiples rows of table: "files"
  """
  update_files_many(
    """updates to execute, in order"""
    updates: [files_updates!]!
  ): [files_mutation_response]

  """
  update data of the table: "follows"
  """
  update_follows(
    """sets the columns of the filtered rows to the given values"""
    _set: follows_set_input

    """filter the rows which have to be updated"""
    where: follows_bool_exp!
  ): follows_mutation_response

  """
  update single row of the table: "follows"
  """
  update_follows_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: follows_set_input
    pk_columns: follows_pk_columns_input!
  ): follows

  """
  update multiples rows of table: "follows"
  """
  update_follows_many(
    """updates to execute, in order"""
    updates: [follows_updates!]!
  ): [follows_mutation_response]

  """
  update data of the table: "free_shipping_configuration"
  """
  update_free_shipping_configuration(
    """increments the numeric columns with given value of the filtered values"""
    _inc: free_shipping_configuration_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: free_shipping_configuration_set_input

    """filter the rows which have to be updated"""
    where: free_shipping_configuration_bool_exp!
  ): free_shipping_configuration_mutation_response

  """
  update single row of the table: "free_shipping_configuration"
  """
  update_free_shipping_configuration_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: free_shipping_configuration_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: free_shipping_configuration_set_input
    pk_columns: free_shipping_configuration_pk_columns_input!
  ): free_shipping_configuration

  """
  update multiples rows of table: "free_shipping_configuration"
  """
  update_free_shipping_configuration_many(
    """updates to execute, in order"""
    updates: [free_shipping_configuration_updates!]!
  ): [free_shipping_configuration_mutation_response]

  """
  update data of the table: "inventory_items"
  """
  update_inventory_items(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: inventory_items_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: inventory_items_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: inventory_items_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: inventory_items_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: inventory_items_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: inventory_items_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: inventory_items_set_input

    """filter the rows which have to be updated"""
    where: inventory_items_bool_exp!
  ): inventory_items_mutation_response

  """
  update single row of the table: "inventory_items"
  """
  update_inventory_items_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: inventory_items_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: inventory_items_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: inventory_items_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: inventory_items_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: inventory_items_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: inventory_items_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: inventory_items_set_input
    pk_columns: inventory_items_pk_columns_input!
  ): inventory_items

  """
  update multiples rows of table: "inventory_items"
  """
  update_inventory_items_many(
    """updates to execute, in order"""
    updates: [inventory_items_updates!]!
  ): [inventory_items_mutation_response]

  """
  update data of the table: "inventory_status"
  """
  update_inventory_status(
    """sets the columns of the filtered rows to the given values"""
    _set: inventory_status_set_input

    """filter the rows which have to be updated"""
    where: inventory_status_bool_exp!
  ): inventory_status_mutation_response

  """
  update single row of the table: "inventory_status"
  """
  update_inventory_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: inventory_status_set_input
    pk_columns: inventory_status_pk_columns_input!
  ): inventory_status

  """
  update multiples rows of table: "inventory_status"
  """
  update_inventory_status_many(
    """updates to execute, in order"""
    updates: [inventory_status_updates!]!
  ): [inventory_status_mutation_response]

  """
  update data of the table: "languages"
  """
  update_languages(
    """sets the columns of the filtered rows to the given values"""
    _set: languages_set_input

    """filter the rows which have to be updated"""
    where: languages_bool_exp!
  ): languages_mutation_response

  """
  update single row of the table: "languages"
  """
  update_languages_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: languages_set_input
    pk_columns: languages_pk_columns_input!
  ): languages

  """
  update multiples rows of table: "languages"
  """
  update_languages_many(
    """updates to execute, in order"""
    updates: [languages_updates!]!
  ): [languages_mutation_response]

  """
  update data of the table: "march_mania_bracket"
  """
  update_march_mania_bracket(
    """increments the numeric columns with given value of the filtered values"""
    _inc: march_mania_bracket_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: march_mania_bracket_set_input

    """filter the rows which have to be updated"""
    where: march_mania_bracket_bool_exp!
  ): march_mania_bracket_mutation_response

  """
  update single row of the table: "march_mania_bracket"
  """
  update_march_mania_bracket_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: march_mania_bracket_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: march_mania_bracket_set_input
    pk_columns: march_mania_bracket_pk_columns_input!
  ): march_mania_bracket

  """
  update multiples rows of table: "march_mania_bracket"
  """
  update_march_mania_bracket_many(
    """updates to execute, in order"""
    updates: [march_mania_bracket_updates!]!
  ): [march_mania_bracket_mutation_response]

  """
  update data of the table: "notifications"
  """
  update_notifications(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: notifications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notifications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notifications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notifications_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: notifications_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: notifications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input

    """filter the rows which have to be updated"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  update single row of the table: "notifications"
  """
  update_notifications_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: notifications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notifications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notifications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notifications_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: notifications_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: notifications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input
    pk_columns: notifications_pk_columns_input!
  ): notifications

  """
  update multiples rows of table: "notifications"
  """
  update_notifications_many(
    """updates to execute, in order"""
    updates: [notifications_updates!]!
  ): [notifications_mutation_response]

  """
  update data of the table: "offer_checkouts"
  """
  update_offer_checkouts(
    """increments the numeric columns with given value of the filtered values"""
    _inc: offer_checkouts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: offer_checkouts_set_input

    """filter the rows which have to be updated"""
    where: offer_checkouts_bool_exp!
  ): offer_checkouts_mutation_response

  """
  update single row of the table: "offer_checkouts"
  """
  update_offer_checkouts_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: offer_checkouts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: offer_checkouts_set_input
    pk_columns: offer_checkouts_pk_columns_input!
  ): offer_checkouts

  """
  update multiples rows of table: "offer_checkouts"
  """
  update_offer_checkouts_many(
    """updates to execute, in order"""
    updates: [offer_checkouts_updates!]!
  ): [offer_checkouts_mutation_response]

  """
  update data of the table: "offer_item_issue_offer_item_issue_types"
  """
  update_offer_item_issue_offer_item_issue_types(
    """sets the columns of the filtered rows to the given values"""
    _set: offer_item_issue_offer_item_issue_types_set_input

    """filter the rows which have to be updated"""
    where: offer_item_issue_offer_item_issue_types_bool_exp!
  ): offer_item_issue_offer_item_issue_types_mutation_response

  """
  update single row of the table: "offer_item_issue_offer_item_issue_types"
  """
  update_offer_item_issue_offer_item_issue_types_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: offer_item_issue_offer_item_issue_types_set_input
    pk_columns: offer_item_issue_offer_item_issue_types_pk_columns_input!
  ): offer_item_issue_offer_item_issue_types

  """
  update multiples rows of table: "offer_item_issue_offer_item_issue_types"
  """
  update_offer_item_issue_offer_item_issue_types_many(
    """updates to execute, in order"""
    updates: [offer_item_issue_offer_item_issue_types_updates!]!
  ): [offer_item_issue_offer_item_issue_types_mutation_response]

  """
  update data of the table: "offer_item_owners"
  """
  update_offer_item_owners(
    """sets the columns of the filtered rows to the given values"""
    _set: offer_item_owners_set_input

    """filter the rows which have to be updated"""
    where: offer_item_owners_bool_exp!
  ): offer_item_owners_mutation_response

  """
  update single row of the table: "offer_item_owners"
  """
  update_offer_item_owners_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: offer_item_owners_set_input
    pk_columns: offer_item_owners_pk_columns_input!
  ): offer_item_owners

  """
  update multiples rows of table: "offer_item_owners"
  """
  update_offer_item_owners_many(
    """updates to execute, in order"""
    updates: [offer_item_owners_updates!]!
  ): [offer_item_owners_mutation_response]

  """
  update data of the table: "offer_item_shipments"
  """
  update_offer_item_shipments(
    """sets the columns of the filtered rows to the given values"""
    _set: offer_item_shipments_set_input

    """filter the rows which have to be updated"""
    where: offer_item_shipments_bool_exp!
  ): offer_item_shipments_mutation_response

  """
  update single row of the table: "offer_item_shipments"
  """
  update_offer_item_shipments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: offer_item_shipments_set_input
    pk_columns: offer_item_shipments_pk_columns_input!
  ): offer_item_shipments

  """
  update multiples rows of table: "offer_item_shipments"
  """
  update_offer_item_shipments_many(
    """updates to execute, in order"""
    updates: [offer_item_shipments_updates!]!
  ): [offer_item_shipments_mutation_response]

  """
  update data of the table: "offer_items"
  """
  update_offer_items(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: offer_items_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: offer_items_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: offer_items_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: offer_items_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: offer_items_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: offer_items_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: offer_items_set_input

    """filter the rows which have to be updated"""
    where: offer_items_bool_exp!
  ): offer_items_mutation_response

  """
  update single row of the table: "offer_items"
  """
  update_offer_items_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: offer_items_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: offer_items_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: offer_items_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: offer_items_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: offer_items_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: offer_items_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: offer_items_set_input
    pk_columns: offer_items_pk_columns_input!
  ): offer_items

  """
  update data of the table: "offer_items_issues"
  """
  update_offer_items_issues(
    """increments the numeric columns with given value of the filtered values"""
    _inc: offer_items_issues_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: offer_items_issues_set_input

    """filter the rows which have to be updated"""
    where: offer_items_issues_bool_exp!
  ): offer_items_issues_mutation_response

  """
  update single row of the table: "offer_items_issues"
  """
  update_offer_items_issues_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: offer_items_issues_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: offer_items_issues_set_input
    pk_columns: offer_items_issues_pk_columns_input!
  ): offer_items_issues

  """
  update multiples rows of table: "offer_items_issues"
  """
  update_offer_items_issues_many(
    """updates to execute, in order"""
    updates: [offer_items_issues_updates!]!
  ): [offer_items_issues_mutation_response]

  """
  update multiples rows of table: "offer_items"
  """
  update_offer_items_many(
    """updates to execute, in order"""
    updates: [offer_items_updates!]!
  ): [offer_items_mutation_response]

  """
  update data of the table: "offer_statuses"
  """
  update_offer_statuses(
    """sets the columns of the filtered rows to the given values"""
    _set: offer_statuses_set_input

    """filter the rows which have to be updated"""
    where: offer_statuses_bool_exp!
  ): offer_statuses_mutation_response

  """
  update single row of the table: "offer_statuses"
  """
  update_offer_statuses_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: offer_statuses_set_input
    pk_columns: offer_statuses_pk_columns_input!
  ): offer_statuses

  """
  update multiples rows of table: "offer_statuses"
  """
  update_offer_statuses_many(
    """updates to execute, in order"""
    updates: [offer_statuses_updates!]!
  ): [offer_statuses_mutation_response]

  """
  update data of the table: "offer_transaction_types"
  """
  update_offer_transaction_types(
    """sets the columns of the filtered rows to the given values"""
    _set: offer_transaction_types_set_input

    """filter the rows which have to be updated"""
    where: offer_transaction_types_bool_exp!
  ): offer_transaction_types_mutation_response

  """
  update single row of the table: "offer_transaction_types"
  """
  update_offer_transaction_types_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: offer_transaction_types_set_input
    pk_columns: offer_transaction_types_pk_columns_input!
  ): offer_transaction_types

  """
  update multiples rows of table: "offer_transaction_types"
  """
  update_offer_transaction_types_many(
    """updates to execute, in order"""
    updates: [offer_transaction_types_updates!]!
  ): [offer_transaction_types_mutation_response]

  """
  update data of the table: "offer_types"
  """
  update_offer_types(
    """sets the columns of the filtered rows to the given values"""
    _set: offer_types_set_input

    """filter the rows which have to be updated"""
    where: offer_types_bool_exp!
  ): offer_types_mutation_response

  """
  update single row of the table: "offer_types"
  """
  update_offer_types_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: offer_types_set_input
    pk_columns: offer_types_pk_columns_input!
  ): offer_types

  """
  update multiples rows of table: "offer_types"
  """
  update_offer_types_many(
    """updates to execute, in order"""
    updates: [offer_types_updates!]!
  ): [offer_types_mutation_response]

  """
  update data of the table: "offers"
  """
  update_offers(
    """increments the numeric columns with given value of the filtered values"""
    _inc: offers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: offers_set_input

    """filter the rows which have to be updated"""
    where: offers_bool_exp!
  ): offers_mutation_response

  """
  update single row of the table: "offers"
  """
  update_offers_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: offers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: offers_set_input
    pk_columns: offers_pk_columns_input!
  ): offers

  """
  update multiples rows of table: "offers"
  """
  update_offers_many(
    """updates to execute, in order"""
    updates: [offers_updates!]!
  ): [offers_mutation_response]

  """
  update data of the table: "payment_transactions"
  """
  update_payment_transactions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_transactions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_transactions_set_input

    """filter the rows which have to be updated"""
    where: payment_transactions_bool_exp!
  ): payment_transactions_mutation_response

  """
  update single row of the table: "payment_transactions"
  """
  update_payment_transactions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_transactions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_transactions_set_input
    pk_columns: payment_transactions_pk_columns_input!
  ): payment_transactions

  """
  update multiples rows of table: "payment_transactions"
  """
  update_payment_transactions_many(
    """updates to execute, in order"""
    updates: [payment_transactions_updates!]!
  ): [payment_transactions_mutation_response]

  """
  update data of the table: "price_report"
  """
  update_price_report(
    """increments the numeric columns with given value of the filtered values"""
    _inc: price_report_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: price_report_set_input

    """filter the rows which have to be updated"""
    where: price_report_bool_exp!
  ): price_report_mutation_response

  """
  update single row of the table: "price_report"
  """
  update_price_report_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: price_report_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: price_report_set_input
    pk_columns: price_report_pk_columns_input!
  ): price_report

  """
  update multiples rows of table: "price_report"
  """
  update_price_report_many(
    """updates to execute, in order"""
    updates: [price_report_updates!]!
  ): [price_report_mutation_response]

  """
  update data of the table: "product_promo_configuration"
  """
  update_product_promo_configuration(
    """sets the columns of the filtered rows to the given values"""
    _set: product_promo_configuration_set_input

    """filter the rows which have to be updated"""
    where: product_promo_configuration_bool_exp!
  ): product_promo_configuration_mutation_response

  """
  update single row of the table: "product_promo_configuration"
  """
  update_product_promo_configuration_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_promo_configuration_set_input
    pk_columns: product_promo_configuration_pk_columns_input!
  ): product_promo_configuration

  """
  update multiples rows of table: "product_promo_configuration"
  """
  update_product_promo_configuration_many(
    """updates to execute, in order"""
    updates: [product_promo_configuration_updates!]!
  ): [product_promo_configuration_mutation_response]

  """
  update data of the table: "product_variants"
  """
  update_product_variants(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: product_variants_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: product_variants_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: product_variants_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: product_variants_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: product_variants_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: product_variants_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_variants_set_input

    """filter the rows which have to be updated"""
    where: product_variants_bool_exp!
  ): product_variants_mutation_response

  """
  update single row of the table: "product_variants"
  """
  update_product_variants_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: product_variants_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: product_variants_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: product_variants_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: product_variants_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: product_variants_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: product_variants_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_variants_set_input
    pk_columns: product_variants_pk_columns_input!
  ): product_variants

  """
  update multiples rows of table: "product_variants"
  """
  update_product_variants_many(
    """updates to execute, in order"""
    updates: [product_variants_updates!]!
  ): [product_variants_mutation_response]

  """
  update data of the table: "products"
  """
  update_products(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: products_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: products_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: products_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: products_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: products_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: products_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: products_set_input

    """filter the rows which have to be updated"""
    where: products_bool_exp!
  ): products_mutation_response

  """
  update single row of the table: "products"
  """
  update_products_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: products_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: products_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: products_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: products_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: products_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: products_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: products_set_input
    pk_columns: products_pk_columns_input!
  ): products

  """
  update multiples rows of table: "products"
  """
  update_products_many(
    """updates to execute, in order"""
    updates: [products_updates!]!
  ): [products_mutation_response]

  """
  update data of the table: "promo_configuration"
  """
  update_promo_configuration(
    """increments the numeric columns with given value of the filtered values"""
    _inc: promo_configuration_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: promo_configuration_set_input

    """filter the rows which have to be updated"""
    where: promo_configuration_bool_exp!
  ): promo_configuration_mutation_response

  """
  update single row of the table: "promo_configuration"
  """
  update_promo_configuration_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: promo_configuration_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: promo_configuration_set_input
    pk_columns: promo_configuration_pk_columns_input!
  ): promo_configuration

  """
  update multiples rows of table: "promo_configuration"
  """
  update_promo_configuration_many(
    """updates to execute, in order"""
    updates: [promo_configuration_updates!]!
  ): [promo_configuration_mutation_response]

  """
  update data of the table: "promo_configuration_name"
  """
  update_promo_configuration_name(
    """sets the columns of the filtered rows to the given values"""
    _set: promo_configuration_name_set_input

    """filter the rows which have to be updated"""
    where: promo_configuration_name_bool_exp!
  ): promo_configuration_name_mutation_response

  """
  update single row of the table: "promo_configuration_name"
  """
  update_promo_configuration_name_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: promo_configuration_name_set_input
    pk_columns: promo_configuration_name_pk_columns_input!
  ): promo_configuration_name

  """
  update multiples rows of table: "promo_configuration_name"
  """
  update_promo_configuration_name_many(
    """updates to execute, in order"""
    updates: [promo_configuration_name_updates!]!
  ): [promo_configuration_name_mutation_response]

  """
  update data of the table: "report_categories"
  """
  update_report_categories(
    """sets the columns of the filtered rows to the given values"""
    _set: report_categories_set_input

    """filter the rows which have to be updated"""
    where: report_categories_bool_exp!
  ): report_categories_mutation_response

  """
  update single row of the table: "report_categories"
  """
  update_report_categories_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: report_categories_set_input
    pk_columns: report_categories_pk_columns_input!
  ): report_categories

  """
  update multiples rows of table: "report_categories"
  """
  update_report_categories_many(
    """updates to execute, in order"""
    updates: [report_categories_updates!]!
  ): [report_categories_mutation_response]

  """
  update data of the table: "reports"
  """
  update_reports(
    """sets the columns of the filtered rows to the given values"""
    _set: reports_set_input

    """filter the rows which have to be updated"""
    where: reports_bool_exp!
  ): reports_mutation_response

  """
  update single row of the table: "reports"
  """
  update_reports_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: reports_set_input
    pk_columns: reports_pk_columns_input!
  ): reports

  """
  update multiples rows of table: "reports"
  """
  update_reports_many(
    """updates to execute, in order"""
    updates: [reports_updates!]!
  ): [reports_mutation_response]

  """
  update data of the table: "roles"
  """
  update_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input

    """filter the rows which have to be updated"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  update single row of the table: "roles"
  """
  update_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input
    pk_columns: roles_pk_columns_input!
  ): roles

  """
  update multiples rows of table: "roles"
  """
  update_roles_many(
    """updates to execute, in order"""
    updates: [roles_updates!]!
  ): [roles_mutation_response]

  """
  update data of the table: "shipments"
  """
  update_shipments(
    """increments the numeric columns with given value of the filtered values"""
    _inc: shipments_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: shipments_set_input

    """filter the rows which have to be updated"""
    where: shipments_bool_exp!
  ): shipments_mutation_response

  """
  update single row of the table: "shipments"
  """
  update_shipments_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: shipments_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: shipments_set_input
    pk_columns: shipments_pk_columns_input!
  ): shipments

  """
  update multiples rows of table: "shipments"
  """
  update_shipments_many(
    """updates to execute, in order"""
    updates: [shipments_updates!]!
  ): [shipments_mutation_response]

  """
  update data of the table: "trade_state_updates"
  """
  update_trade_state_updates(
    """sets the columns of the filtered rows to the given values"""
    _set: trade_state_updates_set_input

    """filter the rows which have to be updated"""
    where: trade_state_updates_bool_exp!
  ): trade_state_updates_mutation_response

  """
  update single row of the table: "trade_state_updates"
  """
  update_trade_state_updates_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: trade_state_updates_set_input
    pk_columns: trade_state_updates_pk_columns_input!
  ): trade_state_updates

  """
  update multiples rows of table: "trade_state_updates"
  """
  update_trade_state_updates_many(
    """updates to execute, in order"""
    updates: [trade_state_updates_updates!]!
  ): [trade_state_updates_mutation_response]

  """
  update data of the table: "trades"
  """
  update_trades(
    """increments the numeric columns with given value of the filtered values"""
    _inc: trades_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: trades_set_input

    """filter the rows which have to be updated"""
    where: trades_bool_exp!
  ): trades_mutation_response

  """
  update single row of the table: "trades"
  """
  update_trades_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: trades_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: trades_set_input
    pk_columns: trades_pk_columns_input!
  ): trades

  """
  update multiples rows of table: "trades"
  """
  update_trades_many(
    """updates to execute, in order"""
    updates: [trades_updates!]!
  ): [trades_mutation_response]

  """
  update data of the table: "user_activities"
  """
  update_user_activities(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_activities_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_activities_set_input

    """filter the rows which have to be updated"""
    where: user_activities_bool_exp!
  ): user_activities_mutation_response

  """
  update single row of the table: "user_activities"
  """
  update_user_activities_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_activities_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_activities_set_input
    pk_columns: user_activities_pk_columns_input!
  ): user_activities

  """
  update multiples rows of table: "user_activities"
  """
  update_user_activities_many(
    """updates to execute, in order"""
    updates: [user_activities_updates!]!
  ): [user_activities_mutation_response]

  """
  update data of the table: "user_admin_informations"
  """
  update_user_admin_informations(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_admin_informations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_admin_informations_set_input

    """filter the rows which have to be updated"""
    where: user_admin_informations_bool_exp!
  ): user_admin_informations_mutation_response

  """
  update single row of the table: "user_admin_informations"
  """
  update_user_admin_informations_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_admin_informations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_admin_informations_set_input
    pk_columns: user_admin_informations_pk_columns_input!
  ): user_admin_informations

  """
  update multiples rows of table: "user_admin_informations"
  """
  update_user_admin_informations_many(
    """updates to execute, in order"""
    updates: [user_admin_informations_updates!]!
  ): [user_admin_informations_mutation_response]

  """
  update data of the table: "user_badges"
  """
  update_user_badges(
    """sets the columns of the filtered rows to the given values"""
    _set: user_badges_set_input

    """filter the rows which have to be updated"""
    where: user_badges_bool_exp!
  ): user_badges_mutation_response

  """
  update single row of the table: "user_badges"
  """
  update_user_badges_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_badges_set_input
    pk_columns: user_badges_pk_columns_input!
  ): user_badges

  """
  update multiples rows of table: "user_badges"
  """
  update_user_badges_many(
    """updates to execute, in order"""
    updates: [user_badges_updates!]!
  ): [user_badges_mutation_response]

  """
  update data of the table: "user_notifications"
  """
  update_user_notifications(
    """sets the columns of the filtered rows to the given values"""
    _set: user_notifications_set_input

    """filter the rows which have to be updated"""
    where: user_notifications_bool_exp!
  ): user_notifications_mutation_response

  """
  update single row of the table: "user_notifications"
  """
  update_user_notifications_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_notifications_set_input
    pk_columns: user_notifications_pk_columns_input!
  ): user_notifications

  """
  update multiples rows of table: "user_notifications"
  """
  update_user_notifications_many(
    """updates to execute, in order"""
    updates: [user_notifications_updates!]!
  ): [user_notifications_mutation_response]

  """
  update data of the table: "user_preferences"
  """
  update_user_preferences(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_preferences_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_preferences_set_input

    """filter the rows which have to be updated"""
    where: user_preferences_bool_exp!
  ): user_preferences_mutation_response

  """
  update single row of the table: "user_preferences"
  """
  update_user_preferences_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_preferences_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_preferences_set_input
    pk_columns: user_preferences_pk_columns_input!
  ): user_preferences

  """
  update multiples rows of table: "user_preferences"
  """
  update_user_preferences_many(
    """updates to execute, in order"""
    updates: [user_preferences_updates!]!
  ): [user_preferences_mutation_response]

  """
  update data of the table: "users"
  """
  update_users(
    """increments the numeric columns with given value of the filtered values"""
    _inc: users_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: users_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update multiples rows of table: "users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]

  """
  update data of the table: "validators"
  """
  update_validators(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validators_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validators_set_input

    """filter the rows which have to be updated"""
    where: validators_bool_exp!
  ): validators_mutation_response

  """
  update single row of the table: "validators"
  """
  update_validators_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validators_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validators_set_input
    pk_columns: validators_pk_columns_input!
  ): validators

  """
  update multiples rows of table: "validators"
  """
  update_validators_many(
    """updates to execute, in order"""
    updates: [validators_updates!]!
  ): [validators_mutation_response]

  """
  update data of the table: "wishlist_items"
  """
  update_wishlist_items(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: wishlist_items_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: wishlist_items_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: wishlist_items_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: wishlist_items_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: wishlist_items_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: wishlist_items_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: wishlist_items_set_input

    """filter the rows which have to be updated"""
    where: wishlist_items_bool_exp!
  ): wishlist_items_mutation_response

  """
  update single row of the table: "wishlist_items"
  """
  update_wishlist_items_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: wishlist_items_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: wishlist_items_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: wishlist_items_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: wishlist_items_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: wishlist_items_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: wishlist_items_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: wishlist_items_set_input
    pk_columns: wishlist_items_pk_columns_input!
  ): wishlist_items

  """
  update multiples rows of table: "wishlist_items"
  """
  update_wishlist_items_many(
    """updates to execute, in order"""
    updates: [wishlist_items_updates!]!
  ): [wishlist_items_mutation_response]
  validatorSubmitReview(offerId: String!, shipmentId: String!): TradeSideStateResponse
  validatorValidateOfferItem(issues: [OfferItemIssue!]!, offerItemId: String!): Success
  verifyPaymentMethod(paymentMethodId: String!): VerifyPaymentMethodResult
}

"""Holds notifications created due to an action by a user."""
type notifications {
  """An object relationship"""
  communication_template: communication_templates!
  communication_template_key: String!
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  notification_key: String

  """An object relationship"""
  owner: users!
  owner_id: uuid!
  updated_at: timestamptz!

  """An array relationship"""
  user_notifications(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): [user_notifications!]!

  """An aggregate relationship"""
  user_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): user_notifications_aggregate!
}

"""
aggregated selection of "notifications"
"""
type notifications_aggregate {
  aggregate: notifications_aggregate_fields
  nodes: [notifications!]!
}

input notifications_aggregate_bool_exp {
  count: notifications_aggregate_bool_exp_count
}

input notifications_aggregate_bool_exp_count {
  arguments: [notifications_select_column!]
  distinct: Boolean
  filter: notifications_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notifications"
"""
type notifications_aggregate_fields {
  avg: notifications_avg_fields
  count(columns: [notifications_select_column!], distinct: Boolean): Int!
  max: notifications_max_fields
  min: notifications_min_fields
  stddev: notifications_stddev_fields
  stddev_pop: notifications_stddev_pop_fields
  stddev_samp: notifications_stddev_samp_fields
  sum: notifications_sum_fields
  var_pop: notifications_var_pop_fields
  var_samp: notifications_var_samp_fields
  variance: notifications_variance_fields
}

"""
order by aggregate values of table "notifications"
"""
input notifications_aggregate_order_by {
  avg: notifications_avg_order_by
  count: order_by
  max: notifications_max_order_by
  min: notifications_min_order_by
  stddev: notifications_stddev_order_by
  stddev_pop: notifications_stddev_pop_order_by
  stddev_samp: notifications_stddev_samp_order_by
  sum: notifications_sum_order_by
  var_pop: notifications_var_pop_order_by
  var_samp: notifications_var_samp_order_by
  variance: notifications_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input notifications_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "notifications"
"""
input notifications_arr_rel_insert_input {
  data: [notifications_insert_input!]!

  """upsert condition"""
  on_conflict: notifications_on_conflict
}

"""aggregate avg on columns"""
type notifications_avg_fields {
  deleted_at: Float
}

"""
order by avg() on columns of table "notifications"
"""
input notifications_avg_order_by {
  deleted_at: order_by
}

"""
Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'.
"""
input notifications_bool_exp {
  _and: [notifications_bool_exp!]
  _not: notifications_bool_exp
  _or: [notifications_bool_exp!]
  communication_template: communication_templates_bool_exp
  communication_template_key: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  notification_key: String_comparison_exp
  owner: users_bool_exp
  owner_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_notifications: user_notifications_bool_exp
  user_notifications_aggregate: user_notifications_aggregate_bool_exp
}

"""
unique or primary key constraints on table "notifications"
"""
enum notifications_constraint {
  """
  unique or primary key constraint on columns "notification_key"
  """
  notifications_notification_key_key

  """
  unique or primary key constraint on columns "id"
  """
  notifications_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input notifications_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input notifications_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input notifications_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "notifications"
"""
input notifications_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "notifications"
"""
input notifications_insert_input {
  communication_template: communication_templates_obj_rel_insert_input
  communication_template_key: String
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  metadata: jsonb
  notification_key: String
  owner: users_obj_rel_insert_input
  owner_id: uuid
  updated_at: timestamptz
  user_notifications: user_notifications_arr_rel_insert_input
}

"""aggregate max on columns"""
type notifications_max_fields {
  communication_template_key: String
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  notification_key: String
  owner_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "notifications"
"""
input notifications_max_order_by {
  communication_template_key: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  notification_key: order_by
  owner_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type notifications_min_fields {
  communication_template_key: String
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  notification_key: String
  owner_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "notifications"
"""
input notifications_min_order_by {
  communication_template_key: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  notification_key: order_by
  owner_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "notifications"
"""
type notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notifications!]!
}

"""
input type for inserting object relation for remote table "notifications"
"""
input notifications_obj_rel_insert_input {
  data: notifications_insert_input!

  """upsert condition"""
  on_conflict: notifications_on_conflict
}

"""
on_conflict condition type for table "notifications"
"""
input notifications_on_conflict {
  constraint: notifications_constraint!
  update_columns: [notifications_update_column!]! = []
  where: notifications_bool_exp
}

"""Ordering options when selecting data from "notifications"."""
input notifications_order_by {
  communication_template: communication_templates_order_by
  communication_template_key: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  metadata: order_by
  notification_key: order_by
  owner: users_order_by
  owner_id: order_by
  updated_at: order_by
  user_notifications_aggregate: user_notifications_aggregate_order_by
}

"""primary key columns input for table: notifications"""
input notifications_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input notifications_prepend_input {
  metadata: jsonb
}

"""
select columns of table "notifications"
"""
enum notifications_select_column {
  """column name"""
  communication_template_key

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  notification_key

  """column name"""
  owner_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "notifications"
"""
input notifications_set_input {
  communication_template_key: String
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  metadata: jsonb
  notification_key: String
  owner_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type notifications_stddev_fields {
  deleted_at: Float
}

"""
order by stddev() on columns of table "notifications"
"""
input notifications_stddev_order_by {
  deleted_at: order_by
}

"""aggregate stddev_pop on columns"""
type notifications_stddev_pop_fields {
  deleted_at: Float
}

"""
order by stddev_pop() on columns of table "notifications"
"""
input notifications_stddev_pop_order_by {
  deleted_at: order_by
}

"""aggregate stddev_samp on columns"""
type notifications_stddev_samp_fields {
  deleted_at: Float
}

"""
order by stddev_samp() on columns of table "notifications"
"""
input notifications_stddev_samp_order_by {
  deleted_at: order_by
}

"""
Streaming cursor of the table "notifications"
"""
input notifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notifications_stream_cursor_value_input {
  communication_template_key: String
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  metadata: jsonb
  notification_key: String
  owner_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type notifications_sum_fields {
  deleted_at: Int
}

"""
order by sum() on columns of table "notifications"
"""
input notifications_sum_order_by {
  deleted_at: order_by
}

"""
update columns of table "notifications"
"""
enum notifications_update_column {
  """column name"""
  communication_template_key

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  notification_key

  """column name"""
  owner_id

  """column name"""
  updated_at
}

input notifications_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: notifications_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: notifications_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: notifications_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: notifications_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: notifications_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: notifications_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: notifications_set_input

  """filter the rows which have to be updated"""
  where: notifications_bool_exp!
}

"""aggregate var_pop on columns"""
type notifications_var_pop_fields {
  deleted_at: Float
}

"""
order by var_pop() on columns of table "notifications"
"""
input notifications_var_pop_order_by {
  deleted_at: order_by
}

"""aggregate var_samp on columns"""
type notifications_var_samp_fields {
  deleted_at: Float
}

"""
order by var_samp() on columns of table "notifications"
"""
input notifications_var_samp_order_by {
  deleted_at: order_by
}

"""aggregate variance on columns"""
type notifications_variance_fields {
  deleted_at: Float
}

"""
order by variance() on columns of table "notifications"
"""
input notifications_variance_order_by {
  deleted_at: order_by
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""Checkout details associated with a user and an offer."""
type offer_checkouts {
  billing_flow_version: Int!
  bounty_discount: Boolean!
  cover_partner_authentication: Boolean!
  created_at: timestamptz!
  deleted_at: Int!
  free_shipping: Boolean
  id: uuid!
  inbound_insurance: Boolean!
  is_trusted_trader: Boolean!

  """An object relationship"""
  offer: offers!
  offer_id: uuid!
  outbound_insurance: Boolean!
  partner_insurance_amount: Int!
  payment_method_id: String!
  payment_method_verified: Boolean

  """An object relationship"""
  payment_transaction: payment_transactions
  seller_fee_free: Boolean
  shipment_location: String

  """An array relationship"""
  shipments(
    """distinct select on columns"""
    distinct_on: [shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipments_order_by!]

    """filter the rows returned"""
    where: shipments_bool_exp
  ): [shipments!]!

  """An aggregate relationship"""
  shipments_aggregate(
    """distinct select on columns"""
    distinct_on: [shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipments_order_by!]

    """filter the rows returned"""
    where: shipments_bool_exp
  ): shipments_aggregate!

  """An object relationship"""
  shippingAddress: addresses!
  shipping_address_id: uuid!
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "offer_checkouts"
"""
type offer_checkouts_aggregate {
  aggregate: offer_checkouts_aggregate_fields
  nodes: [offer_checkouts!]!
}

input offer_checkouts_aggregate_bool_exp {
  bool_and: offer_checkouts_aggregate_bool_exp_bool_and
  bool_or: offer_checkouts_aggregate_bool_exp_bool_or
  count: offer_checkouts_aggregate_bool_exp_count
}

input offer_checkouts_aggregate_bool_exp_bool_and {
  arguments: offer_checkouts_select_column_offer_checkouts_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: offer_checkouts_bool_exp
  predicate: Boolean_comparison_exp!
}

input offer_checkouts_aggregate_bool_exp_bool_or {
  arguments: offer_checkouts_select_column_offer_checkouts_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: offer_checkouts_bool_exp
  predicate: Boolean_comparison_exp!
}

input offer_checkouts_aggregate_bool_exp_count {
  arguments: [offer_checkouts_select_column!]
  distinct: Boolean
  filter: offer_checkouts_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "offer_checkouts"
"""
type offer_checkouts_aggregate_fields {
  avg: offer_checkouts_avg_fields
  count(columns: [offer_checkouts_select_column!], distinct: Boolean): Int!
  max: offer_checkouts_max_fields
  min: offer_checkouts_min_fields
  stddev: offer_checkouts_stddev_fields
  stddev_pop: offer_checkouts_stddev_pop_fields
  stddev_samp: offer_checkouts_stddev_samp_fields
  sum: offer_checkouts_sum_fields
  var_pop: offer_checkouts_var_pop_fields
  var_samp: offer_checkouts_var_samp_fields
  variance: offer_checkouts_variance_fields
}

"""
order by aggregate values of table "offer_checkouts"
"""
input offer_checkouts_aggregate_order_by {
  avg: offer_checkouts_avg_order_by
  count: order_by
  max: offer_checkouts_max_order_by
  min: offer_checkouts_min_order_by
  stddev: offer_checkouts_stddev_order_by
  stddev_pop: offer_checkouts_stddev_pop_order_by
  stddev_samp: offer_checkouts_stddev_samp_order_by
  sum: offer_checkouts_sum_order_by
  var_pop: offer_checkouts_var_pop_order_by
  var_samp: offer_checkouts_var_samp_order_by
  variance: offer_checkouts_variance_order_by
}

"""
input type for inserting array relation for remote table "offer_checkouts"
"""
input offer_checkouts_arr_rel_insert_input {
  data: [offer_checkouts_insert_input!]!

  """upsert condition"""
  on_conflict: offer_checkouts_on_conflict
}

"""aggregate avg on columns"""
type offer_checkouts_avg_fields {
  billing_flow_version: Float
  deleted_at: Float
  partner_insurance_amount: Float
}

"""
order by avg() on columns of table "offer_checkouts"
"""
input offer_checkouts_avg_order_by {
  billing_flow_version: order_by
  deleted_at: order_by
  partner_insurance_amount: order_by
}

"""
Boolean expression to filter rows from the table "offer_checkouts". All fields are combined with a logical 'AND'.
"""
input offer_checkouts_bool_exp {
  _and: [offer_checkouts_bool_exp!]
  _not: offer_checkouts_bool_exp
  _or: [offer_checkouts_bool_exp!]
  billing_flow_version: Int_comparison_exp
  bounty_discount: Boolean_comparison_exp
  cover_partner_authentication: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  free_shipping: Boolean_comparison_exp
  id: uuid_comparison_exp
  inbound_insurance: Boolean_comparison_exp
  is_trusted_trader: Boolean_comparison_exp
  offer: offers_bool_exp
  offer_id: uuid_comparison_exp
  outbound_insurance: Boolean_comparison_exp
  partner_insurance_amount: Int_comparison_exp
  payment_method_id: String_comparison_exp
  payment_method_verified: Boolean_comparison_exp
  payment_transaction: payment_transactions_bool_exp
  seller_fee_free: Boolean_comparison_exp
  shipment_location: String_comparison_exp
  shipments: shipments_bool_exp
  shipments_aggregate: shipments_aggregate_bool_exp
  shippingAddress: addresses_bool_exp
  shipping_address_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "offer_checkouts"
"""
enum offer_checkouts_constraint {
  """
  unique or primary key constraint on columns "user_id", "offer_id"
  """
  offer_checkouts_offer_id_user_id_key

  """
  unique or primary key constraint on columns "id"
  """
  offer_checkouts_pkey
}

"""
input type for incrementing numeric columns in table "offer_checkouts"
"""
input offer_checkouts_inc_input {
  billing_flow_version: Int
  deleted_at: Int
  partner_insurance_amount: Int
}

"""
input type for inserting data into table "offer_checkouts"
"""
input offer_checkouts_insert_input {
  billing_flow_version: Int
  bounty_discount: Boolean
  cover_partner_authentication: Boolean
  created_at: timestamptz
  deleted_at: Int
  free_shipping: Boolean
  id: uuid
  inbound_insurance: Boolean
  is_trusted_trader: Boolean
  offer: offers_obj_rel_insert_input
  offer_id: uuid
  outbound_insurance: Boolean
  partner_insurance_amount: Int
  payment_method_id: String
  payment_method_verified: Boolean
  payment_transaction: payment_transactions_obj_rel_insert_input
  seller_fee_free: Boolean
  shipment_location: String
  shipments: shipments_arr_rel_insert_input
  shippingAddress: addresses_obj_rel_insert_input
  shipping_address_id: uuid
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type offer_checkouts_max_fields {
  billing_flow_version: Int
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  offer_id: uuid
  partner_insurance_amount: Int
  payment_method_id: String
  shipment_location: String
  shipping_address_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "offer_checkouts"
"""
input offer_checkouts_max_order_by {
  billing_flow_version: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  offer_id: order_by
  partner_insurance_amount: order_by
  payment_method_id: order_by
  shipment_location: order_by
  shipping_address_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type offer_checkouts_min_fields {
  billing_flow_version: Int
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  offer_id: uuid
  partner_insurance_amount: Int
  payment_method_id: String
  shipment_location: String
  shipping_address_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "offer_checkouts"
"""
input offer_checkouts_min_order_by {
  billing_flow_version: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  offer_id: order_by
  partner_insurance_amount: order_by
  payment_method_id: order_by
  shipment_location: order_by
  shipping_address_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "offer_checkouts"
"""
type offer_checkouts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [offer_checkouts!]!
}

"""
input type for inserting object relation for remote table "offer_checkouts"
"""
input offer_checkouts_obj_rel_insert_input {
  data: offer_checkouts_insert_input!

  """upsert condition"""
  on_conflict: offer_checkouts_on_conflict
}

"""
on_conflict condition type for table "offer_checkouts"
"""
input offer_checkouts_on_conflict {
  constraint: offer_checkouts_constraint!
  update_columns: [offer_checkouts_update_column!]! = []
  where: offer_checkouts_bool_exp
}

"""Ordering options when selecting data from "offer_checkouts"."""
input offer_checkouts_order_by {
  billing_flow_version: order_by
  bounty_discount: order_by
  cover_partner_authentication: order_by
  created_at: order_by
  deleted_at: order_by
  free_shipping: order_by
  id: order_by
  inbound_insurance: order_by
  is_trusted_trader: order_by
  offer: offers_order_by
  offer_id: order_by
  outbound_insurance: order_by
  partner_insurance_amount: order_by
  payment_method_id: order_by
  payment_method_verified: order_by
  payment_transaction: payment_transactions_order_by
  seller_fee_free: order_by
  shipment_location: order_by
  shipments_aggregate: shipments_aggregate_order_by
  shippingAddress: addresses_order_by
  shipping_address_id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: offer_checkouts"""
input offer_checkouts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "offer_checkouts"
"""
enum offer_checkouts_select_column {
  """column name"""
  billing_flow_version

  """column name"""
  bounty_discount

  """column name"""
  cover_partner_authentication

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  free_shipping

  """column name"""
  id

  """column name"""
  inbound_insurance

  """column name"""
  is_trusted_trader

  """column name"""
  offer_id

  """column name"""
  outbound_insurance

  """column name"""
  partner_insurance_amount

  """column name"""
  payment_method_id

  """column name"""
  payment_method_verified

  """column name"""
  seller_fee_free

  """column name"""
  shipment_location

  """column name"""
  shipping_address_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
select "offer_checkouts_aggregate_bool_exp_bool_and_arguments_columns" columns of table "offer_checkouts"
"""
enum offer_checkouts_select_column_offer_checkouts_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  bounty_discount

  """column name"""
  cover_partner_authentication

  """column name"""
  free_shipping

  """column name"""
  inbound_insurance

  """column name"""
  is_trusted_trader

  """column name"""
  outbound_insurance

  """column name"""
  payment_method_verified

  """column name"""
  seller_fee_free
}

"""
select "offer_checkouts_aggregate_bool_exp_bool_or_arguments_columns" columns of table "offer_checkouts"
"""
enum offer_checkouts_select_column_offer_checkouts_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  bounty_discount

  """column name"""
  cover_partner_authentication

  """column name"""
  free_shipping

  """column name"""
  inbound_insurance

  """column name"""
  is_trusted_trader

  """column name"""
  outbound_insurance

  """column name"""
  payment_method_verified

  """column name"""
  seller_fee_free
}

"""
input type for updating data in table "offer_checkouts"
"""
input offer_checkouts_set_input {
  billing_flow_version: Int
  bounty_discount: Boolean
  cover_partner_authentication: Boolean
  created_at: timestamptz
  deleted_at: Int
  free_shipping: Boolean
  id: uuid
  inbound_insurance: Boolean
  is_trusted_trader: Boolean
  offer_id: uuid
  outbound_insurance: Boolean
  partner_insurance_amount: Int
  payment_method_id: String
  payment_method_verified: Boolean
  seller_fee_free: Boolean
  shipment_location: String
  shipping_address_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type offer_checkouts_stddev_fields {
  billing_flow_version: Float
  deleted_at: Float
  partner_insurance_amount: Float
}

"""
order by stddev() on columns of table "offer_checkouts"
"""
input offer_checkouts_stddev_order_by {
  billing_flow_version: order_by
  deleted_at: order_by
  partner_insurance_amount: order_by
}

"""aggregate stddev_pop on columns"""
type offer_checkouts_stddev_pop_fields {
  billing_flow_version: Float
  deleted_at: Float
  partner_insurance_amount: Float
}

"""
order by stddev_pop() on columns of table "offer_checkouts"
"""
input offer_checkouts_stddev_pop_order_by {
  billing_flow_version: order_by
  deleted_at: order_by
  partner_insurance_amount: order_by
}

"""aggregate stddev_samp on columns"""
type offer_checkouts_stddev_samp_fields {
  billing_flow_version: Float
  deleted_at: Float
  partner_insurance_amount: Float
}

"""
order by stddev_samp() on columns of table "offer_checkouts"
"""
input offer_checkouts_stddev_samp_order_by {
  billing_flow_version: order_by
  deleted_at: order_by
  partner_insurance_amount: order_by
}

"""
Streaming cursor of the table "offer_checkouts"
"""
input offer_checkouts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: offer_checkouts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input offer_checkouts_stream_cursor_value_input {
  billing_flow_version: Int
  bounty_discount: Boolean
  cover_partner_authentication: Boolean
  created_at: timestamptz
  deleted_at: Int
  free_shipping: Boolean
  id: uuid
  inbound_insurance: Boolean
  is_trusted_trader: Boolean
  offer_id: uuid
  outbound_insurance: Boolean
  partner_insurance_amount: Int
  payment_method_id: String
  payment_method_verified: Boolean
  seller_fee_free: Boolean
  shipment_location: String
  shipping_address_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate sum on columns"""
type offer_checkouts_sum_fields {
  billing_flow_version: Int
  deleted_at: Int
  partner_insurance_amount: Int
}

"""
order by sum() on columns of table "offer_checkouts"
"""
input offer_checkouts_sum_order_by {
  billing_flow_version: order_by
  deleted_at: order_by
  partner_insurance_amount: order_by
}

"""
update columns of table "offer_checkouts"
"""
enum offer_checkouts_update_column {
  """column name"""
  billing_flow_version

  """column name"""
  bounty_discount

  """column name"""
  cover_partner_authentication

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  free_shipping

  """column name"""
  id

  """column name"""
  inbound_insurance

  """column name"""
  is_trusted_trader

  """column name"""
  offer_id

  """column name"""
  outbound_insurance

  """column name"""
  partner_insurance_amount

  """column name"""
  payment_method_id

  """column name"""
  payment_method_verified

  """column name"""
  seller_fee_free

  """column name"""
  shipment_location

  """column name"""
  shipping_address_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input offer_checkouts_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: offer_checkouts_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: offer_checkouts_set_input

  """filter the rows which have to be updated"""
  where: offer_checkouts_bool_exp!
}

"""aggregate var_pop on columns"""
type offer_checkouts_var_pop_fields {
  billing_flow_version: Float
  deleted_at: Float
  partner_insurance_amount: Float
}

"""
order by var_pop() on columns of table "offer_checkouts"
"""
input offer_checkouts_var_pop_order_by {
  billing_flow_version: order_by
  deleted_at: order_by
  partner_insurance_amount: order_by
}

"""aggregate var_samp on columns"""
type offer_checkouts_var_samp_fields {
  billing_flow_version: Float
  deleted_at: Float
  partner_insurance_amount: Float
}

"""
order by var_samp() on columns of table "offer_checkouts"
"""
input offer_checkouts_var_samp_order_by {
  billing_flow_version: order_by
  deleted_at: order_by
  partner_insurance_amount: order_by
}

"""aggregate variance on columns"""
type offer_checkouts_variance_fields {
  billing_flow_version: Float
  deleted_at: Float
  partner_insurance_amount: Float
}

"""
order by variance() on columns of table "offer_checkouts"
"""
input offer_checkouts_variance_order_by {
  billing_flow_version: order_by
  deleted_at: order_by
  partner_insurance_amount: order_by
}

"""
columns and relationships of "offer_item_issue_offer_item_issue_types"
"""
type offer_item_issue_offer_item_issue_types {
  issue_id: uuid!
  issue_type: String!
}

"""
aggregated selection of "offer_item_issue_offer_item_issue_types"
"""
type offer_item_issue_offer_item_issue_types_aggregate {
  aggregate: offer_item_issue_offer_item_issue_types_aggregate_fields
  nodes: [offer_item_issue_offer_item_issue_types!]!
}

input offer_item_issue_offer_item_issue_types_aggregate_bool_exp {
  count: offer_item_issue_offer_item_issue_types_aggregate_bool_exp_count
}

input offer_item_issue_offer_item_issue_types_aggregate_bool_exp_count {
  arguments: [offer_item_issue_offer_item_issue_types_select_column!]
  distinct: Boolean
  filter: offer_item_issue_offer_item_issue_types_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "offer_item_issue_offer_item_issue_types"
"""
type offer_item_issue_offer_item_issue_types_aggregate_fields {
  count(columns: [offer_item_issue_offer_item_issue_types_select_column!], distinct: Boolean): Int!
  max: offer_item_issue_offer_item_issue_types_max_fields
  min: offer_item_issue_offer_item_issue_types_min_fields
}

"""
order by aggregate values of table "offer_item_issue_offer_item_issue_types"
"""
input offer_item_issue_offer_item_issue_types_aggregate_order_by {
  count: order_by
  max: offer_item_issue_offer_item_issue_types_max_order_by
  min: offer_item_issue_offer_item_issue_types_min_order_by
}

"""
input type for inserting array relation for remote table "offer_item_issue_offer_item_issue_types"
"""
input offer_item_issue_offer_item_issue_types_arr_rel_insert_input {
  data: [offer_item_issue_offer_item_issue_types_insert_input!]!

  """upsert condition"""
  on_conflict: offer_item_issue_offer_item_issue_types_on_conflict
}

"""
Boolean expression to filter rows from the table "offer_item_issue_offer_item_issue_types". All fields are combined with a logical 'AND'.
"""
input offer_item_issue_offer_item_issue_types_bool_exp {
  _and: [offer_item_issue_offer_item_issue_types_bool_exp!]
  _not: offer_item_issue_offer_item_issue_types_bool_exp
  _or: [offer_item_issue_offer_item_issue_types_bool_exp!]
  issue_id: uuid_comparison_exp
  issue_type: String_comparison_exp
}

"""
unique or primary key constraints on table "offer_item_issue_offer_item_issue_types"
"""
enum offer_item_issue_offer_item_issue_types_constraint {
  """
  unique or primary key constraint on columns "issue_id", "issue_type"
  """
  offer_item_issue_offer_item_issue_types_pkey
}

"""
input type for inserting data into table "offer_item_issue_offer_item_issue_types"
"""
input offer_item_issue_offer_item_issue_types_insert_input {
  issue_id: uuid
  issue_type: String
}

"""aggregate max on columns"""
type offer_item_issue_offer_item_issue_types_max_fields {
  issue_id: uuid
  issue_type: String
}

"""
order by max() on columns of table "offer_item_issue_offer_item_issue_types"
"""
input offer_item_issue_offer_item_issue_types_max_order_by {
  issue_id: order_by
  issue_type: order_by
}

"""aggregate min on columns"""
type offer_item_issue_offer_item_issue_types_min_fields {
  issue_id: uuid
  issue_type: String
}

"""
order by min() on columns of table "offer_item_issue_offer_item_issue_types"
"""
input offer_item_issue_offer_item_issue_types_min_order_by {
  issue_id: order_by
  issue_type: order_by
}

"""
response of any mutation on the table "offer_item_issue_offer_item_issue_types"
"""
type offer_item_issue_offer_item_issue_types_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [offer_item_issue_offer_item_issue_types!]!
}

"""
on_conflict condition type for table "offer_item_issue_offer_item_issue_types"
"""
input offer_item_issue_offer_item_issue_types_on_conflict {
  constraint: offer_item_issue_offer_item_issue_types_constraint!
  update_columns: [offer_item_issue_offer_item_issue_types_update_column!]! = []
  where: offer_item_issue_offer_item_issue_types_bool_exp
}

"""
Ordering options when selecting data from "offer_item_issue_offer_item_issue_types".
"""
input offer_item_issue_offer_item_issue_types_order_by {
  issue_id: order_by
  issue_type: order_by
}

"""
primary key columns input for table: offer_item_issue_offer_item_issue_types
"""
input offer_item_issue_offer_item_issue_types_pk_columns_input {
  issue_id: uuid!
  issue_type: String!
}

"""
select columns of table "offer_item_issue_offer_item_issue_types"
"""
enum offer_item_issue_offer_item_issue_types_select_column {
  """column name"""
  issue_id

  """column name"""
  issue_type
}

"""
input type for updating data in table "offer_item_issue_offer_item_issue_types"
"""
input offer_item_issue_offer_item_issue_types_set_input {
  issue_id: uuid
  issue_type: String
}

"""
Streaming cursor of the table "offer_item_issue_offer_item_issue_types"
"""
input offer_item_issue_offer_item_issue_types_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: offer_item_issue_offer_item_issue_types_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input offer_item_issue_offer_item_issue_types_stream_cursor_value_input {
  issue_id: uuid
  issue_type: String
}

"""
update columns of table "offer_item_issue_offer_item_issue_types"
"""
enum offer_item_issue_offer_item_issue_types_update_column {
  """column name"""
  issue_id

  """column name"""
  issue_type
}

input offer_item_issue_offer_item_issue_types_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: offer_item_issue_offer_item_issue_types_set_input

  """filter the rows which have to be updated"""
  where: offer_item_issue_offer_item_issue_types_bool_exp!
}

"""The owner type of an offer item."""
type offer_item_owners {
  owner: String!
}

"""
aggregated selection of "offer_item_owners"
"""
type offer_item_owners_aggregate {
  aggregate: offer_item_owners_aggregate_fields
  nodes: [offer_item_owners!]!
}

"""
aggregate fields of "offer_item_owners"
"""
type offer_item_owners_aggregate_fields {
  count(columns: [offer_item_owners_select_column!], distinct: Boolean): Int!
  max: offer_item_owners_max_fields
  min: offer_item_owners_min_fields
}

"""
Boolean expression to filter rows from the table "offer_item_owners". All fields are combined with a logical 'AND'.
"""
input offer_item_owners_bool_exp {
  _and: [offer_item_owners_bool_exp!]
  _not: offer_item_owners_bool_exp
  _or: [offer_item_owners_bool_exp!]
  owner: String_comparison_exp
}

"""
unique or primary key constraints on table "offer_item_owners"
"""
enum offer_item_owners_constraint {
  """
  unique or primary key constraint on columns "owner"
  """
  offer_item_owners_pkey
}

enum offer_item_owners_enum {
  CREATOR
  RECEIVER
}

"""
Boolean expression to compare columns of type "offer_item_owners_enum". All fields are combined with logical 'AND'.
"""
input offer_item_owners_enum_comparison_exp {
  _eq: offer_item_owners_enum
  _in: [offer_item_owners_enum!]
  _is_null: Boolean
  _neq: offer_item_owners_enum
  _nin: [offer_item_owners_enum!]
}

"""
input type for inserting data into table "offer_item_owners"
"""
input offer_item_owners_insert_input {
  owner: String
}

"""aggregate max on columns"""
type offer_item_owners_max_fields {
  owner: String
}

"""aggregate min on columns"""
type offer_item_owners_min_fields {
  owner: String
}

"""
response of any mutation on the table "offer_item_owners"
"""
type offer_item_owners_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [offer_item_owners!]!
}

"""
on_conflict condition type for table "offer_item_owners"
"""
input offer_item_owners_on_conflict {
  constraint: offer_item_owners_constraint!
  update_columns: [offer_item_owners_update_column!]! = []
  where: offer_item_owners_bool_exp
}

"""Ordering options when selecting data from "offer_item_owners"."""
input offer_item_owners_order_by {
  owner: order_by
}

"""primary key columns input for table: offer_item_owners"""
input offer_item_owners_pk_columns_input {
  owner: String!
}

"""
select columns of table "offer_item_owners"
"""
enum offer_item_owners_select_column {
  """column name"""
  owner
}

"""
input type for updating data in table "offer_item_owners"
"""
input offer_item_owners_set_input {
  owner: String
}

"""
Streaming cursor of the table "offer_item_owners"
"""
input offer_item_owners_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: offer_item_owners_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input offer_item_owners_stream_cursor_value_input {
  owner: String
}

"""
update columns of table "offer_item_owners"
"""
enum offer_item_owners_update_column {
  """column name"""
  owner
}

input offer_item_owners_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: offer_item_owners_set_input

  """filter the rows which have to be updated"""
  where: offer_item_owners_bool_exp!
}

"""
columns and relationships of "offer_item_shipments"
"""
type offer_item_shipments {
  """An object relationship"""
  offer_item: offer_items!
  offer_item_id: uuid!

  """An object relationship"""
  shipment: shipments!
  shipment_id: uuid!
}

"""
aggregated selection of "offer_item_shipments"
"""
type offer_item_shipments_aggregate {
  aggregate: offer_item_shipments_aggregate_fields
  nodes: [offer_item_shipments!]!
}

input offer_item_shipments_aggregate_bool_exp {
  count: offer_item_shipments_aggregate_bool_exp_count
}

input offer_item_shipments_aggregate_bool_exp_count {
  arguments: [offer_item_shipments_select_column!]
  distinct: Boolean
  filter: offer_item_shipments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "offer_item_shipments"
"""
type offer_item_shipments_aggregate_fields {
  count(columns: [offer_item_shipments_select_column!], distinct: Boolean): Int!
  max: offer_item_shipments_max_fields
  min: offer_item_shipments_min_fields
}

"""
order by aggregate values of table "offer_item_shipments"
"""
input offer_item_shipments_aggregate_order_by {
  count: order_by
  max: offer_item_shipments_max_order_by
  min: offer_item_shipments_min_order_by
}

"""
input type for inserting array relation for remote table "offer_item_shipments"
"""
input offer_item_shipments_arr_rel_insert_input {
  data: [offer_item_shipments_insert_input!]!

  """upsert condition"""
  on_conflict: offer_item_shipments_on_conflict
}

"""
Boolean expression to filter rows from the table "offer_item_shipments". All fields are combined with a logical 'AND'.
"""
input offer_item_shipments_bool_exp {
  _and: [offer_item_shipments_bool_exp!]
  _not: offer_item_shipments_bool_exp
  _or: [offer_item_shipments_bool_exp!]
  offer_item: offer_items_bool_exp
  offer_item_id: uuid_comparison_exp
  shipment: shipments_bool_exp
  shipment_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "offer_item_shipments"
"""
enum offer_item_shipments_constraint {
  """
  unique or primary key constraint on columns "shipment_id", "offer_item_id"
  """
  offer_item_shipments_pkey
}

"""
input type for inserting data into table "offer_item_shipments"
"""
input offer_item_shipments_insert_input {
  offer_item: offer_items_obj_rel_insert_input
  offer_item_id: uuid
  shipment: shipments_obj_rel_insert_input
  shipment_id: uuid
}

"""aggregate max on columns"""
type offer_item_shipments_max_fields {
  offer_item_id: uuid
  shipment_id: uuid
}

"""
order by max() on columns of table "offer_item_shipments"
"""
input offer_item_shipments_max_order_by {
  offer_item_id: order_by
  shipment_id: order_by
}

"""aggregate min on columns"""
type offer_item_shipments_min_fields {
  offer_item_id: uuid
  shipment_id: uuid
}

"""
order by min() on columns of table "offer_item_shipments"
"""
input offer_item_shipments_min_order_by {
  offer_item_id: order_by
  shipment_id: order_by
}

"""
response of any mutation on the table "offer_item_shipments"
"""
type offer_item_shipments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [offer_item_shipments!]!
}

"""
on_conflict condition type for table "offer_item_shipments"
"""
input offer_item_shipments_on_conflict {
  constraint: offer_item_shipments_constraint!
  update_columns: [offer_item_shipments_update_column!]! = []
  where: offer_item_shipments_bool_exp
}

"""Ordering options when selecting data from "offer_item_shipments"."""
input offer_item_shipments_order_by {
  offer_item: offer_items_order_by
  offer_item_id: order_by
  shipment: shipments_order_by
  shipment_id: order_by
}

"""primary key columns input for table: offer_item_shipments"""
input offer_item_shipments_pk_columns_input {
  offer_item_id: uuid!
  shipment_id: uuid!
}

"""
select columns of table "offer_item_shipments"
"""
enum offer_item_shipments_select_column {
  """column name"""
  offer_item_id

  """column name"""
  shipment_id
}

"""
input type for updating data in table "offer_item_shipments"
"""
input offer_item_shipments_set_input {
  offer_item_id: uuid
  shipment_id: uuid
}

"""
Streaming cursor of the table "offer_item_shipments"
"""
input offer_item_shipments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: offer_item_shipments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input offer_item_shipments_stream_cursor_value_input {
  offer_item_id: uuid
  shipment_id: uuid
}

"""
update columns of table "offer_item_shipments"
"""
enum offer_item_shipments_update_column {
  """column name"""
  offer_item_id

  """column name"""
  shipment_id
}

input offer_item_shipments_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: offer_item_shipments_set_input

  """filter the rows which have to be updated"""
  where: offer_item_shipments_bool_exp!
}

"""Items included in an offer, for all sides of the trade."""
type offer_items {
  buyer_fee_free: Boolean
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!

  """An object relationship"""
  inventory_item: inventory_items
  inventory_item_id: uuid

  """An object relationship"""
  offer: offers!
  offer_id: uuid!
  offer_item_owner: offer_item_owners_enum!

  """An array relationship"""
  offer_item_shipments(
    """distinct select on columns"""
    distinct_on: [offer_item_shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_shipments_order_by!]

    """filter the rows returned"""
    where: offer_item_shipments_bool_exp
  ): [offer_item_shipments!]!

  """An aggregate relationship"""
  offer_item_shipments_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_item_shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_shipments_order_by!]

    """filter the rows returned"""
    where: offer_item_shipments_bool_exp
  ): offer_item_shipments_aggregate!
  offer_item_validation_status: String

  """An array relationship"""
  offer_items_issues(
    """distinct select on columns"""
    distinct_on: [offer_items_issues_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_issues_order_by!]

    """filter the rows returned"""
    where: offer_items_issues_bool_exp
  ): [offer_items_issues!]!

  """An aggregate relationship"""
  offer_items_issues_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_items_issues_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_issues_order_by!]

    """filter the rows returned"""
    where: offer_items_issues_bool_exp
  ): offer_items_issues_aggregate!
  pricing_on_trade_confirmation(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  product_variant: product_variants!
  product_variant_id: uuid!
  seller_fee_free: Boolean
  updated_at: timestamptz!
}

"""
aggregated selection of "offer_items"
"""
type offer_items_aggregate {
  aggregate: offer_items_aggregate_fields
  nodes: [offer_items!]!
}

input offer_items_aggregate_bool_exp {
  bool_and: offer_items_aggregate_bool_exp_bool_and
  bool_or: offer_items_aggregate_bool_exp_bool_or
  count: offer_items_aggregate_bool_exp_count
}

input offer_items_aggregate_bool_exp_bool_and {
  arguments: offer_items_select_column_offer_items_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: offer_items_bool_exp
  predicate: Boolean_comparison_exp!
}

input offer_items_aggregate_bool_exp_bool_or {
  arguments: offer_items_select_column_offer_items_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: offer_items_bool_exp
  predicate: Boolean_comparison_exp!
}

input offer_items_aggregate_bool_exp_count {
  arguments: [offer_items_select_column!]
  distinct: Boolean
  filter: offer_items_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "offer_items"
"""
type offer_items_aggregate_fields {
  avg: offer_items_avg_fields
  count(columns: [offer_items_select_column!], distinct: Boolean): Int!
  max: offer_items_max_fields
  min: offer_items_min_fields
  stddev: offer_items_stddev_fields
  stddev_pop: offer_items_stddev_pop_fields
  stddev_samp: offer_items_stddev_samp_fields
  sum: offer_items_sum_fields
  var_pop: offer_items_var_pop_fields
  var_samp: offer_items_var_samp_fields
  variance: offer_items_variance_fields
}

"""
order by aggregate values of table "offer_items"
"""
input offer_items_aggregate_order_by {
  avg: offer_items_avg_order_by
  count: order_by
  max: offer_items_max_order_by
  min: offer_items_min_order_by
  stddev: offer_items_stddev_order_by
  stddev_pop: offer_items_stddev_pop_order_by
  stddev_samp: offer_items_stddev_samp_order_by
  sum: offer_items_sum_order_by
  var_pop: offer_items_var_pop_order_by
  var_samp: offer_items_var_samp_order_by
  variance: offer_items_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input offer_items_append_input {
  pricing_on_trade_confirmation: jsonb
}

"""
input type for inserting array relation for remote table "offer_items"
"""
input offer_items_arr_rel_insert_input {
  data: [offer_items_insert_input!]!

  """upsert condition"""
  on_conflict: offer_items_on_conflict
}

"""aggregate avg on columns"""
type offer_items_avg_fields {
  deleted_at: Float
}

"""
order by avg() on columns of table "offer_items"
"""
input offer_items_avg_order_by {
  deleted_at: order_by
}

"""
Boolean expression to filter rows from the table "offer_items". All fields are combined with a logical 'AND'.
"""
input offer_items_bool_exp {
  _and: [offer_items_bool_exp!]
  _not: offer_items_bool_exp
  _or: [offer_items_bool_exp!]
  buyer_fee_free: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  inventory_item: inventory_items_bool_exp
  inventory_item_id: uuid_comparison_exp
  offer: offers_bool_exp
  offer_id: uuid_comparison_exp
  offer_item_owner: offer_item_owners_enum_comparison_exp
  offer_item_shipments: offer_item_shipments_bool_exp
  offer_item_shipments_aggregate: offer_item_shipments_aggregate_bool_exp
  offer_item_validation_status: String_comparison_exp
  offer_items_issues: offer_items_issues_bool_exp
  offer_items_issues_aggregate: offer_items_issues_aggregate_bool_exp
  pricing_on_trade_confirmation: jsonb_comparison_exp
  product_variant: product_variants_bool_exp
  product_variant_id: uuid_comparison_exp
  seller_fee_free: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "offer_items"
"""
enum offer_items_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  offer_items_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input offer_items_delete_at_path_input {
  pricing_on_trade_confirmation: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input offer_items_delete_elem_input {
  pricing_on_trade_confirmation: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input offer_items_delete_key_input {
  pricing_on_trade_confirmation: String
}

"""
input type for incrementing numeric columns in table "offer_items"
"""
input offer_items_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "offer_items"
"""
input offer_items_insert_input {
  buyer_fee_free: Boolean
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  inventory_item: inventory_items_obj_rel_insert_input
  inventory_item_id: uuid
  offer: offers_obj_rel_insert_input
  offer_id: uuid
  offer_item_owner: offer_item_owners_enum
  offer_item_shipments: offer_item_shipments_arr_rel_insert_input
  offer_item_validation_status: String
  offer_items_issues: offer_items_issues_arr_rel_insert_input
  pricing_on_trade_confirmation: jsonb
  product_variant: product_variants_obj_rel_insert_input
  product_variant_id: uuid
  seller_fee_free: Boolean
  updated_at: timestamptz
}

"""
columns and relationships of "offer_items_issues"
"""
type offer_items_issues {
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!
  note: String
  offer_item_id: uuid!
  offer_item_issue_subject: String!

  """An array relationship"""
  pictures(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  pictures_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """An array relationship"""
  types(
    """distinct select on columns"""
    distinct_on: [offer_item_issue_offer_item_issue_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_issue_offer_item_issue_types_order_by!]

    """filter the rows returned"""
    where: offer_item_issue_offer_item_issue_types_bool_exp
  ): [offer_item_issue_offer_item_issue_types!]!

  """An aggregate relationship"""
  types_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_item_issue_offer_item_issue_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_issue_offer_item_issue_types_order_by!]

    """filter the rows returned"""
    where: offer_item_issue_offer_item_issue_types_bool_exp
  ): offer_item_issue_offer_item_issue_types_aggregate!
  updated_at: timestamptz!
}

"""
aggregated selection of "offer_items_issues"
"""
type offer_items_issues_aggregate {
  aggregate: offer_items_issues_aggregate_fields
  nodes: [offer_items_issues!]!
}

input offer_items_issues_aggregate_bool_exp {
  count: offer_items_issues_aggregate_bool_exp_count
}

input offer_items_issues_aggregate_bool_exp_count {
  arguments: [offer_items_issues_select_column!]
  distinct: Boolean
  filter: offer_items_issues_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "offer_items_issues"
"""
type offer_items_issues_aggregate_fields {
  avg: offer_items_issues_avg_fields
  count(columns: [offer_items_issues_select_column!], distinct: Boolean): Int!
  max: offer_items_issues_max_fields
  min: offer_items_issues_min_fields
  stddev: offer_items_issues_stddev_fields
  stddev_pop: offer_items_issues_stddev_pop_fields
  stddev_samp: offer_items_issues_stddev_samp_fields
  sum: offer_items_issues_sum_fields
  var_pop: offer_items_issues_var_pop_fields
  var_samp: offer_items_issues_var_samp_fields
  variance: offer_items_issues_variance_fields
}

"""
order by aggregate values of table "offer_items_issues"
"""
input offer_items_issues_aggregate_order_by {
  avg: offer_items_issues_avg_order_by
  count: order_by
  max: offer_items_issues_max_order_by
  min: offer_items_issues_min_order_by
  stddev: offer_items_issues_stddev_order_by
  stddev_pop: offer_items_issues_stddev_pop_order_by
  stddev_samp: offer_items_issues_stddev_samp_order_by
  sum: offer_items_issues_sum_order_by
  var_pop: offer_items_issues_var_pop_order_by
  var_samp: offer_items_issues_var_samp_order_by
  variance: offer_items_issues_variance_order_by
}

"""
input type for inserting array relation for remote table "offer_items_issues"
"""
input offer_items_issues_arr_rel_insert_input {
  data: [offer_items_issues_insert_input!]!

  """upsert condition"""
  on_conflict: offer_items_issues_on_conflict
}

"""aggregate avg on columns"""
type offer_items_issues_avg_fields {
  deleted_at: Float
}

"""
order by avg() on columns of table "offer_items_issues"
"""
input offer_items_issues_avg_order_by {
  deleted_at: order_by
}

"""
Boolean expression to filter rows from the table "offer_items_issues". All fields are combined with a logical 'AND'.
"""
input offer_items_issues_bool_exp {
  _and: [offer_items_issues_bool_exp!]
  _not: offer_items_issues_bool_exp
  _or: [offer_items_issues_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  note: String_comparison_exp
  offer_item_id: uuid_comparison_exp
  offer_item_issue_subject: String_comparison_exp
  pictures: files_bool_exp
  pictures_aggregate: files_aggregate_bool_exp
  types: offer_item_issue_offer_item_issue_types_bool_exp
  types_aggregate: offer_item_issue_offer_item_issue_types_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "offer_items_issues"
"""
enum offer_items_issues_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  offer_items_issues_pkey
}

"""
input type for incrementing numeric columns in table "offer_items_issues"
"""
input offer_items_issues_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "offer_items_issues"
"""
input offer_items_issues_insert_input {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  note: String
  offer_item_id: uuid
  offer_item_issue_subject: String
  pictures: files_arr_rel_insert_input
  types: offer_item_issue_offer_item_issue_types_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type offer_items_issues_max_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  note: String
  offer_item_id: uuid
  offer_item_issue_subject: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "offer_items_issues"
"""
input offer_items_issues_max_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  note: order_by
  offer_item_id: order_by
  offer_item_issue_subject: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type offer_items_issues_min_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  note: String
  offer_item_id: uuid
  offer_item_issue_subject: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "offer_items_issues"
"""
input offer_items_issues_min_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  note: order_by
  offer_item_id: order_by
  offer_item_issue_subject: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "offer_items_issues"
"""
type offer_items_issues_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [offer_items_issues!]!
}

"""
on_conflict condition type for table "offer_items_issues"
"""
input offer_items_issues_on_conflict {
  constraint: offer_items_issues_constraint!
  update_columns: [offer_items_issues_update_column!]! = []
  where: offer_items_issues_bool_exp
}

"""Ordering options when selecting data from "offer_items_issues"."""
input offer_items_issues_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  note: order_by
  offer_item_id: order_by
  offer_item_issue_subject: order_by
  pictures_aggregate: files_aggregate_order_by
  types_aggregate: offer_item_issue_offer_item_issue_types_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: offer_items_issues"""
input offer_items_issues_pk_columns_input {
  id: uuid!
}

"""
select columns of table "offer_items_issues"
"""
enum offer_items_issues_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  note

  """column name"""
  offer_item_id

  """column name"""
  offer_item_issue_subject

  """column name"""
  updated_at
}

"""
input type for updating data in table "offer_items_issues"
"""
input offer_items_issues_set_input {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  note: String
  offer_item_id: uuid
  offer_item_issue_subject: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type offer_items_issues_stddev_fields {
  deleted_at: Float
}

"""
order by stddev() on columns of table "offer_items_issues"
"""
input offer_items_issues_stddev_order_by {
  deleted_at: order_by
}

"""aggregate stddev_pop on columns"""
type offer_items_issues_stddev_pop_fields {
  deleted_at: Float
}

"""
order by stddev_pop() on columns of table "offer_items_issues"
"""
input offer_items_issues_stddev_pop_order_by {
  deleted_at: order_by
}

"""aggregate stddev_samp on columns"""
type offer_items_issues_stddev_samp_fields {
  deleted_at: Float
}

"""
order by stddev_samp() on columns of table "offer_items_issues"
"""
input offer_items_issues_stddev_samp_order_by {
  deleted_at: order_by
}

"""
Streaming cursor of the table "offer_items_issues"
"""
input offer_items_issues_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: offer_items_issues_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input offer_items_issues_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  note: String
  offer_item_id: uuid
  offer_item_issue_subject: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type offer_items_issues_sum_fields {
  deleted_at: Int
}

"""
order by sum() on columns of table "offer_items_issues"
"""
input offer_items_issues_sum_order_by {
  deleted_at: order_by
}

"""
update columns of table "offer_items_issues"
"""
enum offer_items_issues_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  note

  """column name"""
  offer_item_id

  """column name"""
  offer_item_issue_subject

  """column name"""
  updated_at
}

input offer_items_issues_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: offer_items_issues_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: offer_items_issues_set_input

  """filter the rows which have to be updated"""
  where: offer_items_issues_bool_exp!
}

"""aggregate var_pop on columns"""
type offer_items_issues_var_pop_fields {
  deleted_at: Float
}

"""
order by var_pop() on columns of table "offer_items_issues"
"""
input offer_items_issues_var_pop_order_by {
  deleted_at: order_by
}

"""aggregate var_samp on columns"""
type offer_items_issues_var_samp_fields {
  deleted_at: Float
}

"""
order by var_samp() on columns of table "offer_items_issues"
"""
input offer_items_issues_var_samp_order_by {
  deleted_at: order_by
}

"""aggregate variance on columns"""
type offer_items_issues_variance_fields {
  deleted_at: Float
}

"""
order by variance() on columns of table "offer_items_issues"
"""
input offer_items_issues_variance_order_by {
  deleted_at: order_by
}

"""aggregate max on columns"""
type offer_items_max_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  inventory_item_id: uuid
  offer_id: uuid
  offer_item_validation_status: String
  product_variant_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "offer_items"
"""
input offer_items_max_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  inventory_item_id: order_by
  offer_id: order_by
  offer_item_validation_status: order_by
  product_variant_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type offer_items_min_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  inventory_item_id: uuid
  offer_id: uuid
  offer_item_validation_status: String
  product_variant_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "offer_items"
"""
input offer_items_min_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  inventory_item_id: order_by
  offer_id: order_by
  offer_item_validation_status: order_by
  product_variant_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "offer_items"
"""
type offer_items_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [offer_items!]!
}

"""
input type for inserting object relation for remote table "offer_items"
"""
input offer_items_obj_rel_insert_input {
  data: offer_items_insert_input!

  """upsert condition"""
  on_conflict: offer_items_on_conflict
}

"""
on_conflict condition type for table "offer_items"
"""
input offer_items_on_conflict {
  constraint: offer_items_constraint!
  update_columns: [offer_items_update_column!]! = []
  where: offer_items_bool_exp
}

"""Ordering options when selecting data from "offer_items"."""
input offer_items_order_by {
  buyer_fee_free: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  inventory_item: inventory_items_order_by
  inventory_item_id: order_by
  offer: offers_order_by
  offer_id: order_by
  offer_item_owner: order_by
  offer_item_shipments_aggregate: offer_item_shipments_aggregate_order_by
  offer_item_validation_status: order_by
  offer_items_issues_aggregate: offer_items_issues_aggregate_order_by
  pricing_on_trade_confirmation: order_by
  product_variant: product_variants_order_by
  product_variant_id: order_by
  seller_fee_free: order_by
  updated_at: order_by
}

"""primary key columns input for table: offer_items"""
input offer_items_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input offer_items_prepend_input {
  pricing_on_trade_confirmation: jsonb
}

"""
select columns of table "offer_items"
"""
enum offer_items_select_column {
  """column name"""
  buyer_fee_free

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  inventory_item_id

  """column name"""
  offer_id

  """column name"""
  offer_item_owner

  """column name"""
  offer_item_validation_status

  """column name"""
  pricing_on_trade_confirmation

  """column name"""
  product_variant_id

  """column name"""
  seller_fee_free

  """column name"""
  updated_at
}

"""
select "offer_items_aggregate_bool_exp_bool_and_arguments_columns" columns of table "offer_items"
"""
enum offer_items_select_column_offer_items_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  buyer_fee_free

  """column name"""
  seller_fee_free
}

"""
select "offer_items_aggregate_bool_exp_bool_or_arguments_columns" columns of table "offer_items"
"""
enum offer_items_select_column_offer_items_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  buyer_fee_free

  """column name"""
  seller_fee_free
}

"""
input type for updating data in table "offer_items"
"""
input offer_items_set_input {
  buyer_fee_free: Boolean
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  inventory_item_id: uuid
  offer_id: uuid
  offer_item_owner: offer_item_owners_enum
  offer_item_validation_status: String
  pricing_on_trade_confirmation: jsonb
  product_variant_id: uuid
  seller_fee_free: Boolean
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type offer_items_stddev_fields {
  deleted_at: Float
}

"""
order by stddev() on columns of table "offer_items"
"""
input offer_items_stddev_order_by {
  deleted_at: order_by
}

"""aggregate stddev_pop on columns"""
type offer_items_stddev_pop_fields {
  deleted_at: Float
}

"""
order by stddev_pop() on columns of table "offer_items"
"""
input offer_items_stddev_pop_order_by {
  deleted_at: order_by
}

"""aggregate stddev_samp on columns"""
type offer_items_stddev_samp_fields {
  deleted_at: Float
}

"""
order by stddev_samp() on columns of table "offer_items"
"""
input offer_items_stddev_samp_order_by {
  deleted_at: order_by
}

"""
Streaming cursor of the table "offer_items"
"""
input offer_items_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: offer_items_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input offer_items_stream_cursor_value_input {
  buyer_fee_free: Boolean
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  inventory_item_id: uuid
  offer_id: uuid
  offer_item_owner: offer_item_owners_enum
  offer_item_validation_status: String
  pricing_on_trade_confirmation: jsonb
  product_variant_id: uuid
  seller_fee_free: Boolean
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type offer_items_sum_fields {
  deleted_at: Int
}

"""
order by sum() on columns of table "offer_items"
"""
input offer_items_sum_order_by {
  deleted_at: order_by
}

"""
update columns of table "offer_items"
"""
enum offer_items_update_column {
  """column name"""
  buyer_fee_free

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  inventory_item_id

  """column name"""
  offer_id

  """column name"""
  offer_item_owner

  """column name"""
  offer_item_validation_status

  """column name"""
  pricing_on_trade_confirmation

  """column name"""
  product_variant_id

  """column name"""
  seller_fee_free

  """column name"""
  updated_at
}

input offer_items_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: offer_items_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: offer_items_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: offer_items_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: offer_items_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: offer_items_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: offer_items_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: offer_items_set_input

  """filter the rows which have to be updated"""
  where: offer_items_bool_exp!
}

"""aggregate var_pop on columns"""
type offer_items_var_pop_fields {
  deleted_at: Float
}

"""
order by var_pop() on columns of table "offer_items"
"""
input offer_items_var_pop_order_by {
  deleted_at: order_by
}

"""aggregate var_samp on columns"""
type offer_items_var_samp_fields {
  deleted_at: Float
}

"""
order by var_samp() on columns of table "offer_items"
"""
input offer_items_var_samp_order_by {
  deleted_at: order_by
}

"""aggregate variance on columns"""
type offer_items_variance_fields {
  deleted_at: Float
}

"""
order by variance() on columns of table "offer_items"
"""
input offer_items_variance_order_by {
  deleted_at: order_by
}

"""All possible statuses of offers."""
type offer_statuses {
  status: String!
}

"""
aggregated selection of "offer_statuses"
"""
type offer_statuses_aggregate {
  aggregate: offer_statuses_aggregate_fields
  nodes: [offer_statuses!]!
}

"""
aggregate fields of "offer_statuses"
"""
type offer_statuses_aggregate_fields {
  count(columns: [offer_statuses_select_column!], distinct: Boolean): Int!
  max: offer_statuses_max_fields
  min: offer_statuses_min_fields
}

"""
Boolean expression to filter rows from the table "offer_statuses". All fields are combined with a logical 'AND'.
"""
input offer_statuses_bool_exp {
  _and: [offer_statuses_bool_exp!]
  _not: offer_statuses_bool_exp
  _or: [offer_statuses_bool_exp!]
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "offer_statuses"
"""
enum offer_statuses_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  offer_statuses_pkey
}

enum offer_statuses_enum {
  COMPLETED
  COUNTERED
  DECLINED
  DRAFT
  EXPIRED
  FAILED
  IN_PROGRESS
  ON_HOLD
  OPEN
  PAUSED
  RESCINDED
}

"""
Boolean expression to compare columns of type "offer_statuses_enum". All fields are combined with logical 'AND'.
"""
input offer_statuses_enum_comparison_exp {
  _eq: offer_statuses_enum
  _in: [offer_statuses_enum!]
  _is_null: Boolean
  _neq: offer_statuses_enum
  _nin: [offer_statuses_enum!]
}

"""
input type for inserting data into table "offer_statuses"
"""
input offer_statuses_insert_input {
  status: String
}

"""aggregate max on columns"""
type offer_statuses_max_fields {
  status: String
}

"""aggregate min on columns"""
type offer_statuses_min_fields {
  status: String
}

"""
response of any mutation on the table "offer_statuses"
"""
type offer_statuses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [offer_statuses!]!
}

"""
on_conflict condition type for table "offer_statuses"
"""
input offer_statuses_on_conflict {
  constraint: offer_statuses_constraint!
  update_columns: [offer_statuses_update_column!]! = []
  where: offer_statuses_bool_exp
}

"""Ordering options when selecting data from "offer_statuses"."""
input offer_statuses_order_by {
  status: order_by
}

"""primary key columns input for table: offer_statuses"""
input offer_statuses_pk_columns_input {
  status: String!
}

"""
select columns of table "offer_statuses"
"""
enum offer_statuses_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "offer_statuses"
"""
input offer_statuses_set_input {
  status: String
}

"""
Streaming cursor of the table "offer_statuses"
"""
input offer_statuses_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: offer_statuses_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input offer_statuses_stream_cursor_value_input {
  status: String
}

"""
update columns of table "offer_statuses"
"""
enum offer_statuses_update_column {
  """column name"""
  status
}

input offer_statuses_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: offer_statuses_set_input

  """filter the rows which have to be updated"""
  where: offer_statuses_bool_exp!
}

"""
columns and relationships of "offer_transaction_types"
"""
type offer_transaction_types {
  transaction_type: String!
}

"""
aggregated selection of "offer_transaction_types"
"""
type offer_transaction_types_aggregate {
  aggregate: offer_transaction_types_aggregate_fields
  nodes: [offer_transaction_types!]!
}

"""
aggregate fields of "offer_transaction_types"
"""
type offer_transaction_types_aggregate_fields {
  count(columns: [offer_transaction_types_select_column!], distinct: Boolean): Int!
  max: offer_transaction_types_max_fields
  min: offer_transaction_types_min_fields
}

"""
Boolean expression to filter rows from the table "offer_transaction_types". All fields are combined with a logical 'AND'.
"""
input offer_transaction_types_bool_exp {
  _and: [offer_transaction_types_bool_exp!]
  _not: offer_transaction_types_bool_exp
  _or: [offer_transaction_types_bool_exp!]
  transaction_type: String_comparison_exp
}

"""
unique or primary key constraints on table "offer_transaction_types"
"""
enum offer_transaction_types_constraint {
  """
  unique or primary key constraint on columns "transaction_type"
  """
  offer_transaction_types_pkey
}

enum offer_transaction_types_enum {
  BUY
  EXCHANGE
  SELL
}

"""
Boolean expression to compare columns of type "offer_transaction_types_enum". All fields are combined with logical 'AND'.
"""
input offer_transaction_types_enum_comparison_exp {
  _eq: offer_transaction_types_enum
  _in: [offer_transaction_types_enum!]
  _is_null: Boolean
  _neq: offer_transaction_types_enum
  _nin: [offer_transaction_types_enum!]
}

"""
input type for inserting data into table "offer_transaction_types"
"""
input offer_transaction_types_insert_input {
  transaction_type: String
}

"""aggregate max on columns"""
type offer_transaction_types_max_fields {
  transaction_type: String
}

"""aggregate min on columns"""
type offer_transaction_types_min_fields {
  transaction_type: String
}

"""
response of any mutation on the table "offer_transaction_types"
"""
type offer_transaction_types_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [offer_transaction_types!]!
}

"""
on_conflict condition type for table "offer_transaction_types"
"""
input offer_transaction_types_on_conflict {
  constraint: offer_transaction_types_constraint!
  update_columns: [offer_transaction_types_update_column!]! = []
  where: offer_transaction_types_bool_exp
}

"""Ordering options when selecting data from "offer_transaction_types"."""
input offer_transaction_types_order_by {
  transaction_type: order_by
}

"""primary key columns input for table: offer_transaction_types"""
input offer_transaction_types_pk_columns_input {
  transaction_type: String!
}

"""
select columns of table "offer_transaction_types"
"""
enum offer_transaction_types_select_column {
  """column name"""
  transaction_type
}

"""
input type for updating data in table "offer_transaction_types"
"""
input offer_transaction_types_set_input {
  transaction_type: String
}

"""
Streaming cursor of the table "offer_transaction_types"
"""
input offer_transaction_types_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: offer_transaction_types_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input offer_transaction_types_stream_cursor_value_input {
  transaction_type: String
}

"""
update columns of table "offer_transaction_types"
"""
enum offer_transaction_types_update_column {
  """column name"""
  transaction_type
}

input offer_transaction_types_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: offer_transaction_types_set_input

  """filter the rows which have to be updated"""
  where: offer_transaction_types_bool_exp!
}

"""All possible types of offers."""
type offer_types {
  type: String!
}

"""
aggregated selection of "offer_types"
"""
type offer_types_aggregate {
  aggregate: offer_types_aggregate_fields
  nodes: [offer_types!]!
}

"""
aggregate fields of "offer_types"
"""
type offer_types_aggregate_fields {
  count(columns: [offer_types_select_column!], distinct: Boolean): Int!
  max: offer_types_max_fields
  min: offer_types_min_fields
}

"""
Boolean expression to filter rows from the table "offer_types". All fields are combined with a logical 'AND'.
"""
input offer_types_bool_exp {
  _and: [offer_types_bool_exp!]
  _not: offer_types_bool_exp
  _or: [offer_types_bool_exp!]
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "offer_types"
"""
enum offer_types_constraint {
  """
  unique or primary key constraint on columns "type"
  """
  offer_types_pkey
}

enum offer_types_enum {
  PRIVATE
  PUBLIC
}

"""
Boolean expression to compare columns of type "offer_types_enum". All fields are combined with logical 'AND'.
"""
input offer_types_enum_comparison_exp {
  _eq: offer_types_enum
  _in: [offer_types_enum!]
  _is_null: Boolean
  _neq: offer_types_enum
  _nin: [offer_types_enum!]
}

"""
input type for inserting data into table "offer_types"
"""
input offer_types_insert_input {
  type: String
}

"""aggregate max on columns"""
type offer_types_max_fields {
  type: String
}

"""aggregate min on columns"""
type offer_types_min_fields {
  type: String
}

"""
response of any mutation on the table "offer_types"
"""
type offer_types_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [offer_types!]!
}

"""
on_conflict condition type for table "offer_types"
"""
input offer_types_on_conflict {
  constraint: offer_types_constraint!
  update_columns: [offer_types_update_column!]! = []
  where: offer_types_bool_exp
}

"""Ordering options when selecting data from "offer_types"."""
input offer_types_order_by {
  type: order_by
}

"""primary key columns input for table: offer_types"""
input offer_types_pk_columns_input {
  type: String!
}

"""
select columns of table "offer_types"
"""
enum offer_types_select_column {
  """column name"""
  type
}

"""
input type for updating data in table "offer_types"
"""
input offer_types_set_input {
  type: String
}

"""
Streaming cursor of the table "offer_types"
"""
input offer_types_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: offer_types_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input offer_types_stream_cursor_value_input {
  type: String
}

"""
update columns of table "offer_types"
"""
enum offer_types_update_column {
  """column name"""
  type
}

input offer_types_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: offer_types_set_input

  """filter the rows which have to be updated"""
  where: offer_types_bool_exp!
}

"""All offers of all types."""
type offers {
  cash: numeric!
  confirmed_trade_date: timestamptz
  created_at: timestamptz!

  """An object relationship"""
  creator: users!
  creator_items_value: numeric
  creator_user_id: uuid!
  deleted_at: Int!
  expiration_date: timestamptz
  id: uuid!
  is_offer_idea: Boolean!
  key: String

  """An array relationship"""
  offer_checkouts(
    """distinct select on columns"""
    distinct_on: [offer_checkouts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_checkouts_order_by!]

    """filter the rows returned"""
    where: offer_checkouts_bool_exp
  ): [offer_checkouts!]!

  """An aggregate relationship"""
  offer_checkouts_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_checkouts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_checkouts_order_by!]

    """filter the rows returned"""
    where: offer_checkouts_bool_exp
  ): offer_checkouts_aggregate!
  offer_currency: currencies_enum!

  """An array relationship"""
  offer_items(
    """distinct select on columns"""
    distinct_on: [offer_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_order_by!]

    """filter the rows returned"""
    where: offer_items_bool_exp
  ): [offer_items!]!

  """An aggregate relationship"""
  offer_items_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_order_by!]

    """filter the rows returned"""
    where: offer_items_bool_exp
  ): offer_items_aggregate!
  offer_pause_reason: String
  offer_status: offer_statuses_enum!
  offer_transaction_type: offer_transaction_types_enum!
  offer_type: offer_types_enum!
  original_offer_id: uuid

  """An object relationship"""
  receiver: users
  receiver_items_value: numeric
  receiver_user_id: uuid
  trade_value_difference: numeric
  trade_value_percentage: numeric

  """An object relationship"""
  trades: trades
  update_index: Boolean!
  updated_at: timestamptz!
}

"""
aggregated selection of "offers"
"""
type offers_aggregate {
  aggregate: offers_aggregate_fields
  nodes: [offers!]!
}

"""
aggregate fields of "offers"
"""
type offers_aggregate_fields {
  avg: offers_avg_fields
  count(columns: [offers_select_column!], distinct: Boolean): Int!
  max: offers_max_fields
  min: offers_min_fields
  stddev: offers_stddev_fields
  stddev_pop: offers_stddev_pop_fields
  stddev_samp: offers_stddev_samp_fields
  sum: offers_sum_fields
  var_pop: offers_var_pop_fields
  var_samp: offers_var_samp_fields
  variance: offers_variance_fields
}

"""aggregate avg on columns"""
type offers_avg_fields {
  cash: Float
  creator_items_value: Float
  deleted_at: Float
  receiver_items_value: Float
  trade_value_difference: Float
  trade_value_percentage: Float
}

"""
Boolean expression to filter rows from the table "offers". All fields are combined with a logical 'AND'.
"""
input offers_bool_exp {
  _and: [offers_bool_exp!]
  _not: offers_bool_exp
  _or: [offers_bool_exp!]
  cash: numeric_comparison_exp
  confirmed_trade_date: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  creator: users_bool_exp
  creator_items_value: numeric_comparison_exp
  creator_user_id: uuid_comparison_exp
  deleted_at: Int_comparison_exp
  expiration_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_offer_idea: Boolean_comparison_exp
  key: String_comparison_exp
  offer_checkouts: offer_checkouts_bool_exp
  offer_checkouts_aggregate: offer_checkouts_aggregate_bool_exp
  offer_currency: currencies_enum_comparison_exp
  offer_items: offer_items_bool_exp
  offer_items_aggregate: offer_items_aggregate_bool_exp
  offer_pause_reason: String_comparison_exp
  offer_status: offer_statuses_enum_comparison_exp
  offer_transaction_type: offer_transaction_types_enum_comparison_exp
  offer_type: offer_types_enum_comparison_exp
  original_offer_id: uuid_comparison_exp
  receiver: users_bool_exp
  receiver_items_value: numeric_comparison_exp
  receiver_user_id: uuid_comparison_exp
  trade_value_difference: numeric_comparison_exp
  trade_value_percentage: numeric_comparison_exp
  trades: trades_bool_exp
  update_index: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "offers"
"""
enum offers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  offers_pkey
}

"""
input type for incrementing numeric columns in table "offers"
"""
input offers_inc_input {
  cash: numeric
  creator_items_value: numeric
  deleted_at: Int
  receiver_items_value: numeric
  trade_value_difference: numeric
  trade_value_percentage: numeric
}

"""
input type for inserting data into table "offers"
"""
input offers_insert_input {
  cash: numeric
  confirmed_trade_date: timestamptz
  created_at: timestamptz
  creator: users_obj_rel_insert_input
  creator_items_value: numeric
  creator_user_id: uuid
  deleted_at: Int
  expiration_date: timestamptz
  id: uuid
  is_offer_idea: Boolean
  key: String
  offer_checkouts: offer_checkouts_arr_rel_insert_input
  offer_currency: currencies_enum
  offer_items: offer_items_arr_rel_insert_input
  offer_pause_reason: String
  offer_status: offer_statuses_enum
  offer_transaction_type: offer_transaction_types_enum
  offer_type: offer_types_enum
  original_offer_id: uuid
  receiver: users_obj_rel_insert_input
  receiver_items_value: numeric
  receiver_user_id: uuid
  trade_value_difference: numeric
  trade_value_percentage: numeric
  trades: trades_obj_rel_insert_input
  update_index: Boolean
  updated_at: timestamptz
}

"""aggregate max on columns"""
type offers_max_fields {
  cash: numeric
  confirmed_trade_date: timestamptz
  created_at: timestamptz
  creator_items_value: numeric
  creator_user_id: uuid
  deleted_at: Int
  expiration_date: timestamptz
  id: uuid
  key: String
  offer_pause_reason: String
  original_offer_id: uuid
  receiver_items_value: numeric
  receiver_user_id: uuid
  trade_value_difference: numeric
  trade_value_percentage: numeric
  updated_at: timestamptz
}

"""aggregate min on columns"""
type offers_min_fields {
  cash: numeric
  confirmed_trade_date: timestamptz
  created_at: timestamptz
  creator_items_value: numeric
  creator_user_id: uuid
  deleted_at: Int
  expiration_date: timestamptz
  id: uuid
  key: String
  offer_pause_reason: String
  original_offer_id: uuid
  receiver_items_value: numeric
  receiver_user_id: uuid
  trade_value_difference: numeric
  trade_value_percentage: numeric
  updated_at: timestamptz
}

"""
response of any mutation on the table "offers"
"""
type offers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [offers!]!
}

"""
input type for inserting object relation for remote table "offers"
"""
input offers_obj_rel_insert_input {
  data: offers_insert_input!

  """upsert condition"""
  on_conflict: offers_on_conflict
}

"""
on_conflict condition type for table "offers"
"""
input offers_on_conflict {
  constraint: offers_constraint!
  update_columns: [offers_update_column!]! = []
  where: offers_bool_exp
}

"""Ordering options when selecting data from "offers"."""
input offers_order_by {
  cash: order_by
  confirmed_trade_date: order_by
  created_at: order_by
  creator: users_order_by
  creator_items_value: order_by
  creator_user_id: order_by
  deleted_at: order_by
  expiration_date: order_by
  id: order_by
  is_offer_idea: order_by
  key: order_by
  offer_checkouts_aggregate: offer_checkouts_aggregate_order_by
  offer_currency: order_by
  offer_items_aggregate: offer_items_aggregate_order_by
  offer_pause_reason: order_by
  offer_status: order_by
  offer_transaction_type: order_by
  offer_type: order_by
  original_offer_id: order_by
  receiver: users_order_by
  receiver_items_value: order_by
  receiver_user_id: order_by
  trade_value_difference: order_by
  trade_value_percentage: order_by
  trades: trades_order_by
  update_index: order_by
  updated_at: order_by
}

"""primary key columns input for table: offers"""
input offers_pk_columns_input {
  id: uuid!
}

"""
select columns of table "offers"
"""
enum offers_select_column {
  """column name"""
  cash

  """column name"""
  confirmed_trade_date

  """column name"""
  created_at

  """column name"""
  creator_items_value

  """column name"""
  creator_user_id

  """column name"""
  deleted_at

  """column name"""
  expiration_date

  """column name"""
  id

  """column name"""
  is_offer_idea

  """column name"""
  key

  """column name"""
  offer_currency

  """column name"""
  offer_pause_reason

  """column name"""
  offer_status

  """column name"""
  offer_transaction_type

  """column name"""
  offer_type

  """column name"""
  original_offer_id

  """column name"""
  receiver_items_value

  """column name"""
  receiver_user_id

  """column name"""
  trade_value_difference

  """column name"""
  trade_value_percentage

  """column name"""
  update_index

  """column name"""
  updated_at
}

"""
input type for updating data in table "offers"
"""
input offers_set_input {
  cash: numeric
  confirmed_trade_date: timestamptz
  created_at: timestamptz
  creator_items_value: numeric
  creator_user_id: uuid
  deleted_at: Int
  expiration_date: timestamptz
  id: uuid
  is_offer_idea: Boolean
  key: String
  offer_currency: currencies_enum
  offer_pause_reason: String
  offer_status: offer_statuses_enum
  offer_transaction_type: offer_transaction_types_enum
  offer_type: offer_types_enum
  original_offer_id: uuid
  receiver_items_value: numeric
  receiver_user_id: uuid
  trade_value_difference: numeric
  trade_value_percentage: numeric
  update_index: Boolean
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type offers_stddev_fields {
  cash: Float
  creator_items_value: Float
  deleted_at: Float
  receiver_items_value: Float
  trade_value_difference: Float
  trade_value_percentage: Float
}

"""aggregate stddev_pop on columns"""
type offers_stddev_pop_fields {
  cash: Float
  creator_items_value: Float
  deleted_at: Float
  receiver_items_value: Float
  trade_value_difference: Float
  trade_value_percentage: Float
}

"""aggregate stddev_samp on columns"""
type offers_stddev_samp_fields {
  cash: Float
  creator_items_value: Float
  deleted_at: Float
  receiver_items_value: Float
  trade_value_difference: Float
  trade_value_percentage: Float
}

"""
Streaming cursor of the table "offers"
"""
input offers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: offers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input offers_stream_cursor_value_input {
  cash: numeric
  confirmed_trade_date: timestamptz
  created_at: timestamptz
  creator_items_value: numeric
  creator_user_id: uuid
  deleted_at: Int
  expiration_date: timestamptz
  id: uuid
  is_offer_idea: Boolean
  key: String
  offer_currency: currencies_enum
  offer_pause_reason: String
  offer_status: offer_statuses_enum
  offer_transaction_type: offer_transaction_types_enum
  offer_type: offer_types_enum
  original_offer_id: uuid
  receiver_items_value: numeric
  receiver_user_id: uuid
  trade_value_difference: numeric
  trade_value_percentage: numeric
  update_index: Boolean
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type offers_sum_fields {
  cash: numeric
  creator_items_value: numeric
  deleted_at: Int
  receiver_items_value: numeric
  trade_value_difference: numeric
  trade_value_percentage: numeric
}

"""
update columns of table "offers"
"""
enum offers_update_column {
  """column name"""
  cash

  """column name"""
  confirmed_trade_date

  """column name"""
  created_at

  """column name"""
  creator_items_value

  """column name"""
  creator_user_id

  """column name"""
  deleted_at

  """column name"""
  expiration_date

  """column name"""
  id

  """column name"""
  is_offer_idea

  """column name"""
  key

  """column name"""
  offer_currency

  """column name"""
  offer_pause_reason

  """column name"""
  offer_status

  """column name"""
  offer_transaction_type

  """column name"""
  offer_type

  """column name"""
  original_offer_id

  """column name"""
  receiver_items_value

  """column name"""
  receiver_user_id

  """column name"""
  trade_value_difference

  """column name"""
  trade_value_percentage

  """column name"""
  update_index

  """column name"""
  updated_at
}

input offers_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: offers_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: offers_set_input

  """filter the rows which have to be updated"""
  where: offers_bool_exp!
}

"""aggregate var_pop on columns"""
type offers_var_pop_fields {
  cash: Float
  creator_items_value: Float
  deleted_at: Float
  receiver_items_value: Float
  trade_value_difference: Float
  trade_value_percentage: Float
}

"""aggregate var_samp on columns"""
type offers_var_samp_fields {
  cash: Float
  creator_items_value: Float
  deleted_at: Float
  receiver_items_value: Float
  trade_value_difference: Float
  trade_value_percentage: Float
}

"""aggregate variance on columns"""
type offers_variance_fields {
  cash: Float
  creator_items_value: Float
  deleted_at: Float
  receiver_items_value: Float
  trade_value_difference: Float
  trade_value_percentage: Float
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "payment_transactions"
"""
type payment_transactions {
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!
  invoice_id: String!
  offer_checkout_id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "payment_transactions"
"""
type payment_transactions_aggregate {
  aggregate: payment_transactions_aggregate_fields
  nodes: [payment_transactions!]!
}

"""
aggregate fields of "payment_transactions"
"""
type payment_transactions_aggregate_fields {
  avg: payment_transactions_avg_fields
  count(columns: [payment_transactions_select_column!], distinct: Boolean): Int!
  max: payment_transactions_max_fields
  min: payment_transactions_min_fields
  stddev: payment_transactions_stddev_fields
  stddev_pop: payment_transactions_stddev_pop_fields
  stddev_samp: payment_transactions_stddev_samp_fields
  sum: payment_transactions_sum_fields
  var_pop: payment_transactions_var_pop_fields
  var_samp: payment_transactions_var_samp_fields
  variance: payment_transactions_variance_fields
}

"""aggregate avg on columns"""
type payment_transactions_avg_fields {
  deleted_at: Float
}

"""
Boolean expression to filter rows from the table "payment_transactions". All fields are combined with a logical 'AND'.
"""
input payment_transactions_bool_exp {
  _and: [payment_transactions_bool_exp!]
  _not: payment_transactions_bool_exp
  _or: [payment_transactions_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  invoice_id: String_comparison_exp
  offer_checkout_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payment_transactions"
"""
enum payment_transactions_constraint {
  """
  unique or primary key constraint on columns "offer_checkout_id"
  """
  payment_transactions_offer_checkout_id_key

  """
  unique or primary key constraint on columns "id"
  """
  payment_transactions_pkey
}

"""
input type for incrementing numeric columns in table "payment_transactions"
"""
input payment_transactions_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "payment_transactions"
"""
input payment_transactions_insert_input {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  invoice_id: String
  offer_checkout_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type payment_transactions_max_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  invoice_id: String
  offer_checkout_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type payment_transactions_min_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  invoice_id: String
  offer_checkout_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "payment_transactions"
"""
type payment_transactions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_transactions!]!
}

"""
input type for inserting object relation for remote table "payment_transactions"
"""
input payment_transactions_obj_rel_insert_input {
  data: payment_transactions_insert_input!

  """upsert condition"""
  on_conflict: payment_transactions_on_conflict
}

"""
on_conflict condition type for table "payment_transactions"
"""
input payment_transactions_on_conflict {
  constraint: payment_transactions_constraint!
  update_columns: [payment_transactions_update_column!]! = []
  where: payment_transactions_bool_exp
}

"""Ordering options when selecting data from "payment_transactions"."""
input payment_transactions_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  invoice_id: order_by
  offer_checkout_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: payment_transactions"""
input payment_transactions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payment_transactions"
"""
enum payment_transactions_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  invoice_id

  """column name"""
  offer_checkout_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "payment_transactions"
"""
input payment_transactions_set_input {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  invoice_id: String
  offer_checkout_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type payment_transactions_stddev_fields {
  deleted_at: Float
}

"""aggregate stddev_pop on columns"""
type payment_transactions_stddev_pop_fields {
  deleted_at: Float
}

"""aggregate stddev_samp on columns"""
type payment_transactions_stddev_samp_fields {
  deleted_at: Float
}

"""
Streaming cursor of the table "payment_transactions"
"""
input payment_transactions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payment_transactions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payment_transactions_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  invoice_id: String
  offer_checkout_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type payment_transactions_sum_fields {
  deleted_at: Int
}

"""
update columns of table "payment_transactions"
"""
enum payment_transactions_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  invoice_id

  """column name"""
  offer_checkout_id

  """column name"""
  updated_at
}

input payment_transactions_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payment_transactions_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payment_transactions_set_input

  """filter the rows which have to be updated"""
  where: payment_transactions_bool_exp!
}

"""aggregate var_pop on columns"""
type payment_transactions_var_pop_fields {
  deleted_at: Float
}

"""aggregate var_samp on columns"""
type payment_transactions_var_samp_fields {
  deleted_at: Float
}

"""aggregate variance on columns"""
type payment_transactions_variance_fields {
  deleted_at: Float
}

"""
columns and relationships of "price_report"
"""
type price_report {
  created_at: timestamptz!
  data_point: String!
  deleted_at: Int!
  id: uuid!
  price: numeric!
  source: String!
  updated_at: timestamptz!
  user_id: uuid!
  variant_id: uuid!
}

"""
aggregated selection of "price_report"
"""
type price_report_aggregate {
  aggregate: price_report_aggregate_fields
  nodes: [price_report!]!
}

input price_report_aggregate_bool_exp {
  count: price_report_aggregate_bool_exp_count
}

input price_report_aggregate_bool_exp_count {
  arguments: [price_report_select_column!]
  distinct: Boolean
  filter: price_report_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "price_report"
"""
type price_report_aggregate_fields {
  avg: price_report_avg_fields
  count(columns: [price_report_select_column!], distinct: Boolean): Int!
  max: price_report_max_fields
  min: price_report_min_fields
  stddev: price_report_stddev_fields
  stddev_pop: price_report_stddev_pop_fields
  stddev_samp: price_report_stddev_samp_fields
  sum: price_report_sum_fields
  var_pop: price_report_var_pop_fields
  var_samp: price_report_var_samp_fields
  variance: price_report_variance_fields
}

"""
order by aggregate values of table "price_report"
"""
input price_report_aggregate_order_by {
  avg: price_report_avg_order_by
  count: order_by
  max: price_report_max_order_by
  min: price_report_min_order_by
  stddev: price_report_stddev_order_by
  stddev_pop: price_report_stddev_pop_order_by
  stddev_samp: price_report_stddev_samp_order_by
  sum: price_report_sum_order_by
  var_pop: price_report_var_pop_order_by
  var_samp: price_report_var_samp_order_by
  variance: price_report_variance_order_by
}

"""
input type for inserting array relation for remote table "price_report"
"""
input price_report_arr_rel_insert_input {
  data: [price_report_insert_input!]!

  """upsert condition"""
  on_conflict: price_report_on_conflict
}

"""aggregate avg on columns"""
type price_report_avg_fields {
  deleted_at: Float
  price: Float
}

"""
order by avg() on columns of table "price_report"
"""
input price_report_avg_order_by {
  deleted_at: order_by
  price: order_by
}

"""
Boolean expression to filter rows from the table "price_report". All fields are combined with a logical 'AND'.
"""
input price_report_bool_exp {
  _and: [price_report_bool_exp!]
  _not: price_report_bool_exp
  _or: [price_report_bool_exp!]
  created_at: timestamptz_comparison_exp
  data_point: String_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  price: numeric_comparison_exp
  source: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
  variant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "price_report"
"""
enum price_report_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  price_report_pkey

  """
  unique or primary key constraint on columns "user_id", "variant_id"
  """
  price_report_user_id_variant_id_key
}

"""
input type for incrementing numeric columns in table "price_report"
"""
input price_report_inc_input {
  deleted_at: Int
  price: numeric
}

"""
input type for inserting data into table "price_report"
"""
input price_report_insert_input {
  created_at: timestamptz
  data_point: String
  deleted_at: Int
  id: uuid
  price: numeric
  source: String
  updated_at: timestamptz
  user_id: uuid
  variant_id: uuid
}

"""aggregate max on columns"""
type price_report_max_fields {
  created_at: timestamptz
  data_point: String
  deleted_at: Int
  id: uuid
  price: numeric
  source: String
  updated_at: timestamptz
  user_id: uuid
  variant_id: uuid
}

"""
order by max() on columns of table "price_report"
"""
input price_report_max_order_by {
  created_at: order_by
  data_point: order_by
  deleted_at: order_by
  id: order_by
  price: order_by
  source: order_by
  updated_at: order_by
  user_id: order_by
  variant_id: order_by
}

"""aggregate min on columns"""
type price_report_min_fields {
  created_at: timestamptz
  data_point: String
  deleted_at: Int
  id: uuid
  price: numeric
  source: String
  updated_at: timestamptz
  user_id: uuid
  variant_id: uuid
}

"""
order by min() on columns of table "price_report"
"""
input price_report_min_order_by {
  created_at: order_by
  data_point: order_by
  deleted_at: order_by
  id: order_by
  price: order_by
  source: order_by
  updated_at: order_by
  user_id: order_by
  variant_id: order_by
}

"""
response of any mutation on the table "price_report"
"""
type price_report_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [price_report!]!
}

"""
on_conflict condition type for table "price_report"
"""
input price_report_on_conflict {
  constraint: price_report_constraint!
  update_columns: [price_report_update_column!]! = []
  where: price_report_bool_exp
}

"""Ordering options when selecting data from "price_report"."""
input price_report_order_by {
  created_at: order_by
  data_point: order_by
  deleted_at: order_by
  id: order_by
  price: order_by
  source: order_by
  updated_at: order_by
  user_id: order_by
  variant_id: order_by
}

"""primary key columns input for table: price_report"""
input price_report_pk_columns_input {
  id: uuid!
}

"""
select columns of table "price_report"
"""
enum price_report_select_column {
  """column name"""
  created_at

  """column name"""
  data_point

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  price

  """column name"""
  source

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  variant_id
}

"""
input type for updating data in table "price_report"
"""
input price_report_set_input {
  created_at: timestamptz
  data_point: String
  deleted_at: Int
  id: uuid
  price: numeric
  source: String
  updated_at: timestamptz
  user_id: uuid
  variant_id: uuid
}

"""aggregate stddev on columns"""
type price_report_stddev_fields {
  deleted_at: Float
  price: Float
}

"""
order by stddev() on columns of table "price_report"
"""
input price_report_stddev_order_by {
  deleted_at: order_by
  price: order_by
}

"""aggregate stddev_pop on columns"""
type price_report_stddev_pop_fields {
  deleted_at: Float
  price: Float
}

"""
order by stddev_pop() on columns of table "price_report"
"""
input price_report_stddev_pop_order_by {
  deleted_at: order_by
  price: order_by
}

"""aggregate stddev_samp on columns"""
type price_report_stddev_samp_fields {
  deleted_at: Float
  price: Float
}

"""
order by stddev_samp() on columns of table "price_report"
"""
input price_report_stddev_samp_order_by {
  deleted_at: order_by
  price: order_by
}

"""
Streaming cursor of the table "price_report"
"""
input price_report_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: price_report_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input price_report_stream_cursor_value_input {
  created_at: timestamptz
  data_point: String
  deleted_at: Int
  id: uuid
  price: numeric
  source: String
  updated_at: timestamptz
  user_id: uuid
  variant_id: uuid
}

"""aggregate sum on columns"""
type price_report_sum_fields {
  deleted_at: Int
  price: numeric
}

"""
order by sum() on columns of table "price_report"
"""
input price_report_sum_order_by {
  deleted_at: order_by
  price: order_by
}

"""
update columns of table "price_report"
"""
enum price_report_update_column {
  """column name"""
  created_at

  """column name"""
  data_point

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  price

  """column name"""
  source

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  variant_id
}

input price_report_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: price_report_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: price_report_set_input

  """filter the rows which have to be updated"""
  where: price_report_bool_exp!
}

"""aggregate var_pop on columns"""
type price_report_var_pop_fields {
  deleted_at: Float
  price: Float
}

"""
order by var_pop() on columns of table "price_report"
"""
input price_report_var_pop_order_by {
  deleted_at: order_by
  price: order_by
}

"""aggregate var_samp on columns"""
type price_report_var_samp_fields {
  deleted_at: Float
  price: Float
}

"""
order by var_samp() on columns of table "price_report"
"""
input price_report_var_samp_order_by {
  deleted_at: order_by
  price: order_by
}

"""aggregate variance on columns"""
type price_report_variance_fields {
  deleted_at: Float
  price: Float
}

"""
order by variance() on columns of table "price_report"
"""
input price_report_variance_order_by {
  deleted_at: order_by
  price: order_by
}

"""
columns and relationships of "product_promo_configuration"
"""
type product_promo_configuration {
  """An object relationship"""
  product: products!
  product_id: uuid!

  """An object relationship"""
  promo_configuration: promo_configuration!
  promo_configuration_id: uuid!
}

"""
aggregated selection of "product_promo_configuration"
"""
type product_promo_configuration_aggregate {
  aggregate: product_promo_configuration_aggregate_fields
  nodes: [product_promo_configuration!]!
}

input product_promo_configuration_aggregate_bool_exp {
  count: product_promo_configuration_aggregate_bool_exp_count
}

input product_promo_configuration_aggregate_bool_exp_count {
  arguments: [product_promo_configuration_select_column!]
  distinct: Boolean
  filter: product_promo_configuration_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_promo_configuration"
"""
type product_promo_configuration_aggregate_fields {
  count(columns: [product_promo_configuration_select_column!], distinct: Boolean): Int!
  max: product_promo_configuration_max_fields
  min: product_promo_configuration_min_fields
}

"""
order by aggregate values of table "product_promo_configuration"
"""
input product_promo_configuration_aggregate_order_by {
  count: order_by
  max: product_promo_configuration_max_order_by
  min: product_promo_configuration_min_order_by
}

"""
input type for inserting array relation for remote table "product_promo_configuration"
"""
input product_promo_configuration_arr_rel_insert_input {
  data: [product_promo_configuration_insert_input!]!

  """upsert condition"""
  on_conflict: product_promo_configuration_on_conflict
}

"""
Boolean expression to filter rows from the table "product_promo_configuration". All fields are combined with a logical 'AND'.
"""
input product_promo_configuration_bool_exp {
  _and: [product_promo_configuration_bool_exp!]
  _not: product_promo_configuration_bool_exp
  _or: [product_promo_configuration_bool_exp!]
  product: products_bool_exp
  product_id: uuid_comparison_exp
  promo_configuration: promo_configuration_bool_exp
  promo_configuration_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "product_promo_configuration"
"""
enum product_promo_configuration_constraint {
  """
  unique or primary key constraint on columns "product_id", "promo_configuration_id"
  """
  product_promo_configuration_pkey
}

"""
input type for inserting data into table "product_promo_configuration"
"""
input product_promo_configuration_insert_input {
  product: products_obj_rel_insert_input
  product_id: uuid
  promo_configuration: promo_configuration_obj_rel_insert_input
  promo_configuration_id: uuid
}

"""aggregate max on columns"""
type product_promo_configuration_max_fields {
  product_id: uuid
  promo_configuration_id: uuid
}

"""
order by max() on columns of table "product_promo_configuration"
"""
input product_promo_configuration_max_order_by {
  product_id: order_by
  promo_configuration_id: order_by
}

"""aggregate min on columns"""
type product_promo_configuration_min_fields {
  product_id: uuid
  promo_configuration_id: uuid
}

"""
order by min() on columns of table "product_promo_configuration"
"""
input product_promo_configuration_min_order_by {
  product_id: order_by
  promo_configuration_id: order_by
}

"""
response of any mutation on the table "product_promo_configuration"
"""
type product_promo_configuration_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_promo_configuration!]!
}

"""
on_conflict condition type for table "product_promo_configuration"
"""
input product_promo_configuration_on_conflict {
  constraint: product_promo_configuration_constraint!
  update_columns: [product_promo_configuration_update_column!]! = []
  where: product_promo_configuration_bool_exp
}

"""
Ordering options when selecting data from "product_promo_configuration".
"""
input product_promo_configuration_order_by {
  product: products_order_by
  product_id: order_by
  promo_configuration: promo_configuration_order_by
  promo_configuration_id: order_by
}

"""primary key columns input for table: product_promo_configuration"""
input product_promo_configuration_pk_columns_input {
  product_id: uuid!
  promo_configuration_id: uuid!
}

"""
select columns of table "product_promo_configuration"
"""
enum product_promo_configuration_select_column {
  """column name"""
  product_id

  """column name"""
  promo_configuration_id
}

"""
input type for updating data in table "product_promo_configuration"
"""
input product_promo_configuration_set_input {
  product_id: uuid
  promo_configuration_id: uuid
}

"""
Streaming cursor of the table "product_promo_configuration"
"""
input product_promo_configuration_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_promo_configuration_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_promo_configuration_stream_cursor_value_input {
  product_id: uuid
  promo_configuration_id: uuid
}

"""
update columns of table "product_promo_configuration"
"""
enum product_promo_configuration_update_column {
  """column name"""
  product_id

  """column name"""
  promo_configuration_id
}

input product_promo_configuration_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_promo_configuration_set_input

  """filter the rows which have to be updated"""
  where: product_promo_configuration_bool_exp!
}

"""Each record represents an available variant for a product."""
type product_variants {
  """An array relationship"""
  attribute_selections(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): [attribute_selections!]!

  """An aggregate relationship"""
  attribute_selections_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): attribute_selections_aggregate!
  created_at: timestamptz!
  deleted_at: Int!
  highest_bid_offer_id: uuid
  highest_bid_price: numeric
  id: uuid!
  index_cache(
    """JSON select path"""
    path: String
  ): jsonb

  """An array relationship"""
  inventory_items(
    """distinct select on columns"""
    distinct_on: [inventory_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_items_order_by!]

    """filter the rows returned"""
    where: inventory_items_bool_exp
  ): [inventory_items!]!

  """An aggregate relationship"""
  inventory_items_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_items_order_by!]

    """filter the rows returned"""
    where: inventory_items_bool_exp
  ): inventory_items_aggregate!
  last_sale_at: timestamptz
  last_sale_price: numeric
  lowest_ask_offer_id: uuid
  lowest_ask_price: numeric
  manual_price: numeric
  manual_price_date: timestamptz
  max_market_price: numeric
  min_market_price: numeric
  price_mode: String!

  """An array relationship"""
  price_reports(
    """distinct select on columns"""
    distinct_on: [price_report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [price_report_order_by!]

    """filter the rows returned"""
    where: price_report_bool_exp
  ): [price_report!]!

  """An aggregate relationship"""
  price_reports_aggregate(
    """distinct select on columns"""
    distinct_on: [price_report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [price_report_order_by!]

    """filter the rows returned"""
    where: price_report_bool_exp
  ): price_report_aggregate!

  """An object relationship"""
  product: products!
  product_id: uuid!
  report_price: numeric
  report_price_date: timestamptz
  source_price: numeric
  source_price_date: timestamptz
  upc: String!
  update_report_price: Boolean!
  updated_at: timestamptz!

  """An array relationship"""
  wishlist_items(
    """distinct select on columns"""
    distinct_on: [wishlist_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlist_items_order_by!]

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): [wishlist_items!]!

  """An aggregate relationship"""
  wishlist_items_aggregate(
    """distinct select on columns"""
    distinct_on: [wishlist_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlist_items_order_by!]

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): wishlist_items_aggregate!
}

"""
aggregated selection of "product_variants"
"""
type product_variants_aggregate {
  aggregate: product_variants_aggregate_fields
  nodes: [product_variants!]!
}

input product_variants_aggregate_bool_exp {
  bool_and: product_variants_aggregate_bool_exp_bool_and
  bool_or: product_variants_aggregate_bool_exp_bool_or
  count: product_variants_aggregate_bool_exp_count
}

input product_variants_aggregate_bool_exp_bool_and {
  arguments: product_variants_select_column_product_variants_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: product_variants_bool_exp
  predicate: Boolean_comparison_exp!
}

input product_variants_aggregate_bool_exp_bool_or {
  arguments: product_variants_select_column_product_variants_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: product_variants_bool_exp
  predicate: Boolean_comparison_exp!
}

input product_variants_aggregate_bool_exp_count {
  arguments: [product_variants_select_column!]
  distinct: Boolean
  filter: product_variants_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_variants"
"""
type product_variants_aggregate_fields {
  avg: product_variants_avg_fields
  count(columns: [product_variants_select_column!], distinct: Boolean): Int!
  max: product_variants_max_fields
  min: product_variants_min_fields
  stddev: product_variants_stddev_fields
  stddev_pop: product_variants_stddev_pop_fields
  stddev_samp: product_variants_stddev_samp_fields
  sum: product_variants_sum_fields
  var_pop: product_variants_var_pop_fields
  var_samp: product_variants_var_samp_fields
  variance: product_variants_variance_fields
}

"""
order by aggregate values of table "product_variants"
"""
input product_variants_aggregate_order_by {
  avg: product_variants_avg_order_by
  count: order_by
  max: product_variants_max_order_by
  min: product_variants_min_order_by
  stddev: product_variants_stddev_order_by
  stddev_pop: product_variants_stddev_pop_order_by
  stddev_samp: product_variants_stddev_samp_order_by
  sum: product_variants_sum_order_by
  var_pop: product_variants_var_pop_order_by
  var_samp: product_variants_var_samp_order_by
  variance: product_variants_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input product_variants_append_input {
  index_cache: jsonb
}

"""
input type for inserting array relation for remote table "product_variants"
"""
input product_variants_arr_rel_insert_input {
  data: [product_variants_insert_input!]!

  """upsert condition"""
  on_conflict: product_variants_on_conflict
}

"""aggregate avg on columns"""
type product_variants_avg_fields {
  deleted_at: Float
  highest_bid_price: Float
  last_sale_price: Float
  lowest_ask_price: Float
  manual_price: Float
  max_market_price: Float
  min_market_price: Float
  report_price: Float
  source_price: Float
}

"""
order by avg() on columns of table "product_variants"
"""
input product_variants_avg_order_by {
  deleted_at: order_by
  highest_bid_price: order_by
  last_sale_price: order_by
  lowest_ask_price: order_by
  manual_price: order_by
  max_market_price: order_by
  min_market_price: order_by
  report_price: order_by
  source_price: order_by
}

"""
Boolean expression to filter rows from the table "product_variants". All fields are combined with a logical 'AND'.
"""
input product_variants_bool_exp {
  _and: [product_variants_bool_exp!]
  _not: product_variants_bool_exp
  _or: [product_variants_bool_exp!]
  attribute_selections: attribute_selections_bool_exp
  attribute_selections_aggregate: attribute_selections_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  highest_bid_offer_id: uuid_comparison_exp
  highest_bid_price: numeric_comparison_exp
  id: uuid_comparison_exp
  index_cache: jsonb_comparison_exp
  inventory_items: inventory_items_bool_exp
  inventory_items_aggregate: inventory_items_aggregate_bool_exp
  last_sale_at: timestamptz_comparison_exp
  last_sale_price: numeric_comparison_exp
  lowest_ask_offer_id: uuid_comparison_exp
  lowest_ask_price: numeric_comparison_exp
  manual_price: numeric_comparison_exp
  manual_price_date: timestamptz_comparison_exp
  max_market_price: numeric_comparison_exp
  min_market_price: numeric_comparison_exp
  price_mode: String_comparison_exp
  price_reports: price_report_bool_exp
  price_reports_aggregate: price_report_aggregate_bool_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  report_price: numeric_comparison_exp
  report_price_date: timestamptz_comparison_exp
  source_price: numeric_comparison_exp
  source_price_date: timestamptz_comparison_exp
  upc: String_comparison_exp
  update_report_price: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
  wishlist_items: wishlist_items_bool_exp
  wishlist_items_aggregate: wishlist_items_aggregate_bool_exp
}

"""
unique or primary key constraints on table "product_variants"
"""
enum product_variants_constraint {
  """
  unique or primary key constraint on columns "highest_bid_offer_id"
  """
  product_variants_highest_bid_offer_id_key

  """
  unique or primary key constraint on columns "lowest_ask_offer_id"
  """
  product_variants_lowest_ask_offer_id_key

  """
  unique or primary key constraint on columns "id"
  """
  product_variants_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input product_variants_delete_at_path_input {
  index_cache: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input product_variants_delete_elem_input {
  index_cache: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input product_variants_delete_key_input {
  index_cache: String
}

"""
input type for incrementing numeric columns in table "product_variants"
"""
input product_variants_inc_input {
  deleted_at: Int
  highest_bid_price: numeric
  last_sale_price: numeric
  lowest_ask_price: numeric
  manual_price: numeric
  max_market_price: numeric
  min_market_price: numeric
  report_price: numeric
  source_price: numeric
}

"""
input type for inserting data into table "product_variants"
"""
input product_variants_insert_input {
  attribute_selections: attribute_selections_arr_rel_insert_input
  created_at: timestamptz
  deleted_at: Int
  highest_bid_offer_id: uuid
  highest_bid_price: numeric
  id: uuid
  index_cache: jsonb
  inventory_items: inventory_items_arr_rel_insert_input
  last_sale_at: timestamptz
  last_sale_price: numeric
  lowest_ask_offer_id: uuid
  lowest_ask_price: numeric
  manual_price: numeric
  manual_price_date: timestamptz
  max_market_price: numeric
  min_market_price: numeric
  price_mode: String
  price_reports: price_report_arr_rel_insert_input
  product: products_obj_rel_insert_input
  product_id: uuid
  report_price: numeric
  report_price_date: timestamptz
  source_price: numeric
  source_price_date: timestamptz
  upc: String
  update_report_price: Boolean
  updated_at: timestamptz
  wishlist_items: wishlist_items_arr_rel_insert_input
}

"""aggregate max on columns"""
type product_variants_max_fields {
  created_at: timestamptz
  deleted_at: Int
  highest_bid_offer_id: uuid
  highest_bid_price: numeric
  id: uuid
  last_sale_at: timestamptz
  last_sale_price: numeric
  lowest_ask_offer_id: uuid
  lowest_ask_price: numeric
  manual_price: numeric
  manual_price_date: timestamptz
  max_market_price: numeric
  min_market_price: numeric
  price_mode: String
  product_id: uuid
  report_price: numeric
  report_price_date: timestamptz
  source_price: numeric
  source_price_date: timestamptz
  upc: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "product_variants"
"""
input product_variants_max_order_by {
  created_at: order_by
  deleted_at: order_by
  highest_bid_offer_id: order_by
  highest_bid_price: order_by
  id: order_by
  last_sale_at: order_by
  last_sale_price: order_by
  lowest_ask_offer_id: order_by
  lowest_ask_price: order_by
  manual_price: order_by
  manual_price_date: order_by
  max_market_price: order_by
  min_market_price: order_by
  price_mode: order_by
  product_id: order_by
  report_price: order_by
  report_price_date: order_by
  source_price: order_by
  source_price_date: order_by
  upc: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type product_variants_min_fields {
  created_at: timestamptz
  deleted_at: Int
  highest_bid_offer_id: uuid
  highest_bid_price: numeric
  id: uuid
  last_sale_at: timestamptz
  last_sale_price: numeric
  lowest_ask_offer_id: uuid
  lowest_ask_price: numeric
  manual_price: numeric
  manual_price_date: timestamptz
  max_market_price: numeric
  min_market_price: numeric
  price_mode: String
  product_id: uuid
  report_price: numeric
  report_price_date: timestamptz
  source_price: numeric
  source_price_date: timestamptz
  upc: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "product_variants"
"""
input product_variants_min_order_by {
  created_at: order_by
  deleted_at: order_by
  highest_bid_offer_id: order_by
  highest_bid_price: order_by
  id: order_by
  last_sale_at: order_by
  last_sale_price: order_by
  lowest_ask_offer_id: order_by
  lowest_ask_price: order_by
  manual_price: order_by
  manual_price_date: order_by
  max_market_price: order_by
  min_market_price: order_by
  price_mode: order_by
  product_id: order_by
  report_price: order_by
  report_price_date: order_by
  source_price: order_by
  source_price_date: order_by
  upc: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "product_variants"
"""
type product_variants_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_variants!]!
}

"""
input type for inserting object relation for remote table "product_variants"
"""
input product_variants_obj_rel_insert_input {
  data: product_variants_insert_input!

  """upsert condition"""
  on_conflict: product_variants_on_conflict
}

"""
on_conflict condition type for table "product_variants"
"""
input product_variants_on_conflict {
  constraint: product_variants_constraint!
  update_columns: [product_variants_update_column!]! = []
  where: product_variants_bool_exp
}

"""Ordering options when selecting data from "product_variants"."""
input product_variants_order_by {
  attribute_selections_aggregate: attribute_selections_aggregate_order_by
  created_at: order_by
  deleted_at: order_by
  highest_bid_offer_id: order_by
  highest_bid_price: order_by
  id: order_by
  index_cache: order_by
  inventory_items_aggregate: inventory_items_aggregate_order_by
  last_sale_at: order_by
  last_sale_price: order_by
  lowest_ask_offer_id: order_by
  lowest_ask_price: order_by
  manual_price: order_by
  manual_price_date: order_by
  max_market_price: order_by
  min_market_price: order_by
  price_mode: order_by
  price_reports_aggregate: price_report_aggregate_order_by
  product: products_order_by
  product_id: order_by
  report_price: order_by
  report_price_date: order_by
  source_price: order_by
  source_price_date: order_by
  upc: order_by
  update_report_price: order_by
  updated_at: order_by
  wishlist_items_aggregate: wishlist_items_aggregate_order_by
}

"""primary key columns input for table: product_variants"""
input product_variants_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input product_variants_prepend_input {
  index_cache: jsonb
}

"""
select columns of table "product_variants"
"""
enum product_variants_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  highest_bid_offer_id

  """column name"""
  highest_bid_price

  """column name"""
  id

  """column name"""
  index_cache

  """column name"""
  last_sale_at

  """column name"""
  last_sale_price

  """column name"""
  lowest_ask_offer_id

  """column name"""
  lowest_ask_price

  """column name"""
  manual_price

  """column name"""
  manual_price_date

  """column name"""
  max_market_price

  """column name"""
  min_market_price

  """column name"""
  price_mode

  """column name"""
  product_id

  """column name"""
  report_price

  """column name"""
  report_price_date

  """column name"""
  source_price

  """column name"""
  source_price_date

  """column name"""
  upc

  """column name"""
  update_report_price

  """column name"""
  updated_at
}

"""
select "product_variants_aggregate_bool_exp_bool_and_arguments_columns" columns of table "product_variants"
"""
enum product_variants_select_column_product_variants_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  update_report_price
}

"""
select "product_variants_aggregate_bool_exp_bool_or_arguments_columns" columns of table "product_variants"
"""
enum product_variants_select_column_product_variants_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  update_report_price
}

"""
input type for updating data in table "product_variants"
"""
input product_variants_set_input {
  created_at: timestamptz
  deleted_at: Int
  highest_bid_offer_id: uuid
  highest_bid_price: numeric
  id: uuid
  index_cache: jsonb
  last_sale_at: timestamptz
  last_sale_price: numeric
  lowest_ask_offer_id: uuid
  lowest_ask_price: numeric
  manual_price: numeric
  manual_price_date: timestamptz
  max_market_price: numeric
  min_market_price: numeric
  price_mode: String
  product_id: uuid
  report_price: numeric
  report_price_date: timestamptz
  source_price: numeric
  source_price_date: timestamptz
  upc: String
  update_report_price: Boolean
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type product_variants_stddev_fields {
  deleted_at: Float
  highest_bid_price: Float
  last_sale_price: Float
  lowest_ask_price: Float
  manual_price: Float
  max_market_price: Float
  min_market_price: Float
  report_price: Float
  source_price: Float
}

"""
order by stddev() on columns of table "product_variants"
"""
input product_variants_stddev_order_by {
  deleted_at: order_by
  highest_bid_price: order_by
  last_sale_price: order_by
  lowest_ask_price: order_by
  manual_price: order_by
  max_market_price: order_by
  min_market_price: order_by
  report_price: order_by
  source_price: order_by
}

"""aggregate stddev_pop on columns"""
type product_variants_stddev_pop_fields {
  deleted_at: Float
  highest_bid_price: Float
  last_sale_price: Float
  lowest_ask_price: Float
  manual_price: Float
  max_market_price: Float
  min_market_price: Float
  report_price: Float
  source_price: Float
}

"""
order by stddev_pop() on columns of table "product_variants"
"""
input product_variants_stddev_pop_order_by {
  deleted_at: order_by
  highest_bid_price: order_by
  last_sale_price: order_by
  lowest_ask_price: order_by
  manual_price: order_by
  max_market_price: order_by
  min_market_price: order_by
  report_price: order_by
  source_price: order_by
}

"""aggregate stddev_samp on columns"""
type product_variants_stddev_samp_fields {
  deleted_at: Float
  highest_bid_price: Float
  last_sale_price: Float
  lowest_ask_price: Float
  manual_price: Float
  max_market_price: Float
  min_market_price: Float
  report_price: Float
  source_price: Float
}

"""
order by stddev_samp() on columns of table "product_variants"
"""
input product_variants_stddev_samp_order_by {
  deleted_at: order_by
  highest_bid_price: order_by
  last_sale_price: order_by
  lowest_ask_price: order_by
  manual_price: order_by
  max_market_price: order_by
  min_market_price: order_by
  report_price: order_by
  source_price: order_by
}

"""
Streaming cursor of the table "product_variants"
"""
input product_variants_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_variants_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_variants_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: Int
  highest_bid_offer_id: uuid
  highest_bid_price: numeric
  id: uuid
  index_cache: jsonb
  last_sale_at: timestamptz
  last_sale_price: numeric
  lowest_ask_offer_id: uuid
  lowest_ask_price: numeric
  manual_price: numeric
  manual_price_date: timestamptz
  max_market_price: numeric
  min_market_price: numeric
  price_mode: String
  product_id: uuid
  report_price: numeric
  report_price_date: timestamptz
  source_price: numeric
  source_price_date: timestamptz
  upc: String
  update_report_price: Boolean
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type product_variants_sum_fields {
  deleted_at: Int
  highest_bid_price: numeric
  last_sale_price: numeric
  lowest_ask_price: numeric
  manual_price: numeric
  max_market_price: numeric
  min_market_price: numeric
  report_price: numeric
  source_price: numeric
}

"""
order by sum() on columns of table "product_variants"
"""
input product_variants_sum_order_by {
  deleted_at: order_by
  highest_bid_price: order_by
  last_sale_price: order_by
  lowest_ask_price: order_by
  manual_price: order_by
  max_market_price: order_by
  min_market_price: order_by
  report_price: order_by
  source_price: order_by
}

"""
update columns of table "product_variants"
"""
enum product_variants_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  highest_bid_offer_id

  """column name"""
  highest_bid_price

  """column name"""
  id

  """column name"""
  index_cache

  """column name"""
  last_sale_at

  """column name"""
  last_sale_price

  """column name"""
  lowest_ask_offer_id

  """column name"""
  lowest_ask_price

  """column name"""
  manual_price

  """column name"""
  manual_price_date

  """column name"""
  max_market_price

  """column name"""
  min_market_price

  """column name"""
  price_mode

  """column name"""
  product_id

  """column name"""
  report_price

  """column name"""
  report_price_date

  """column name"""
  source_price

  """column name"""
  source_price_date

  """column name"""
  upc

  """column name"""
  update_report_price

  """column name"""
  updated_at
}

input product_variants_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: product_variants_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: product_variants_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: product_variants_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: product_variants_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: product_variants_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: product_variants_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_variants_set_input

  """filter the rows which have to be updated"""
  where: product_variants_bool_exp!
}

"""aggregate var_pop on columns"""
type product_variants_var_pop_fields {
  deleted_at: Float
  highest_bid_price: Float
  last_sale_price: Float
  lowest_ask_price: Float
  manual_price: Float
  max_market_price: Float
  min_market_price: Float
  report_price: Float
  source_price: Float
}

"""
order by var_pop() on columns of table "product_variants"
"""
input product_variants_var_pop_order_by {
  deleted_at: order_by
  highest_bid_price: order_by
  last_sale_price: order_by
  lowest_ask_price: order_by
  manual_price: order_by
  max_market_price: order_by
  min_market_price: order_by
  report_price: order_by
  source_price: order_by
}

"""aggregate var_samp on columns"""
type product_variants_var_samp_fields {
  deleted_at: Float
  highest_bid_price: Float
  last_sale_price: Float
  lowest_ask_price: Float
  manual_price: Float
  max_market_price: Float
  min_market_price: Float
  report_price: Float
  source_price: Float
}

"""
order by var_samp() on columns of table "product_variants"
"""
input product_variants_var_samp_order_by {
  deleted_at: order_by
  highest_bid_price: order_by
  last_sale_price: order_by
  lowest_ask_price: order_by
  manual_price: order_by
  max_market_price: order_by
  min_market_price: order_by
  report_price: order_by
  source_price: order_by
}

"""aggregate variance on columns"""
type product_variants_variance_fields {
  deleted_at: Float
  highest_bid_price: Float
  last_sale_price: Float
  lowest_ask_price: Float
  manual_price: Float
  max_market_price: Float
  min_market_price: Float
  report_price: Float
  source_price: Float
}

"""
order by variance() on columns of table "product_variants"
"""
input product_variants_variance_order_by {
  deleted_at: order_by
  highest_bid_price: order_by
  last_sale_price: order_by
  lowest_ask_price: order_by
  manual_price: order_by
  max_market_price: order_by
  min_market_price: order_by
  report_price: order_by
  source_price: order_by
}

"""Each record represents a product in our catalog."""
type products {
  """An object relationship"""
  attribute_group: attribute_groups!
  attribute_group_id: uuid!

  """An array relationship"""
  attribute_selections(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): [attribute_selections!]!

  """An aggregate relationship"""
  attribute_selections_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): attribute_selections_aggregate!
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!
  index_cache(
    """JSON select path"""
    path: String
  ): jsonb

  """An array relationship"""
  march_mania_brackets(
    """distinct select on columns"""
    distinct_on: [march_mania_bracket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [march_mania_bracket_order_by!]

    """filter the rows returned"""
    where: march_mania_bracket_bool_exp
  ): [march_mania_bracket!]!

  """An aggregate relationship"""
  march_mania_brackets_aggregate(
    """distinct select on columns"""
    distinct_on: [march_mania_bracket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [march_mania_bracket_order_by!]

    """filter the rows returned"""
    where: march_mania_bracket_bool_exp
  ): march_mania_bracket_aggregate!
  mpn: String!
  name: String!
  page_views_count: Int!

  """An array relationship"""
  pictures(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  pictures_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """An array relationship"""
  product_variants(
    """distinct select on columns"""
    distinct_on: [product_variants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_variants_order_by!]

    """filter the rows returned"""
    where: product_variants_bool_exp
  ): [product_variants!]!

  """An aggregate relationship"""
  product_variants_aggregate(
    """distinct select on columns"""
    distinct_on: [product_variants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_variants_order_by!]

    """filter the rows returned"""
    where: product_variants_bool_exp
  ): product_variants_aggregate!

  """An array relationship"""
  promo_configurations(
    """distinct select on columns"""
    distinct_on: [product_promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_promo_configuration_order_by!]

    """filter the rows returned"""
    where: product_promo_configuration_bool_exp
  ): [product_promo_configuration!]!

  """An aggregate relationship"""
  promo_configurations_aggregate(
    """distinct select on columns"""
    distinct_on: [product_promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_promo_configuration_order_by!]

    """filter the rows returned"""
    where: product_promo_configuration_bool_exp
  ): product_promo_configuration_aggregate!
  release_date: date
  retail_price: numeric
  skip_prices_update: Boolean!
  slug: String
  update_prices_daily: Boolean!
  updated_at: timestamptz!
}

"""
aggregated selection of "products"
"""
type products_aggregate {
  aggregate: products_aggregate_fields
  nodes: [products!]!
}

input products_aggregate_bool_exp {
  bool_and: products_aggregate_bool_exp_bool_and
  bool_or: products_aggregate_bool_exp_bool_or
  count: products_aggregate_bool_exp_count
}

input products_aggregate_bool_exp_bool_and {
  arguments: products_select_column_products_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: products_bool_exp
  predicate: Boolean_comparison_exp!
}

input products_aggregate_bool_exp_bool_or {
  arguments: products_select_column_products_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: products_bool_exp
  predicate: Boolean_comparison_exp!
}

input products_aggregate_bool_exp_count {
  arguments: [products_select_column!]
  distinct: Boolean
  filter: products_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "products"
"""
type products_aggregate_fields {
  avg: products_avg_fields
  count(columns: [products_select_column!], distinct: Boolean): Int!
  max: products_max_fields
  min: products_min_fields
  stddev: products_stddev_fields
  stddev_pop: products_stddev_pop_fields
  stddev_samp: products_stddev_samp_fields
  sum: products_sum_fields
  var_pop: products_var_pop_fields
  var_samp: products_var_samp_fields
  variance: products_variance_fields
}

"""
order by aggregate values of table "products"
"""
input products_aggregate_order_by {
  avg: products_avg_order_by
  count: order_by
  max: products_max_order_by
  min: products_min_order_by
  stddev: products_stddev_order_by
  stddev_pop: products_stddev_pop_order_by
  stddev_samp: products_stddev_samp_order_by
  sum: products_sum_order_by
  var_pop: products_var_pop_order_by
  var_samp: products_var_samp_order_by
  variance: products_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input products_append_input {
  index_cache: jsonb
}

"""
input type for inserting array relation for remote table "products"
"""
input products_arr_rel_insert_input {
  data: [products_insert_input!]!

  """upsert condition"""
  on_conflict: products_on_conflict
}

"""aggregate avg on columns"""
type products_avg_fields {
  deleted_at: Float
  page_views_count: Float
  retail_price: Float
}

"""
order by avg() on columns of table "products"
"""
input products_avg_order_by {
  deleted_at: order_by
  page_views_count: order_by
  retail_price: order_by
}

"""
Boolean expression to filter rows from the table "products". All fields are combined with a logical 'AND'.
"""
input products_bool_exp {
  _and: [products_bool_exp!]
  _not: products_bool_exp
  _or: [products_bool_exp!]
  attribute_group: attribute_groups_bool_exp
  attribute_group_id: uuid_comparison_exp
  attribute_selections: attribute_selections_bool_exp
  attribute_selections_aggregate: attribute_selections_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  index_cache: jsonb_comparison_exp
  march_mania_brackets: march_mania_bracket_bool_exp
  march_mania_brackets_aggregate: march_mania_bracket_aggregate_bool_exp
  mpn: String_comparison_exp
  name: String_comparison_exp
  page_views_count: Int_comparison_exp
  pictures: files_bool_exp
  pictures_aggregate: files_aggregate_bool_exp
  product_variants: product_variants_bool_exp
  product_variants_aggregate: product_variants_aggregate_bool_exp
  promo_configurations: product_promo_configuration_bool_exp
  promo_configurations_aggregate: product_promo_configuration_aggregate_bool_exp
  release_date: date_comparison_exp
  retail_price: numeric_comparison_exp
  skip_prices_update: Boolean_comparison_exp
  slug: String_comparison_exp
  update_prices_daily: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "products"
"""
enum products_constraint {
  """
  unique or primary key constraint on columns "mpn"
  """
  products_mpn_key

  """
  unique or primary key constraint on columns "id"
  """
  products_pkey

  """
  unique or primary key constraint on columns "slug"
  """
  products_slug_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input products_delete_at_path_input {
  index_cache: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input products_delete_elem_input {
  index_cache: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input products_delete_key_input {
  index_cache: String
}

"""
input type for incrementing numeric columns in table "products"
"""
input products_inc_input {
  deleted_at: Int
  page_views_count: Int
  retail_price: numeric
}

"""
input type for inserting data into table "products"
"""
input products_insert_input {
  attribute_group: attribute_groups_obj_rel_insert_input
  attribute_group_id: uuid
  attribute_selections: attribute_selections_arr_rel_insert_input
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  index_cache: jsonb
  march_mania_brackets: march_mania_bracket_arr_rel_insert_input
  mpn: String
  name: String
  page_views_count: Int
  pictures: files_arr_rel_insert_input
  product_variants: product_variants_arr_rel_insert_input
  promo_configurations: product_promo_configuration_arr_rel_insert_input
  release_date: date
  retail_price: numeric
  skip_prices_update: Boolean
  slug: String
  update_prices_daily: Boolean
  updated_at: timestamptz
}

"""aggregate max on columns"""
type products_max_fields {
  attribute_group_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  mpn: String
  name: String
  page_views_count: Int
  release_date: date
  retail_price: numeric
  slug: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "products"
"""
input products_max_order_by {
  attribute_group_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  mpn: order_by
  name: order_by
  page_views_count: order_by
  release_date: order_by
  retail_price: order_by
  slug: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type products_min_fields {
  attribute_group_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  mpn: String
  name: String
  page_views_count: Int
  release_date: date
  retail_price: numeric
  slug: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "products"
"""
input products_min_order_by {
  attribute_group_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  mpn: order_by
  name: order_by
  page_views_count: order_by
  release_date: order_by
  retail_price: order_by
  slug: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "products"
"""
type products_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [products!]!
}

"""
input type for inserting object relation for remote table "products"
"""
input products_obj_rel_insert_input {
  data: products_insert_input!

  """upsert condition"""
  on_conflict: products_on_conflict
}

"""
on_conflict condition type for table "products"
"""
input products_on_conflict {
  constraint: products_constraint!
  update_columns: [products_update_column!]! = []
  where: products_bool_exp
}

"""Ordering options when selecting data from "products"."""
input products_order_by {
  attribute_group: attribute_groups_order_by
  attribute_group_id: order_by
  attribute_selections_aggregate: attribute_selections_aggregate_order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  index_cache: order_by
  march_mania_brackets_aggregate: march_mania_bracket_aggregate_order_by
  mpn: order_by
  name: order_by
  page_views_count: order_by
  pictures_aggregate: files_aggregate_order_by
  product_variants_aggregate: product_variants_aggregate_order_by
  promo_configurations_aggregate: product_promo_configuration_aggregate_order_by
  release_date: order_by
  retail_price: order_by
  skip_prices_update: order_by
  slug: order_by
  update_prices_daily: order_by
  updated_at: order_by
}

"""primary key columns input for table: products"""
input products_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input products_prepend_input {
  index_cache: jsonb
}

"""
select columns of table "products"
"""
enum products_select_column {
  """column name"""
  attribute_group_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  index_cache

  """column name"""
  mpn

  """column name"""
  name

  """column name"""
  page_views_count

  """column name"""
  release_date

  """column name"""
  retail_price

  """column name"""
  skip_prices_update

  """column name"""
  slug

  """column name"""
  update_prices_daily

  """column name"""
  updated_at
}

"""
select "products_aggregate_bool_exp_bool_and_arguments_columns" columns of table "products"
"""
enum products_select_column_products_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  skip_prices_update

  """column name"""
  update_prices_daily
}

"""
select "products_aggregate_bool_exp_bool_or_arguments_columns" columns of table "products"
"""
enum products_select_column_products_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  skip_prices_update

  """column name"""
  update_prices_daily
}

"""
input type for updating data in table "products"
"""
input products_set_input {
  attribute_group_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  index_cache: jsonb
  mpn: String
  name: String
  page_views_count: Int
  release_date: date
  retail_price: numeric
  skip_prices_update: Boolean
  slug: String
  update_prices_daily: Boolean
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type products_stddev_fields {
  deleted_at: Float
  page_views_count: Float
  retail_price: Float
}

"""
order by stddev() on columns of table "products"
"""
input products_stddev_order_by {
  deleted_at: order_by
  page_views_count: order_by
  retail_price: order_by
}

"""aggregate stddev_pop on columns"""
type products_stddev_pop_fields {
  deleted_at: Float
  page_views_count: Float
  retail_price: Float
}

"""
order by stddev_pop() on columns of table "products"
"""
input products_stddev_pop_order_by {
  deleted_at: order_by
  page_views_count: order_by
  retail_price: order_by
}

"""aggregate stddev_samp on columns"""
type products_stddev_samp_fields {
  deleted_at: Float
  page_views_count: Float
  retail_price: Float
}

"""
order by stddev_samp() on columns of table "products"
"""
input products_stddev_samp_order_by {
  deleted_at: order_by
  page_views_count: order_by
  retail_price: order_by
}

"""
Streaming cursor of the table "products"
"""
input products_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: products_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input products_stream_cursor_value_input {
  attribute_group_id: uuid
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  index_cache: jsonb
  mpn: String
  name: String
  page_views_count: Int
  release_date: date
  retail_price: numeric
  skip_prices_update: Boolean
  slug: String
  update_prices_daily: Boolean
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type products_sum_fields {
  deleted_at: Int
  page_views_count: Int
  retail_price: numeric
}

"""
order by sum() on columns of table "products"
"""
input products_sum_order_by {
  deleted_at: order_by
  page_views_count: order_by
  retail_price: order_by
}

"""
update columns of table "products"
"""
enum products_update_column {
  """column name"""
  attribute_group_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  index_cache

  """column name"""
  mpn

  """column name"""
  name

  """column name"""
  page_views_count

  """column name"""
  release_date

  """column name"""
  retail_price

  """column name"""
  skip_prices_update

  """column name"""
  slug

  """column name"""
  update_prices_daily

  """column name"""
  updated_at
}

input products_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: products_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: products_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: products_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: products_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: products_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: products_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: products_set_input

  """filter the rows which have to be updated"""
  where: products_bool_exp!
}

"""aggregate var_pop on columns"""
type products_var_pop_fields {
  deleted_at: Float
  page_views_count: Float
  retail_price: Float
}

"""
order by var_pop() on columns of table "products"
"""
input products_var_pop_order_by {
  deleted_at: order_by
  page_views_count: order_by
  retail_price: order_by
}

"""aggregate var_samp on columns"""
type products_var_samp_fields {
  deleted_at: Float
  page_views_count: Float
  retail_price: Float
}

"""
order by var_samp() on columns of table "products"
"""
input products_var_samp_order_by {
  deleted_at: order_by
  page_views_count: order_by
  retail_price: order_by
}

"""aggregate variance on columns"""
type products_variance_fields {
  deleted_at: Float
  page_views_count: Float
  retail_price: Float
}

"""
order by variance() on columns of table "products"
"""
input products_variance_order_by {
  deleted_at: order_by
  page_views_count: order_by
  retail_price: order_by
}

"""
columns and relationships of "promo_configuration"
"""
type promo_configuration {
  created_at: timestamptz!
  deleted_at: Int!
  enabled: Boolean!
  end_date: timestamptz!
  id: uuid!
  name: String!

  """An array relationship"""
  product_promo_configurations(
    """distinct select on columns"""
    distinct_on: [product_promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_promo_configuration_order_by!]

    """filter the rows returned"""
    where: product_promo_configuration_bool_exp
  ): [product_promo_configuration!]!

  """An aggregate relationship"""
  product_promo_configurations_aggregate(
    """distinct select on columns"""
    distinct_on: [product_promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_promo_configuration_order_by!]

    """filter the rows returned"""
    where: product_promo_configuration_bool_exp
  ): product_promo_configuration_aggregate!

  """An object relationship"""
  promo_name: promo_configuration_name!
  start_date: timestamptz!
  updated_at: timestamptz!
}

"""
aggregated selection of "promo_configuration"
"""
type promo_configuration_aggregate {
  aggregate: promo_configuration_aggregate_fields
  nodes: [promo_configuration!]!
}

input promo_configuration_aggregate_bool_exp {
  bool_and: promo_configuration_aggregate_bool_exp_bool_and
  bool_or: promo_configuration_aggregate_bool_exp_bool_or
  count: promo_configuration_aggregate_bool_exp_count
}

input promo_configuration_aggregate_bool_exp_bool_and {
  arguments: promo_configuration_select_column_promo_configuration_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: promo_configuration_bool_exp
  predicate: Boolean_comparison_exp!
}

input promo_configuration_aggregate_bool_exp_bool_or {
  arguments: promo_configuration_select_column_promo_configuration_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: promo_configuration_bool_exp
  predicate: Boolean_comparison_exp!
}

input promo_configuration_aggregate_bool_exp_count {
  arguments: [promo_configuration_select_column!]
  distinct: Boolean
  filter: promo_configuration_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "promo_configuration"
"""
type promo_configuration_aggregate_fields {
  avg: promo_configuration_avg_fields
  count(columns: [promo_configuration_select_column!], distinct: Boolean): Int!
  max: promo_configuration_max_fields
  min: promo_configuration_min_fields
  stddev: promo_configuration_stddev_fields
  stddev_pop: promo_configuration_stddev_pop_fields
  stddev_samp: promo_configuration_stddev_samp_fields
  sum: promo_configuration_sum_fields
  var_pop: promo_configuration_var_pop_fields
  var_samp: promo_configuration_var_samp_fields
  variance: promo_configuration_variance_fields
}

"""
order by aggregate values of table "promo_configuration"
"""
input promo_configuration_aggregate_order_by {
  avg: promo_configuration_avg_order_by
  count: order_by
  max: promo_configuration_max_order_by
  min: promo_configuration_min_order_by
  stddev: promo_configuration_stddev_order_by
  stddev_pop: promo_configuration_stddev_pop_order_by
  stddev_samp: promo_configuration_stddev_samp_order_by
  sum: promo_configuration_sum_order_by
  var_pop: promo_configuration_var_pop_order_by
  var_samp: promo_configuration_var_samp_order_by
  variance: promo_configuration_variance_order_by
}

"""
input type for inserting array relation for remote table "promo_configuration"
"""
input promo_configuration_arr_rel_insert_input {
  data: [promo_configuration_insert_input!]!

  """upsert condition"""
  on_conflict: promo_configuration_on_conflict
}

"""aggregate avg on columns"""
type promo_configuration_avg_fields {
  deleted_at: Float
}

"""
order by avg() on columns of table "promo_configuration"
"""
input promo_configuration_avg_order_by {
  deleted_at: order_by
}

"""
Boolean expression to filter rows from the table "promo_configuration". All fields are combined with a logical 'AND'.
"""
input promo_configuration_bool_exp {
  _and: [promo_configuration_bool_exp!]
  _not: promo_configuration_bool_exp
  _or: [promo_configuration_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  enabled: Boolean_comparison_exp
  end_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  product_promo_configurations: product_promo_configuration_bool_exp
  product_promo_configurations_aggregate: product_promo_configuration_aggregate_bool_exp
  promo_name: promo_configuration_name_bool_exp
  start_date: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "promo_configuration"
"""
enum promo_configuration_constraint {
  """
  unique or primary key constraint on columns "start_date", "end_date", "name"
  """
  promo_configuration_name_start_date_end_date_key

  """
  unique or primary key constraint on columns "id"
  """
  promo_configuration_pkey
}

"""
input type for incrementing numeric columns in table "promo_configuration"
"""
input promo_configuration_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "promo_configuration"
"""
input promo_configuration_insert_input {
  created_at: timestamptz
  deleted_at: Int
  enabled: Boolean
  end_date: timestamptz
  id: uuid
  name: String
  product_promo_configurations: product_promo_configuration_arr_rel_insert_input
  promo_name: promo_configuration_name_obj_rel_insert_input
  start_date: timestamptz
  updated_at: timestamptz
}

"""aggregate max on columns"""
type promo_configuration_max_fields {
  created_at: timestamptz
  deleted_at: Int
  end_date: timestamptz
  id: uuid
  name: String
  start_date: timestamptz
  updated_at: timestamptz
}

"""
order by max() on columns of table "promo_configuration"
"""
input promo_configuration_max_order_by {
  created_at: order_by
  deleted_at: order_by
  end_date: order_by
  id: order_by
  name: order_by
  start_date: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type promo_configuration_min_fields {
  created_at: timestamptz
  deleted_at: Int
  end_date: timestamptz
  id: uuid
  name: String
  start_date: timestamptz
  updated_at: timestamptz
}

"""
order by min() on columns of table "promo_configuration"
"""
input promo_configuration_min_order_by {
  created_at: order_by
  deleted_at: order_by
  end_date: order_by
  id: order_by
  name: order_by
  start_date: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "promo_configuration"
"""
type promo_configuration_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [promo_configuration!]!
}

"""
columns and relationships of "promo_configuration_name"
"""
type promo_configuration_name {
  name: String!

  """An array relationship"""
  promo_name_configurations(
    """distinct select on columns"""
    distinct_on: [promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [promo_configuration_order_by!]

    """filter the rows returned"""
    where: promo_configuration_bool_exp
  ): [promo_configuration!]!

  """An aggregate relationship"""
  promo_name_configurations_aggregate(
    """distinct select on columns"""
    distinct_on: [promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [promo_configuration_order_by!]

    """filter the rows returned"""
    where: promo_configuration_bool_exp
  ): promo_configuration_aggregate!
}

"""
aggregated selection of "promo_configuration_name"
"""
type promo_configuration_name_aggregate {
  aggregate: promo_configuration_name_aggregate_fields
  nodes: [promo_configuration_name!]!
}

"""
aggregate fields of "promo_configuration_name"
"""
type promo_configuration_name_aggregate_fields {
  count(columns: [promo_configuration_name_select_column!], distinct: Boolean): Int!
  max: promo_configuration_name_max_fields
  min: promo_configuration_name_min_fields
}

"""
Boolean expression to filter rows from the table "promo_configuration_name". All fields are combined with a logical 'AND'.
"""
input promo_configuration_name_bool_exp {
  _and: [promo_configuration_name_bool_exp!]
  _not: promo_configuration_name_bool_exp
  _or: [promo_configuration_name_bool_exp!]
  name: String_comparison_exp
  promo_name_configurations: promo_configuration_bool_exp
  promo_name_configurations_aggregate: promo_configuration_aggregate_bool_exp
}

"""
unique or primary key constraints on table "promo_configuration_name"
"""
enum promo_configuration_name_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  promo_configuration_name_pkey
}

"""
input type for inserting data into table "promo_configuration_name"
"""
input promo_configuration_name_insert_input {
  name: String
  promo_name_configurations: promo_configuration_arr_rel_insert_input
}

"""aggregate max on columns"""
type promo_configuration_name_max_fields {
  name: String
}

"""aggregate min on columns"""
type promo_configuration_name_min_fields {
  name: String
}

"""
response of any mutation on the table "promo_configuration_name"
"""
type promo_configuration_name_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [promo_configuration_name!]!
}

"""
input type for inserting object relation for remote table "promo_configuration_name"
"""
input promo_configuration_name_obj_rel_insert_input {
  data: promo_configuration_name_insert_input!

  """upsert condition"""
  on_conflict: promo_configuration_name_on_conflict
}

"""
on_conflict condition type for table "promo_configuration_name"
"""
input promo_configuration_name_on_conflict {
  constraint: promo_configuration_name_constraint!
  update_columns: [promo_configuration_name_update_column!]! = []
  where: promo_configuration_name_bool_exp
}

"""Ordering options when selecting data from "promo_configuration_name"."""
input promo_configuration_name_order_by {
  name: order_by
  promo_name_configurations_aggregate: promo_configuration_aggregate_order_by
}

"""primary key columns input for table: promo_configuration_name"""
input promo_configuration_name_pk_columns_input {
  name: String!
}

"""
select columns of table "promo_configuration_name"
"""
enum promo_configuration_name_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "promo_configuration_name"
"""
input promo_configuration_name_set_input {
  name: String
}

"""
Streaming cursor of the table "promo_configuration_name"
"""
input promo_configuration_name_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: promo_configuration_name_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input promo_configuration_name_stream_cursor_value_input {
  name: String
}

"""
update columns of table "promo_configuration_name"
"""
enum promo_configuration_name_update_column {
  """column name"""
  name
}

input promo_configuration_name_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: promo_configuration_name_set_input

  """filter the rows which have to be updated"""
  where: promo_configuration_name_bool_exp!
}

"""
input type for inserting object relation for remote table "promo_configuration"
"""
input promo_configuration_obj_rel_insert_input {
  data: promo_configuration_insert_input!

  """upsert condition"""
  on_conflict: promo_configuration_on_conflict
}

"""
on_conflict condition type for table "promo_configuration"
"""
input promo_configuration_on_conflict {
  constraint: promo_configuration_constraint!
  update_columns: [promo_configuration_update_column!]! = []
  where: promo_configuration_bool_exp
}

"""Ordering options when selecting data from "promo_configuration"."""
input promo_configuration_order_by {
  created_at: order_by
  deleted_at: order_by
  enabled: order_by
  end_date: order_by
  id: order_by
  name: order_by
  product_promo_configurations_aggregate: product_promo_configuration_aggregate_order_by
  promo_name: promo_configuration_name_order_by
  start_date: order_by
  updated_at: order_by
}

"""primary key columns input for table: promo_configuration"""
input promo_configuration_pk_columns_input {
  id: uuid!
}

"""
select columns of table "promo_configuration"
"""
enum promo_configuration_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  enabled

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  name

  """column name"""
  start_date

  """column name"""
  updated_at
}

"""
select "promo_configuration_aggregate_bool_exp_bool_and_arguments_columns" columns of table "promo_configuration"
"""
enum promo_configuration_select_column_promo_configuration_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  enabled
}

"""
select "promo_configuration_aggregate_bool_exp_bool_or_arguments_columns" columns of table "promo_configuration"
"""
enum promo_configuration_select_column_promo_configuration_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  enabled
}

"""
input type for updating data in table "promo_configuration"
"""
input promo_configuration_set_input {
  created_at: timestamptz
  deleted_at: Int
  enabled: Boolean
  end_date: timestamptz
  id: uuid
  name: String
  start_date: timestamptz
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type promo_configuration_stddev_fields {
  deleted_at: Float
}

"""
order by stddev() on columns of table "promo_configuration"
"""
input promo_configuration_stddev_order_by {
  deleted_at: order_by
}

"""aggregate stddev_pop on columns"""
type promo_configuration_stddev_pop_fields {
  deleted_at: Float
}

"""
order by stddev_pop() on columns of table "promo_configuration"
"""
input promo_configuration_stddev_pop_order_by {
  deleted_at: order_by
}

"""aggregate stddev_samp on columns"""
type promo_configuration_stddev_samp_fields {
  deleted_at: Float
}

"""
order by stddev_samp() on columns of table "promo_configuration"
"""
input promo_configuration_stddev_samp_order_by {
  deleted_at: order_by
}

"""
Streaming cursor of the table "promo_configuration"
"""
input promo_configuration_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: promo_configuration_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input promo_configuration_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: Int
  enabled: Boolean
  end_date: timestamptz
  id: uuid
  name: String
  start_date: timestamptz
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type promo_configuration_sum_fields {
  deleted_at: Int
}

"""
order by sum() on columns of table "promo_configuration"
"""
input promo_configuration_sum_order_by {
  deleted_at: order_by
}

"""
update columns of table "promo_configuration"
"""
enum promo_configuration_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  enabled

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  name

  """column name"""
  start_date

  """column name"""
  updated_at
}

input promo_configuration_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: promo_configuration_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: promo_configuration_set_input

  """filter the rows which have to be updated"""
  where: promo_configuration_bool_exp!
}

"""aggregate var_pop on columns"""
type promo_configuration_var_pop_fields {
  deleted_at: Float
}

"""
order by var_pop() on columns of table "promo_configuration"
"""
input promo_configuration_var_pop_order_by {
  deleted_at: order_by
}

"""aggregate var_samp on columns"""
type promo_configuration_var_samp_fields {
  deleted_at: Float
}

"""
order by var_samp() on columns of table "promo_configuration"
"""
input promo_configuration_var_samp_order_by {
  deleted_at: order_by
}

"""aggregate variance on columns"""
type promo_configuration_variance_fields {
  deleted_at: Float
}

"""
order by variance() on columns of table "promo_configuration"
"""
input promo_configuration_variance_order_by {
  deleted_at: order_by
}

type query_root {
  """An array relationship"""
  addresses(
    """distinct select on columns"""
    distinct_on: [addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [addresses_order_by!]

    """filter the rows returned"""
    where: addresses_bool_exp
  ): [addresses!]!

  """An aggregate relationship"""
  addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [addresses_order_by!]

    """filter the rows returned"""
    where: addresses_bool_exp
  ): addresses_aggregate!

  """fetch data from the table: "addresses" using primary key columns"""
  addresses_by_pk(id: uuid!): addresses

  """
  fetch data from the table: "attribute_attribute_group"
  """
  attribute_attribute_group(
    """distinct select on columns"""
    distinct_on: [attribute_attribute_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_attribute_group_order_by!]

    """filter the rows returned"""
    where: attribute_attribute_group_bool_exp
  ): [attribute_attribute_group!]!

  """
  fetch aggregated fields from the table: "attribute_attribute_group"
  """
  attribute_attribute_group_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_attribute_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_attribute_group_order_by!]

    """filter the rows returned"""
    where: attribute_attribute_group_bool_exp
  ): attribute_attribute_group_aggregate!

  """
  fetch data from the table: "attribute_attribute_group" using primary key columns
  """
  attribute_attribute_group_by_pk(id: uuid!): attribute_attribute_group

  """
  fetch data from the table: "attribute_groups"
  """
  attribute_groups(
    """distinct select on columns"""
    distinct_on: [attribute_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_groups_order_by!]

    """filter the rows returned"""
    where: attribute_groups_bool_exp
  ): [attribute_groups!]!

  """
  fetch aggregated fields from the table: "attribute_groups"
  """
  attribute_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_groups_order_by!]

    """filter the rows returned"""
    where: attribute_groups_bool_exp
  ): attribute_groups_aggregate!

  """
  fetch data from the table: "attribute_groups" using primary key columns
  """
  attribute_groups_by_pk(id: uuid!): attribute_groups

  """An array relationship"""
  attribute_preferences(
    """distinct select on columns"""
    distinct_on: [attribute_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_preferences_order_by!]

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): [attribute_preferences!]!

  """An aggregate relationship"""
  attribute_preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_preferences_order_by!]

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): attribute_preferences_aggregate!

  """
  fetch data from the table: "attribute_preferences" using primary key columns
  """
  attribute_preferences_by_pk(id: uuid!): attribute_preferences

  """An array relationship"""
  attribute_selections(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): [attribute_selections!]!

  """An aggregate relationship"""
  attribute_selections_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): attribute_selections_aggregate!

  """
  fetch data from the table: "attribute_selections" using primary key columns
  """
  attribute_selections_by_pk(id: uuid!): attribute_selections

  """
  fetch data from the table: "attribute_type"
  """
  attribute_type(
    """distinct select on columns"""
    distinct_on: [attribute_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_type_order_by!]

    """filter the rows returned"""
    where: attribute_type_bool_exp
  ): [attribute_type!]!

  """
  fetch aggregated fields from the table: "attribute_type"
  """
  attribute_type_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_type_order_by!]

    """filter the rows returned"""
    where: attribute_type_bool_exp
  ): attribute_type_aggregate!

  """fetch data from the table: "attribute_type" using primary key columns"""
  attribute_type_by_pk(value: String!): attribute_type

  """An array relationship"""
  attribute_values(
    """distinct select on columns"""
    distinct_on: [attribute_values_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_values_order_by!]

    """filter the rows returned"""
    where: attribute_values_bool_exp
  ): [attribute_values!]!

  """An aggregate relationship"""
  attribute_values_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_values_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_values_order_by!]

    """filter the rows returned"""
    where: attribute_values_bool_exp
  ): attribute_values_aggregate!

  """
  fetch data from the table: "attribute_values" using primary key columns
  """
  attribute_values_by_pk(id: uuid!): attribute_values

  """An array relationship"""
  attributes(
    """distinct select on columns"""
    distinct_on: [attributes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attributes_order_by!]

    """filter the rows returned"""
    where: attributes_bool_exp
  ): [attributes!]!

  """An aggregate relationship"""
  attributes_aggregate(
    """distinct select on columns"""
    distinct_on: [attributes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attributes_order_by!]

    """filter the rows returned"""
    where: attributes_bool_exp
  ): attributes_aggregate!

  """fetch data from the table: "attributes" using primary key columns"""
  attributes_by_pk(id: uuid!): attributes

  """
  fetch data from the table: "badges"
  """
  badges(
    """distinct select on columns"""
    distinct_on: [badges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [badges_order_by!]

    """filter the rows returned"""
    where: badges_bool_exp
  ): [badges!]!

  """
  fetch aggregated fields from the table: "badges"
  """
  badges_aggregate(
    """distinct select on columns"""
    distinct_on: [badges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [badges_order_by!]

    """filter the rows returned"""
    where: badges_bool_exp
  ): badges_aggregate!

  """fetch data from the table: "badges" using primary key columns"""
  badges_by_pk(name: String!): badges

  """
  fetch data from the table: "blocks"
  """
  blocks(
    """distinct select on columns"""
    distinct_on: [blocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blocks_order_by!]

    """filter the rows returned"""
    where: blocks_bool_exp
  ): [blocks!]!

  """
  fetch aggregated fields from the table: "blocks"
  """
  blocks_aggregate(
    """distinct select on columns"""
    distinct_on: [blocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blocks_order_by!]

    """filter the rows returned"""
    where: blocks_bool_exp
  ): blocks_aggregate!

  """fetch data from the table: "blocks" using primary key columns"""
  blocks_by_pk(blocked_id: uuid!, blocker_id: uuid!): blocks
  calculateOfferEarnings(offerEarningsInput: OfferEarningsInput!): OfferEarnings
  calculateOfferTotal(coverPartnerAuthentication: Boolean, offerTotalInput: OfferTotalInput!, offerTransactionType: OfferTransactionTypeInput, partnerInsuranceAmount: Int, partnerItemsCount: Int): OfferTotal
  calculateOfferTotalMany(offerTotalManyInput: [OfferTotalInput!]!, offerTransactionType: OfferTransactionTypeInput): OfferTotalMany
  closetValue(userId: String): ClosetValue

  """
  fetch data from the table: "communication_preference_groups"
  """
  communication_preference_groups(
    """distinct select on columns"""
    distinct_on: [communication_preference_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_preference_groups_order_by!]

    """filter the rows returned"""
    where: communication_preference_groups_bool_exp
  ): [communication_preference_groups!]!

  """
  fetch aggregated fields from the table: "communication_preference_groups"
  """
  communication_preference_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [communication_preference_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_preference_groups_order_by!]

    """filter the rows returned"""
    where: communication_preference_groups_bool_exp
  ): communication_preference_groups_aggregate!

  """
  fetch data from the table: "communication_preference_groups" using primary key columns
  """
  communication_preference_groups_by_pk(key: String!): communication_preference_groups

  """An array relationship"""
  communication_preferences(
    """distinct select on columns"""
    distinct_on: [communication_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_preferences_order_by!]

    """filter the rows returned"""
    where: communication_preferences_bool_exp
  ): [communication_preferences!]!

  """An aggregate relationship"""
  communication_preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [communication_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_preferences_order_by!]

    """filter the rows returned"""
    where: communication_preferences_bool_exp
  ): communication_preferences_aggregate!

  """
  fetch data from the table: "communication_preferences" using primary key columns
  """
  communication_preferences_by_pk(communication_preference_group_key: String!, user_preference_id: uuid!): communication_preferences

  """An array relationship"""
  communication_templates(
    """distinct select on columns"""
    distinct_on: [communication_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_templates_order_by!]

    """filter the rows returned"""
    where: communication_templates_bool_exp
  ): [communication_templates!]!

  """An aggregate relationship"""
  communication_templates_aggregate(
    """distinct select on columns"""
    distinct_on: [communication_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_templates_order_by!]

    """filter the rows returned"""
    where: communication_templates_bool_exp
  ): communication_templates_aggregate!

  """
  fetch data from the table: "communication_templates" using primary key columns
  """
  communication_templates_by_pk(key: String!): communication_templates
  connectedAccountBalance: StripeAccountBalance
  connectedAccountPayouts(limit: Int, startingAfter: String): StripeAccountPayouts
  connectedAccountStatus(returnUrl: String!): StripeAccountStatusResult

  """
  fetch data from the table: "currencies"
  """
  currencies(
    """distinct select on columns"""
    distinct_on: [currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currencies_order_by!]

    """filter the rows returned"""
    where: currencies_bool_exp
  ): [currencies!]!

  """
  fetch aggregated fields from the table: "currencies"
  """
  currencies_aggregate(
    """distinct select on columns"""
    distinct_on: [currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currencies_order_by!]

    """filter the rows returned"""
    where: currencies_bool_exp
  ): currencies_aggregate!

  """fetch data from the table: "currencies" using primary key columns"""
  currencies_by_pk(currency: String!): currencies

  """An array relationship"""
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """An aggregate relationship"""
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!

  """fetch data from the table: "devices" using primary key columns"""
  devices_by_pk(id: uuid!): devices

  """
  fetch data from the table: "files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "files"
  """
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """fetch data from the table: "files" using primary key columns"""
  files_by_pk(id: uuid!): files

  """
  fetch data from the table: "follows"
  """
  follows(
    """distinct select on columns"""
    distinct_on: [follows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [follows_order_by!]

    """filter the rows returned"""
    where: follows_bool_exp
  ): [follows!]!

  """
  fetch aggregated fields from the table: "follows"
  """
  follows_aggregate(
    """distinct select on columns"""
    distinct_on: [follows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [follows_order_by!]

    """filter the rows returned"""
    where: follows_bool_exp
  ): follows_aggregate!

  """fetch data from the table: "follows" using primary key columns"""
  follows_by_pk(follower_id: uuid!, following_id: uuid!): follows

  """
  fetch data from the table: "free_shipping_configuration"
  """
  free_shipping_configuration(
    """distinct select on columns"""
    distinct_on: [free_shipping_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [free_shipping_configuration_order_by!]

    """filter the rows returned"""
    where: free_shipping_configuration_bool_exp
  ): [free_shipping_configuration!]!

  """
  fetch aggregated fields from the table: "free_shipping_configuration"
  """
  free_shipping_configuration_aggregate(
    """distinct select on columns"""
    distinct_on: [free_shipping_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [free_shipping_configuration_order_by!]

    """filter the rows returned"""
    where: free_shipping_configuration_bool_exp
  ): free_shipping_configuration_aggregate!

  """
  fetch data from the table: "free_shipping_configuration" using primary key columns
  """
  free_shipping_configuration_by_pk(id: uuid!): free_shipping_configuration
  fullHealth: Health
  generateOfferIdeas(desiredReceiverItemsValue: Float!, desiredSizes: [String!]!, inventoryItemIds: [String!], maxCashWillingToAdd: Float!, premiums: [[Float!]!]): [OfferIdea]
  generateOfferIdeasPaginated(desiredReceiverItemsValue: Float!, desiredSizes: [String!]!, inventoryItemIds: [String!], limit: Int, maxCashWillingToAdd: Float!, offset: Int, premiums: [[Float!]!], receivingProductVariantIds: [String!]): OfferIdeasPaginated
  generateSmartOfferIdeas(existingCreatorItemsPairs: [SmartOfferIdeaCreatorInventoryPair!]!, key: String): SmartOfferIdeas
  generateUserOfferIdeasPaginated(exclusiveUserInventoryItemIds: Boolean, limit: Int!, maxCashWillingToAdd: Float!, offset: Int!, partnerId: String!, partnerInventoryItemIds: [String!]!, premiums: [[Float!]!], userInventoryItemIds: [String!]!): OfferIdeasPaginated
  getCollectorTradeStats(userId: String!): GetCollectorTradeStatsResponse

  """<p>Returns the Customer object.</p>"""
  getCustomer: Customer

  """<p>Returns a list of PaymentMethods for a given Customer</p>"""
  getCustomerPaymentMethods(limit: Int, startingAfter: String): CustomerPaymentMethodResourceList

  """
  <p>Returns a list of ExternalAccounts for a given Connected Account</p>
  """
  getExternalAccounts(limit: Int, startingAfter: String): ExternalAccountsResourceList
  getOfferTransactions(dateISO: String, mode: OfferTransactionMode!): OfferTransactions
  getRevertTradeSteps: GetRevertTradeStepsResponse
  health: Health

  """An array relationship"""
  inventory_items(
    """distinct select on columns"""
    distinct_on: [inventory_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_items_order_by!]

    """filter the rows returned"""
    where: inventory_items_bool_exp
  ): [inventory_items!]!

  """An aggregate relationship"""
  inventory_items_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_items_order_by!]

    """filter the rows returned"""
    where: inventory_items_bool_exp
  ): inventory_items_aggregate!

  """fetch data from the table: "inventory_items" using primary key columns"""
  inventory_items_by_pk(id: uuid!): inventory_items

  """
  fetch data from the table: "inventory_status"
  """
  inventory_status(
    """distinct select on columns"""
    distinct_on: [inventory_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_status_order_by!]

    """filter the rows returned"""
    where: inventory_status_bool_exp
  ): [inventory_status!]!

  """
  fetch aggregated fields from the table: "inventory_status"
  """
  inventory_status_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_status_order_by!]

    """filter the rows returned"""
    where: inventory_status_bool_exp
  ): inventory_status_aggregate!

  """
  fetch data from the table: "inventory_status" using primary key columns
  """
  inventory_status_by_pk(value: String!): inventory_status

  """
  fetch data from the table: "languages"
  """
  languages(
    """distinct select on columns"""
    distinct_on: [languages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [languages_order_by!]

    """filter the rows returned"""
    where: languages_bool_exp
  ): [languages!]!

  """
  fetch aggregated fields from the table: "languages"
  """
  languages_aggregate(
    """distinct select on columns"""
    distinct_on: [languages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [languages_order_by!]

    """filter the rows returned"""
    where: languages_bool_exp
  ): languages_aggregate!

  """fetch data from the table: "languages" using primary key columns"""
  languages_by_pk(code: String!): languages

  """
  fetch data from the table: "march_mania_bracket"
  """
  march_mania_bracket(
    """distinct select on columns"""
    distinct_on: [march_mania_bracket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [march_mania_bracket_order_by!]

    """filter the rows returned"""
    where: march_mania_bracket_bool_exp
  ): [march_mania_bracket!]!

  """
  fetch aggregated fields from the table: "march_mania_bracket"
  """
  march_mania_bracket_aggregate(
    """distinct select on columns"""
    distinct_on: [march_mania_bracket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [march_mania_bracket_order_by!]

    """filter the rows returned"""
    where: march_mania_bracket_bool_exp
  ): march_mania_bracket_aggregate!

  """
  fetch data from the table: "march_mania_bracket" using primary key columns
  """
  march_mania_bracket_by_pk(id: uuid!): march_mania_bracket

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: uuid!): notifications

  """An array relationship"""
  offer_checkouts(
    """distinct select on columns"""
    distinct_on: [offer_checkouts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_checkouts_order_by!]

    """filter the rows returned"""
    where: offer_checkouts_bool_exp
  ): [offer_checkouts!]!

  """An aggregate relationship"""
  offer_checkouts_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_checkouts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_checkouts_order_by!]

    """filter the rows returned"""
    where: offer_checkouts_bool_exp
  ): offer_checkouts_aggregate!

  """fetch data from the table: "offer_checkouts" using primary key columns"""
  offer_checkouts_by_pk(id: uuid!): offer_checkouts

  """
  fetch data from the table: "offer_item_issue_offer_item_issue_types"
  """
  offer_item_issue_offer_item_issue_types(
    """distinct select on columns"""
    distinct_on: [offer_item_issue_offer_item_issue_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_issue_offer_item_issue_types_order_by!]

    """filter the rows returned"""
    where: offer_item_issue_offer_item_issue_types_bool_exp
  ): [offer_item_issue_offer_item_issue_types!]!

  """
  fetch aggregated fields from the table: "offer_item_issue_offer_item_issue_types"
  """
  offer_item_issue_offer_item_issue_types_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_item_issue_offer_item_issue_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_issue_offer_item_issue_types_order_by!]

    """filter the rows returned"""
    where: offer_item_issue_offer_item_issue_types_bool_exp
  ): offer_item_issue_offer_item_issue_types_aggregate!

  """
  fetch data from the table: "offer_item_issue_offer_item_issue_types" using primary key columns
  """
  offer_item_issue_offer_item_issue_types_by_pk(issue_id: uuid!, issue_type: String!): offer_item_issue_offer_item_issue_types

  """
  fetch data from the table: "offer_item_owners"
  """
  offer_item_owners(
    """distinct select on columns"""
    distinct_on: [offer_item_owners_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_owners_order_by!]

    """filter the rows returned"""
    where: offer_item_owners_bool_exp
  ): [offer_item_owners!]!

  """
  fetch aggregated fields from the table: "offer_item_owners"
  """
  offer_item_owners_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_item_owners_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_owners_order_by!]

    """filter the rows returned"""
    where: offer_item_owners_bool_exp
  ): offer_item_owners_aggregate!

  """
  fetch data from the table: "offer_item_owners" using primary key columns
  """
  offer_item_owners_by_pk(owner: String!): offer_item_owners

  """An array relationship"""
  offer_item_shipments(
    """distinct select on columns"""
    distinct_on: [offer_item_shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_shipments_order_by!]

    """filter the rows returned"""
    where: offer_item_shipments_bool_exp
  ): [offer_item_shipments!]!

  """An aggregate relationship"""
  offer_item_shipments_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_item_shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_shipments_order_by!]

    """filter the rows returned"""
    where: offer_item_shipments_bool_exp
  ): offer_item_shipments_aggregate!

  """
  fetch data from the table: "offer_item_shipments" using primary key columns
  """
  offer_item_shipments_by_pk(offer_item_id: uuid!, shipment_id: uuid!): offer_item_shipments

  """An array relationship"""
  offer_items(
    """distinct select on columns"""
    distinct_on: [offer_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_order_by!]

    """filter the rows returned"""
    where: offer_items_bool_exp
  ): [offer_items!]!

  """An aggregate relationship"""
  offer_items_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_order_by!]

    """filter the rows returned"""
    where: offer_items_bool_exp
  ): offer_items_aggregate!

  """fetch data from the table: "offer_items" using primary key columns"""
  offer_items_by_pk(id: uuid!): offer_items

  """An array relationship"""
  offer_items_issues(
    """distinct select on columns"""
    distinct_on: [offer_items_issues_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_issues_order_by!]

    """filter the rows returned"""
    where: offer_items_issues_bool_exp
  ): [offer_items_issues!]!

  """An aggregate relationship"""
  offer_items_issues_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_items_issues_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_issues_order_by!]

    """filter the rows returned"""
    where: offer_items_issues_bool_exp
  ): offer_items_issues_aggregate!

  """
  fetch data from the table: "offer_items_issues" using primary key columns
  """
  offer_items_issues_by_pk(id: uuid!): offer_items_issues

  """
  fetch data from the table: "offer_statuses"
  """
  offer_statuses(
    """distinct select on columns"""
    distinct_on: [offer_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_statuses_order_by!]

    """filter the rows returned"""
    where: offer_statuses_bool_exp
  ): [offer_statuses!]!

  """
  fetch aggregated fields from the table: "offer_statuses"
  """
  offer_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_statuses_order_by!]

    """filter the rows returned"""
    where: offer_statuses_bool_exp
  ): offer_statuses_aggregate!

  """fetch data from the table: "offer_statuses" using primary key columns"""
  offer_statuses_by_pk(status: String!): offer_statuses

  """
  fetch data from the table: "offer_transaction_types"
  """
  offer_transaction_types(
    """distinct select on columns"""
    distinct_on: [offer_transaction_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_transaction_types_order_by!]

    """filter the rows returned"""
    where: offer_transaction_types_bool_exp
  ): [offer_transaction_types!]!

  """
  fetch aggregated fields from the table: "offer_transaction_types"
  """
  offer_transaction_types_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_transaction_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_transaction_types_order_by!]

    """filter the rows returned"""
    where: offer_transaction_types_bool_exp
  ): offer_transaction_types_aggregate!

  """
  fetch data from the table: "offer_transaction_types" using primary key columns
  """
  offer_transaction_types_by_pk(transaction_type: String!): offer_transaction_types

  """
  fetch data from the table: "offer_types"
  """
  offer_types(
    """distinct select on columns"""
    distinct_on: [offer_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_types_order_by!]

    """filter the rows returned"""
    where: offer_types_bool_exp
  ): [offer_types!]!

  """
  fetch aggregated fields from the table: "offer_types"
  """
  offer_types_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_types_order_by!]

    """filter the rows returned"""
    where: offer_types_bool_exp
  ): offer_types_aggregate!

  """fetch data from the table: "offer_types" using primary key columns"""
  offer_types_by_pk(type: String!): offer_types

  """
  fetch data from the table: "offers"
  """
  offers(
    """distinct select on columns"""
    distinct_on: [offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offers_order_by!]

    """filter the rows returned"""
    where: offers_bool_exp
  ): [offers!]!

  """
  fetch aggregated fields from the table: "offers"
  """
  offers_aggregate(
    """distinct select on columns"""
    distinct_on: [offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offers_order_by!]

    """filter the rows returned"""
    where: offers_bool_exp
  ): offers_aggregate!

  """fetch data from the table: "offers" using primary key columns"""
  offers_by_pk(id: uuid!): offers

  """
  fetch data from the table: "payment_transactions"
  """
  payment_transactions(
    """distinct select on columns"""
    distinct_on: [payment_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_transactions_order_by!]

    """filter the rows returned"""
    where: payment_transactions_bool_exp
  ): [payment_transactions!]!

  """
  fetch aggregated fields from the table: "payment_transactions"
  """
  payment_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_transactions_order_by!]

    """filter the rows returned"""
    where: payment_transactions_bool_exp
  ): payment_transactions_aggregate!

  """
  fetch data from the table: "payment_transactions" using primary key columns
  """
  payment_transactions_by_pk(id: uuid!): payment_transactions

  """
  fetch data from the table: "price_report"
  """
  price_report(
    """distinct select on columns"""
    distinct_on: [price_report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [price_report_order_by!]

    """filter the rows returned"""
    where: price_report_bool_exp
  ): [price_report!]!

  """
  fetch aggregated fields from the table: "price_report"
  """
  price_report_aggregate(
    """distinct select on columns"""
    distinct_on: [price_report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [price_report_order_by!]

    """filter the rows returned"""
    where: price_report_bool_exp
  ): price_report_aggregate!

  """fetch data from the table: "price_report" using primary key columns"""
  price_report_by_pk(id: uuid!): price_report

  """
  fetch data from the table: "product_promo_configuration"
  """
  product_promo_configuration(
    """distinct select on columns"""
    distinct_on: [product_promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_promo_configuration_order_by!]

    """filter the rows returned"""
    where: product_promo_configuration_bool_exp
  ): [product_promo_configuration!]!

  """
  fetch aggregated fields from the table: "product_promo_configuration"
  """
  product_promo_configuration_aggregate(
    """distinct select on columns"""
    distinct_on: [product_promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_promo_configuration_order_by!]

    """filter the rows returned"""
    where: product_promo_configuration_bool_exp
  ): product_promo_configuration_aggregate!

  """
  fetch data from the table: "product_promo_configuration" using primary key columns
  """
  product_promo_configuration_by_pk(product_id: uuid!, promo_configuration_id: uuid!): product_promo_configuration

  """An array relationship"""
  product_variants(
    """distinct select on columns"""
    distinct_on: [product_variants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_variants_order_by!]

    """filter the rows returned"""
    where: product_variants_bool_exp
  ): [product_variants!]!

  """An aggregate relationship"""
  product_variants_aggregate(
    """distinct select on columns"""
    distinct_on: [product_variants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_variants_order_by!]

    """filter the rows returned"""
    where: product_variants_bool_exp
  ): product_variants_aggregate!

  """
  fetch data from the table: "product_variants" using primary key columns
  """
  product_variants_by_pk(id: uuid!): product_variants

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): products_aggregate!

  """fetch data from the table: "products" using primary key columns"""
  products_by_pk(id: uuid!): products

  """
  fetch data from the table: "promo_configuration"
  """
  promo_configuration(
    """distinct select on columns"""
    distinct_on: [promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [promo_configuration_order_by!]

    """filter the rows returned"""
    where: promo_configuration_bool_exp
  ): [promo_configuration!]!

  """
  fetch aggregated fields from the table: "promo_configuration"
  """
  promo_configuration_aggregate(
    """distinct select on columns"""
    distinct_on: [promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [promo_configuration_order_by!]

    """filter the rows returned"""
    where: promo_configuration_bool_exp
  ): promo_configuration_aggregate!

  """
  fetch data from the table: "promo_configuration" using primary key columns
  """
  promo_configuration_by_pk(id: uuid!): promo_configuration

  """
  fetch data from the table: "promo_configuration_name"
  """
  promo_configuration_name(
    """distinct select on columns"""
    distinct_on: [promo_configuration_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [promo_configuration_name_order_by!]

    """filter the rows returned"""
    where: promo_configuration_name_bool_exp
  ): [promo_configuration_name!]!

  """
  fetch aggregated fields from the table: "promo_configuration_name"
  """
  promo_configuration_name_aggregate(
    """distinct select on columns"""
    distinct_on: [promo_configuration_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [promo_configuration_name_order_by!]

    """filter the rows returned"""
    where: promo_configuration_name_bool_exp
  ): promo_configuration_name_aggregate!

  """
  fetch data from the table: "promo_configuration_name" using primary key columns
  """
  promo_configuration_name_by_pk(name: String!): promo_configuration_name

  """
  fetch data from the table: "report_categories"
  """
  report_categories(
    """distinct select on columns"""
    distinct_on: [report_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_categories_order_by!]

    """filter the rows returned"""
    where: report_categories_bool_exp
  ): [report_categories!]!

  """
  fetch aggregated fields from the table: "report_categories"
  """
  report_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [report_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_categories_order_by!]

    """filter the rows returned"""
    where: report_categories_bool_exp
  ): report_categories_aggregate!

  """
  fetch data from the table: "report_categories" using primary key columns
  """
  report_categories_by_pk(key: String!): report_categories

  """An array relationship"""
  reports(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """An aggregate relationship"""
  reports_aggregate(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): reports_aggregate!

  """fetch data from the table: "reports" using primary key columns"""
  reports_by_pk(categoryKey: report_categories_enum!, reported_id: uuid!, reporter_id: uuid!): reports

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(name: String!): roles

  """An array relationship"""
  shipments(
    """distinct select on columns"""
    distinct_on: [shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipments_order_by!]

    """filter the rows returned"""
    where: shipments_bool_exp
  ): [shipments!]!

  """An aggregate relationship"""
  shipments_aggregate(
    """distinct select on columns"""
    distinct_on: [shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipments_order_by!]

    """filter the rows returned"""
    where: shipments_bool_exp
  ): shipments_aggregate!

  """fetch data from the table: "shipments" using primary key columns"""
  shipments_by_pk(id: uuid!): shipments
  status: Status
  strapi: strapiQuery

  """An array relationship"""
  trade_state_updates(
    """distinct select on columns"""
    distinct_on: [trade_state_updates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_state_updates_order_by!]

    """filter the rows returned"""
    where: trade_state_updates_bool_exp
  ): [trade_state_updates!]!

  """An aggregate relationship"""
  trade_state_updates_aggregate(
    """distinct select on columns"""
    distinct_on: [trade_state_updates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_state_updates_order_by!]

    """filter the rows returned"""
    where: trade_state_updates_bool_exp
  ): trade_state_updates_aggregate!

  """
  fetch data from the table: "trade_state_updates" using primary key columns
  """
  trade_state_updates_by_pk(id: uuid!): trade_state_updates

  """
  fetch data from the table: "trades"
  """
  trades(
    """distinct select on columns"""
    distinct_on: [trades_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trades_order_by!]

    """filter the rows returned"""
    where: trades_bool_exp
  ): [trades!]!

  """
  fetch aggregated fields from the table: "trades"
  """
  trades_aggregate(
    """distinct select on columns"""
    distinct_on: [trades_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trades_order_by!]

    """filter the rows returned"""
    where: trades_bool_exp
  ): trades_aggregate!

  """fetch data from the table: "trades" using primary key columns"""
  trades_by_pk(id: uuid!): trades

  """
  fetch data from the table: "user_activities"
  """
  user_activities(
    """distinct select on columns"""
    distinct_on: [user_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_activities_order_by!]

    """filter the rows returned"""
    where: user_activities_bool_exp
  ): [user_activities!]!

  """
  fetch aggregated fields from the table: "user_activities"
  """
  user_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [user_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_activities_order_by!]

    """filter the rows returned"""
    where: user_activities_bool_exp
  ): user_activities_aggregate!

  """fetch data from the table: "user_activities" using primary key columns"""
  user_activities_by_pk(id: uuid!): user_activities

  """
  fetch data from the table: "user_admin_informations"
  """
  user_admin_informations(
    """distinct select on columns"""
    distinct_on: [user_admin_informations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_admin_informations_order_by!]

    """filter the rows returned"""
    where: user_admin_informations_bool_exp
  ): [user_admin_informations!]!

  """
  fetch aggregated fields from the table: "user_admin_informations"
  """
  user_admin_informations_aggregate(
    """distinct select on columns"""
    distinct_on: [user_admin_informations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_admin_informations_order_by!]

    """filter the rows returned"""
    where: user_admin_informations_bool_exp
  ): user_admin_informations_aggregate!

  """
  fetch data from the table: "user_admin_informations" using primary key columns
  """
  user_admin_informations_by_pk(id: uuid!): user_admin_informations

  """An array relationship"""
  user_badges(
    """distinct select on columns"""
    distinct_on: [user_badges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_badges_order_by!]

    """filter the rows returned"""
    where: user_badges_bool_exp
  ): [user_badges!]!

  """An aggregate relationship"""
  user_badges_aggregate(
    """distinct select on columns"""
    distinct_on: [user_badges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_badges_order_by!]

    """filter the rows returned"""
    where: user_badges_bool_exp
  ): user_badges_aggregate!

  """fetch data from the table: "user_badges" using primary key columns"""
  user_badges_by_pk(badge_name: badges_enum!, user_id: uuid!): user_badges

  """An array relationship"""
  user_notifications(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): [user_notifications!]!

  """An aggregate relationship"""
  user_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): user_notifications_aggregate!

  """
  fetch data from the table: "user_notifications" using primary key columns
  """
  user_notifications_by_pk(notification_id: uuid!, notified_id: uuid!): user_notifications

  """
  fetch data from the table: "user_preferences"
  """
  user_preferences(
    """distinct select on columns"""
    distinct_on: [user_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_preferences_order_by!]

    """filter the rows returned"""
    where: user_preferences_bool_exp
  ): [user_preferences!]!

  """
  fetch aggregated fields from the table: "user_preferences"
  """
  user_preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [user_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_preferences_order_by!]

    """filter the rows returned"""
    where: user_preferences_bool_exp
  ): user_preferences_aggregate!

  """
  fetch data from the table: "user_preferences" using primary key columns
  """
  user_preferences_by_pk(id: uuid!): user_preferences

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users

  """
  fetch data from the table: "validators"
  """
  validators(
    """distinct select on columns"""
    distinct_on: [validators_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validators_order_by!]

    """filter the rows returned"""
    where: validators_bool_exp
  ): [validators!]!

  """
  fetch aggregated fields from the table: "validators"
  """
  validators_aggregate(
    """distinct select on columns"""
    distinct_on: [validators_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validators_order_by!]

    """filter the rows returned"""
    where: validators_bool_exp
  ): validators_aggregate!

  """fetch data from the table: "validators" using primary key columns"""
  validators_by_pk(id: uuid!): validators

  """An array relationship"""
  wishlist_items(
    """distinct select on columns"""
    distinct_on: [wishlist_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlist_items_order_by!]

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): [wishlist_items!]!

  """An aggregate relationship"""
  wishlist_items_aggregate(
    """distinct select on columns"""
    distinct_on: [wishlist_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlist_items_order_by!]

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): wishlist_items_aggregate!

  """fetch data from the table: "wishlist_items" using primary key columns"""
  wishlist_items_by_pk(id: uuid!): wishlist_items
}

"""Possible categories for reports."""
type report_categories {
  key: String!

  """An array relationship"""
  reports(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """An aggregate relationship"""
  reports_aggregate(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): reports_aggregate!
}

"""
aggregated selection of "report_categories"
"""
type report_categories_aggregate {
  aggregate: report_categories_aggregate_fields
  nodes: [report_categories!]!
}

"""
aggregate fields of "report_categories"
"""
type report_categories_aggregate_fields {
  count(columns: [report_categories_select_column!], distinct: Boolean): Int!
  max: report_categories_max_fields
  min: report_categories_min_fields
}

"""
Boolean expression to filter rows from the table "report_categories". All fields are combined with a logical 'AND'.
"""
input report_categories_bool_exp {
  _and: [report_categories_bool_exp!]
  _not: report_categories_bool_exp
  _or: [report_categories_bool_exp!]
  key: String_comparison_exp
  reports: reports_bool_exp
  reports_aggregate: reports_aggregate_bool_exp
}

"""
unique or primary key constraints on table "report_categories"
"""
enum report_categories_constraint {
  """
  unique or primary key constraint on columns "key"
  """
  report_categories_pkey
}

enum report_categories_enum {
  HARASSING_MESSAGES
  INAPPROPRIATE
  POOR_NEGOTIATION
  SPAMMING
}

"""
Boolean expression to compare columns of type "report_categories_enum". All fields are combined with logical 'AND'.
"""
input report_categories_enum_comparison_exp {
  _eq: report_categories_enum
  _in: [report_categories_enum!]
  _is_null: Boolean
  _neq: report_categories_enum
  _nin: [report_categories_enum!]
}

"""
input type for inserting data into table "report_categories"
"""
input report_categories_insert_input {
  key: String
  reports: reports_arr_rel_insert_input
}

"""aggregate max on columns"""
type report_categories_max_fields {
  key: String
}

"""aggregate min on columns"""
type report_categories_min_fields {
  key: String
}

"""
response of any mutation on the table "report_categories"
"""
type report_categories_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [report_categories!]!
}

"""
input type for inserting object relation for remote table "report_categories"
"""
input report_categories_obj_rel_insert_input {
  data: report_categories_insert_input!

  """upsert condition"""
  on_conflict: report_categories_on_conflict
}

"""
on_conflict condition type for table "report_categories"
"""
input report_categories_on_conflict {
  constraint: report_categories_constraint!
  update_columns: [report_categories_update_column!]! = []
  where: report_categories_bool_exp
}

"""Ordering options when selecting data from "report_categories"."""
input report_categories_order_by {
  key: order_by
  reports_aggregate: reports_aggregate_order_by
}

"""primary key columns input for table: report_categories"""
input report_categories_pk_columns_input {
  key: String!
}

"""
select columns of table "report_categories"
"""
enum report_categories_select_column {
  """column name"""
  key
}

"""
input type for updating data in table "report_categories"
"""
input report_categories_set_input {
  key: String
}

"""
Streaming cursor of the table "report_categories"
"""
input report_categories_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: report_categories_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input report_categories_stream_cursor_value_input {
  key: String
}

"""
update columns of table "report_categories"
"""
enum report_categories_update_column {
  """column name"""
  key
}

input report_categories_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: report_categories_set_input

  """filter the rows which have to be updated"""
  where: report_categories_bool_exp!
}

"""Holds reported users and their reporters."""
type reports {
  """An object relationship"""
  category: report_categories!
  categoryKey: report_categories_enum!
  comment: String

  """An object relationship"""
  reportedUser: users!
  reported_id: uuid!

  """An object relationship"""
  reporterUser: users!
  reporter_id: uuid!
}

"""
aggregated selection of "reports"
"""
type reports_aggregate {
  aggregate: reports_aggregate_fields
  nodes: [reports!]!
}

input reports_aggregate_bool_exp {
  count: reports_aggregate_bool_exp_count
}

input reports_aggregate_bool_exp_count {
  arguments: [reports_select_column!]
  distinct: Boolean
  filter: reports_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "reports"
"""
type reports_aggregate_fields {
  count(columns: [reports_select_column!], distinct: Boolean): Int!
  max: reports_max_fields
  min: reports_min_fields
}

"""
order by aggregate values of table "reports"
"""
input reports_aggregate_order_by {
  count: order_by
  max: reports_max_order_by
  min: reports_min_order_by
}

"""
input type for inserting array relation for remote table "reports"
"""
input reports_arr_rel_insert_input {
  data: [reports_insert_input!]!

  """upsert condition"""
  on_conflict: reports_on_conflict
}

"""
Boolean expression to filter rows from the table "reports". All fields are combined with a logical 'AND'.
"""
input reports_bool_exp {
  _and: [reports_bool_exp!]
  _not: reports_bool_exp
  _or: [reports_bool_exp!]
  category: report_categories_bool_exp
  categoryKey: report_categories_enum_comparison_exp
  comment: String_comparison_exp
  reportedUser: users_bool_exp
  reported_id: uuid_comparison_exp
  reporterUser: users_bool_exp
  reporter_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "reports"
"""
enum reports_constraint {
  """
  unique or primary key constraint on columns "categoryKey", "reporter_id", "reported_id"
  """
  reports_pkey
}

"""
input type for inserting data into table "reports"
"""
input reports_insert_input {
  category: report_categories_obj_rel_insert_input
  categoryKey: report_categories_enum
  comment: String
  reportedUser: users_obj_rel_insert_input
  reported_id: uuid
  reporterUser: users_obj_rel_insert_input
  reporter_id: uuid
}

"""aggregate max on columns"""
type reports_max_fields {
  comment: String
  reported_id: uuid
  reporter_id: uuid
}

"""
order by max() on columns of table "reports"
"""
input reports_max_order_by {
  comment: order_by
  reported_id: order_by
  reporter_id: order_by
}

"""aggregate min on columns"""
type reports_min_fields {
  comment: String
  reported_id: uuid
  reporter_id: uuid
}

"""
order by min() on columns of table "reports"
"""
input reports_min_order_by {
  comment: order_by
  reported_id: order_by
  reporter_id: order_by
}

"""
response of any mutation on the table "reports"
"""
type reports_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [reports!]!
}

"""
on_conflict condition type for table "reports"
"""
input reports_on_conflict {
  constraint: reports_constraint!
  update_columns: [reports_update_column!]! = []
  where: reports_bool_exp
}

"""Ordering options when selecting data from "reports"."""
input reports_order_by {
  category: report_categories_order_by
  categoryKey: order_by
  comment: order_by
  reportedUser: users_order_by
  reported_id: order_by
  reporterUser: users_order_by
  reporter_id: order_by
}

"""primary key columns input for table: reports"""
input reports_pk_columns_input {
  categoryKey: report_categories_enum!
  reported_id: uuid!
  reporter_id: uuid!
}

"""
select columns of table "reports"
"""
enum reports_select_column {
  """column name"""
  categoryKey

  """column name"""
  comment

  """column name"""
  reported_id

  """column name"""
  reporter_id
}

"""
input type for updating data in table "reports"
"""
input reports_set_input {
  categoryKey: report_categories_enum
  comment: String
  reported_id: uuid
  reporter_id: uuid
}

"""
Streaming cursor of the table "reports"
"""
input reports_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: reports_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input reports_stream_cursor_value_input {
  categoryKey: report_categories_enum
  comment: String
  reported_id: uuid
  reporter_id: uuid
}

"""
update columns of table "reports"
"""
enum reports_update_column {
  """column name"""
  categoryKey

  """column name"""
  comment

  """column name"""
  reported_id

  """column name"""
  reporter_id
}

input reports_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: reports_set_input

  """filter the rows which have to be updated"""
  where: reports_bool_exp!
}

"""Roles a user may have."""
type roles {
  name: String!
}

"""
aggregated selection of "roles"
"""
type roles_aggregate {
  aggregate: roles_aggregate_fields
  nodes: [roles!]!
}

"""
aggregate fields of "roles"
"""
type roles_aggregate_fields {
  count(columns: [roles_select_column!], distinct: Boolean): Int!
  max: roles_max_fields
  min: roles_min_fields
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input roles_bool_exp {
  _and: [roles_bool_exp!]
  _not: roles_bool_exp
  _or: [roles_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "roles"
"""
enum roles_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  roles_pkey
}

enum roles_enum {
  collector
  frozen
  validator
}

"""
Boolean expression to compare columns of type "roles_enum". All fields are combined with logical 'AND'.
"""
input roles_enum_comparison_exp {
  _eq: roles_enum
  _in: [roles_enum!]
  _is_null: Boolean
  _neq: roles_enum
  _nin: [roles_enum!]
}

"""
input type for inserting data into table "roles"
"""
input roles_insert_input {
  name: String
}

"""aggregate max on columns"""
type roles_max_fields {
  name: String
}

"""aggregate min on columns"""
type roles_min_fields {
  name: String
}

"""
response of any mutation on the table "roles"
"""
type roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [roles!]!
}

"""
on_conflict condition type for table "roles"
"""
input roles_on_conflict {
  constraint: roles_constraint!
  update_columns: [roles_update_column!]! = []
  where: roles_bool_exp
}

"""Ordering options when selecting data from "roles"."""
input roles_order_by {
  name: order_by
}

"""primary key columns input for table: roles"""
input roles_pk_columns_input {
  name: String!
}

"""
select columns of table "roles"
"""
enum roles_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "roles"
"""
input roles_set_input {
  name: String
}

"""
Streaming cursor of the table "roles"
"""
input roles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: roles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input roles_stream_cursor_value_input {
  name: String
}

"""
update columns of table "roles"
"""
enum roles_update_column {
  """column name"""
  name
}

input roles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: roles_set_input

  """filter the rows which have to be updated"""
  where: roles_bool_exp!
}

"""
columns and relationships of "shipments"
"""
type shipments {
  """An object relationship"""
  box_up_validator: validators
  boxed_up_date: timestamptz
  boxed_up_date_validator_id: uuid

  """An object relationship"""
  check_in_validator: validators
  checked_in_date: timestamptz
  checked_in_date_validator_id: uuid
  created_at: timestamptz!
  deleted_at: Int!
  delivered_date: timestamptz
  estimated_delivery_date: timestamptz
  id: uuid!

  """An object relationship"""
  offer_checkout: offer_checkouts!
  offer_checkout_id: uuid!

  """An array relationship"""
  offer_item_shipments(
    """distinct select on columns"""
    distinct_on: [offer_item_shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_shipments_order_by!]

    """filter the rows returned"""
    where: offer_item_shipments_bool_exp
  ): [offer_item_shipments!]!

  """An aggregate relationship"""
  offer_item_shipments_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_item_shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_shipments_order_by!]

    """filter the rows returned"""
    where: offer_item_shipments_bool_exp
  ): offer_item_shipments_aggregate!
  picked_up_date: timestamptz
  picked_up_date_validator_id: uuid

  """An array relationship"""
  pictures(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  pictures_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """An object relationship"""
  review_validator: validators
  sent_date: timestamptz
  shipment_destination: String!
  shipment_status: String!
  shipping_label_link: String
  tracking_link: String
  tracking_number: String
  transaction_id: String
  updated_at: timestamptz!
  user_shipping_expiration_date: timestamptz
  validator_review_submit_date: timestamptz
  validator_review_submit_date_validator_id: uuid
}

"""
aggregated selection of "shipments"
"""
type shipments_aggregate {
  aggregate: shipments_aggregate_fields
  nodes: [shipments!]!
}

input shipments_aggregate_bool_exp {
  count: shipments_aggregate_bool_exp_count
}

input shipments_aggregate_bool_exp_count {
  arguments: [shipments_select_column!]
  distinct: Boolean
  filter: shipments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "shipments"
"""
type shipments_aggregate_fields {
  avg: shipments_avg_fields
  count(columns: [shipments_select_column!], distinct: Boolean): Int!
  max: shipments_max_fields
  min: shipments_min_fields
  stddev: shipments_stddev_fields
  stddev_pop: shipments_stddev_pop_fields
  stddev_samp: shipments_stddev_samp_fields
  sum: shipments_sum_fields
  var_pop: shipments_var_pop_fields
  var_samp: shipments_var_samp_fields
  variance: shipments_variance_fields
}

"""
order by aggregate values of table "shipments"
"""
input shipments_aggregate_order_by {
  avg: shipments_avg_order_by
  count: order_by
  max: shipments_max_order_by
  min: shipments_min_order_by
  stddev: shipments_stddev_order_by
  stddev_pop: shipments_stddev_pop_order_by
  stddev_samp: shipments_stddev_samp_order_by
  sum: shipments_sum_order_by
  var_pop: shipments_var_pop_order_by
  var_samp: shipments_var_samp_order_by
  variance: shipments_variance_order_by
}

"""
input type for inserting array relation for remote table "shipments"
"""
input shipments_arr_rel_insert_input {
  data: [shipments_insert_input!]!

  """upsert condition"""
  on_conflict: shipments_on_conflict
}

"""aggregate avg on columns"""
type shipments_avg_fields {
  deleted_at: Float
}

"""
order by avg() on columns of table "shipments"
"""
input shipments_avg_order_by {
  deleted_at: order_by
}

"""
Boolean expression to filter rows from the table "shipments". All fields are combined with a logical 'AND'.
"""
input shipments_bool_exp {
  _and: [shipments_bool_exp!]
  _not: shipments_bool_exp
  _or: [shipments_bool_exp!]
  box_up_validator: validators_bool_exp
  boxed_up_date: timestamptz_comparison_exp
  boxed_up_date_validator_id: uuid_comparison_exp
  check_in_validator: validators_bool_exp
  checked_in_date: timestamptz_comparison_exp
  checked_in_date_validator_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  delivered_date: timestamptz_comparison_exp
  estimated_delivery_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  offer_checkout: offer_checkouts_bool_exp
  offer_checkout_id: uuid_comparison_exp
  offer_item_shipments: offer_item_shipments_bool_exp
  offer_item_shipments_aggregate: offer_item_shipments_aggregate_bool_exp
  picked_up_date: timestamptz_comparison_exp
  picked_up_date_validator_id: uuid_comparison_exp
  pictures: files_bool_exp
  pictures_aggregate: files_aggregate_bool_exp
  review_validator: validators_bool_exp
  sent_date: timestamptz_comparison_exp
  shipment_destination: String_comparison_exp
  shipment_status: String_comparison_exp
  shipping_label_link: String_comparison_exp
  tracking_link: String_comparison_exp
  tracking_number: String_comparison_exp
  transaction_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_shipping_expiration_date: timestamptz_comparison_exp
  validator_review_submit_date: timestamptz_comparison_exp
  validator_review_submit_date_validator_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "shipments"
"""
enum shipments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  shipments_pkey

  """
  unique or primary key constraint on columns "transaction_id"
  """
  shipments_transaction_id_key
}

"""
input type for incrementing numeric columns in table "shipments"
"""
input shipments_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "shipments"
"""
input shipments_insert_input {
  box_up_validator: validators_obj_rel_insert_input
  boxed_up_date: timestamptz
  boxed_up_date_validator_id: uuid
  check_in_validator: validators_obj_rel_insert_input
  checked_in_date: timestamptz
  checked_in_date_validator_id: uuid
  created_at: timestamptz
  deleted_at: Int
  delivered_date: timestamptz
  estimated_delivery_date: timestamptz
  id: uuid
  offer_checkout: offer_checkouts_obj_rel_insert_input
  offer_checkout_id: uuid
  offer_item_shipments: offer_item_shipments_arr_rel_insert_input
  picked_up_date: timestamptz
  picked_up_date_validator_id: uuid
  pictures: files_arr_rel_insert_input
  review_validator: validators_obj_rel_insert_input
  sent_date: timestamptz
  shipment_destination: String
  shipment_status: String
  shipping_label_link: String
  tracking_link: String
  tracking_number: String
  transaction_id: String
  updated_at: timestamptz
  user_shipping_expiration_date: timestamptz
  validator_review_submit_date: timestamptz
  validator_review_submit_date_validator_id: uuid
}

"""aggregate max on columns"""
type shipments_max_fields {
  boxed_up_date: timestamptz
  boxed_up_date_validator_id: uuid
  checked_in_date: timestamptz
  checked_in_date_validator_id: uuid
  created_at: timestamptz
  deleted_at: Int
  delivered_date: timestamptz
  estimated_delivery_date: timestamptz
  id: uuid
  offer_checkout_id: uuid
  picked_up_date: timestamptz
  picked_up_date_validator_id: uuid
  sent_date: timestamptz
  shipment_destination: String
  shipment_status: String
  shipping_label_link: String
  tracking_link: String
  tracking_number: String
  transaction_id: String
  updated_at: timestamptz
  user_shipping_expiration_date: timestamptz
  validator_review_submit_date: timestamptz
  validator_review_submit_date_validator_id: uuid
}

"""
order by max() on columns of table "shipments"
"""
input shipments_max_order_by {
  boxed_up_date: order_by
  boxed_up_date_validator_id: order_by
  checked_in_date: order_by
  checked_in_date_validator_id: order_by
  created_at: order_by
  deleted_at: order_by
  delivered_date: order_by
  estimated_delivery_date: order_by
  id: order_by
  offer_checkout_id: order_by
  picked_up_date: order_by
  picked_up_date_validator_id: order_by
  sent_date: order_by
  shipment_destination: order_by
  shipment_status: order_by
  shipping_label_link: order_by
  tracking_link: order_by
  tracking_number: order_by
  transaction_id: order_by
  updated_at: order_by
  user_shipping_expiration_date: order_by
  validator_review_submit_date: order_by
  validator_review_submit_date_validator_id: order_by
}

"""aggregate min on columns"""
type shipments_min_fields {
  boxed_up_date: timestamptz
  boxed_up_date_validator_id: uuid
  checked_in_date: timestamptz
  checked_in_date_validator_id: uuid
  created_at: timestamptz
  deleted_at: Int
  delivered_date: timestamptz
  estimated_delivery_date: timestamptz
  id: uuid
  offer_checkout_id: uuid
  picked_up_date: timestamptz
  picked_up_date_validator_id: uuid
  sent_date: timestamptz
  shipment_destination: String
  shipment_status: String
  shipping_label_link: String
  tracking_link: String
  tracking_number: String
  transaction_id: String
  updated_at: timestamptz
  user_shipping_expiration_date: timestamptz
  validator_review_submit_date: timestamptz
  validator_review_submit_date_validator_id: uuid
}

"""
order by min() on columns of table "shipments"
"""
input shipments_min_order_by {
  boxed_up_date: order_by
  boxed_up_date_validator_id: order_by
  checked_in_date: order_by
  checked_in_date_validator_id: order_by
  created_at: order_by
  deleted_at: order_by
  delivered_date: order_by
  estimated_delivery_date: order_by
  id: order_by
  offer_checkout_id: order_by
  picked_up_date: order_by
  picked_up_date_validator_id: order_by
  sent_date: order_by
  shipment_destination: order_by
  shipment_status: order_by
  shipping_label_link: order_by
  tracking_link: order_by
  tracking_number: order_by
  transaction_id: order_by
  updated_at: order_by
  user_shipping_expiration_date: order_by
  validator_review_submit_date: order_by
  validator_review_submit_date_validator_id: order_by
}

"""
response of any mutation on the table "shipments"
"""
type shipments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [shipments!]!
}

"""
input type for inserting object relation for remote table "shipments"
"""
input shipments_obj_rel_insert_input {
  data: shipments_insert_input!

  """upsert condition"""
  on_conflict: shipments_on_conflict
}

"""
on_conflict condition type for table "shipments"
"""
input shipments_on_conflict {
  constraint: shipments_constraint!
  update_columns: [shipments_update_column!]! = []
  where: shipments_bool_exp
}

"""Ordering options when selecting data from "shipments"."""
input shipments_order_by {
  box_up_validator: validators_order_by
  boxed_up_date: order_by
  boxed_up_date_validator_id: order_by
  check_in_validator: validators_order_by
  checked_in_date: order_by
  checked_in_date_validator_id: order_by
  created_at: order_by
  deleted_at: order_by
  delivered_date: order_by
  estimated_delivery_date: order_by
  id: order_by
  offer_checkout: offer_checkouts_order_by
  offer_checkout_id: order_by
  offer_item_shipments_aggregate: offer_item_shipments_aggregate_order_by
  picked_up_date: order_by
  picked_up_date_validator_id: order_by
  pictures_aggregate: files_aggregate_order_by
  review_validator: validators_order_by
  sent_date: order_by
  shipment_destination: order_by
  shipment_status: order_by
  shipping_label_link: order_by
  tracking_link: order_by
  tracking_number: order_by
  transaction_id: order_by
  updated_at: order_by
  user_shipping_expiration_date: order_by
  validator_review_submit_date: order_by
  validator_review_submit_date_validator_id: order_by
}

"""primary key columns input for table: shipments"""
input shipments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "shipments"
"""
enum shipments_select_column {
  """column name"""
  boxed_up_date

  """column name"""
  boxed_up_date_validator_id

  """column name"""
  checked_in_date

  """column name"""
  checked_in_date_validator_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  delivered_date

  """column name"""
  estimated_delivery_date

  """column name"""
  id

  """column name"""
  offer_checkout_id

  """column name"""
  picked_up_date

  """column name"""
  picked_up_date_validator_id

  """column name"""
  sent_date

  """column name"""
  shipment_destination

  """column name"""
  shipment_status

  """column name"""
  shipping_label_link

  """column name"""
  tracking_link

  """column name"""
  tracking_number

  """column name"""
  transaction_id

  """column name"""
  updated_at

  """column name"""
  user_shipping_expiration_date

  """column name"""
  validator_review_submit_date

  """column name"""
  validator_review_submit_date_validator_id
}

"""
input type for updating data in table "shipments"
"""
input shipments_set_input {
  boxed_up_date: timestamptz
  boxed_up_date_validator_id: uuid
  checked_in_date: timestamptz
  checked_in_date_validator_id: uuid
  created_at: timestamptz
  deleted_at: Int
  delivered_date: timestamptz
  estimated_delivery_date: timestamptz
  id: uuid
  offer_checkout_id: uuid
  picked_up_date: timestamptz
  picked_up_date_validator_id: uuid
  sent_date: timestamptz
  shipment_destination: String
  shipment_status: String
  shipping_label_link: String
  tracking_link: String
  tracking_number: String
  transaction_id: String
  updated_at: timestamptz
  user_shipping_expiration_date: timestamptz
  validator_review_submit_date: timestamptz
  validator_review_submit_date_validator_id: uuid
}

"""aggregate stddev on columns"""
type shipments_stddev_fields {
  deleted_at: Float
}

"""
order by stddev() on columns of table "shipments"
"""
input shipments_stddev_order_by {
  deleted_at: order_by
}

"""aggregate stddev_pop on columns"""
type shipments_stddev_pop_fields {
  deleted_at: Float
}

"""
order by stddev_pop() on columns of table "shipments"
"""
input shipments_stddev_pop_order_by {
  deleted_at: order_by
}

"""aggregate stddev_samp on columns"""
type shipments_stddev_samp_fields {
  deleted_at: Float
}

"""
order by stddev_samp() on columns of table "shipments"
"""
input shipments_stddev_samp_order_by {
  deleted_at: order_by
}

"""
Streaming cursor of the table "shipments"
"""
input shipments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: shipments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input shipments_stream_cursor_value_input {
  boxed_up_date: timestamptz
  boxed_up_date_validator_id: uuid
  checked_in_date: timestamptz
  checked_in_date_validator_id: uuid
  created_at: timestamptz
  deleted_at: Int
  delivered_date: timestamptz
  estimated_delivery_date: timestamptz
  id: uuid
  offer_checkout_id: uuid
  picked_up_date: timestamptz
  picked_up_date_validator_id: uuid
  sent_date: timestamptz
  shipment_destination: String
  shipment_status: String
  shipping_label_link: String
  tracking_link: String
  tracking_number: String
  transaction_id: String
  updated_at: timestamptz
  user_shipping_expiration_date: timestamptz
  validator_review_submit_date: timestamptz
  validator_review_submit_date_validator_id: uuid
}

"""aggregate sum on columns"""
type shipments_sum_fields {
  deleted_at: Int
}

"""
order by sum() on columns of table "shipments"
"""
input shipments_sum_order_by {
  deleted_at: order_by
}

"""
update columns of table "shipments"
"""
enum shipments_update_column {
  """column name"""
  boxed_up_date

  """column name"""
  boxed_up_date_validator_id

  """column name"""
  checked_in_date

  """column name"""
  checked_in_date_validator_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  delivered_date

  """column name"""
  estimated_delivery_date

  """column name"""
  id

  """column name"""
  offer_checkout_id

  """column name"""
  picked_up_date

  """column name"""
  picked_up_date_validator_id

  """column name"""
  sent_date

  """column name"""
  shipment_destination

  """column name"""
  shipment_status

  """column name"""
  shipping_label_link

  """column name"""
  tracking_link

  """column name"""
  tracking_number

  """column name"""
  transaction_id

  """column name"""
  updated_at

  """column name"""
  user_shipping_expiration_date

  """column name"""
  validator_review_submit_date

  """column name"""
  validator_review_submit_date_validator_id
}

input shipments_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: shipments_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: shipments_set_input

  """filter the rows which have to be updated"""
  where: shipments_bool_exp!
}

"""aggregate var_pop on columns"""
type shipments_var_pop_fields {
  deleted_at: Float
}

"""
order by var_pop() on columns of table "shipments"
"""
input shipments_var_pop_order_by {
  deleted_at: order_by
}

"""aggregate var_samp on columns"""
type shipments_var_samp_fields {
  deleted_at: Float
}

"""
order by var_samp() on columns of table "shipments"
"""
input shipments_var_samp_order_by {
  deleted_at: order_by
}

"""aggregate variance on columns"""
type shipments_variance_fields {
  deleted_at: Float
}

"""
order by variance() on columns of table "shipments"
"""
input shipments_variance_order_by {
  deleted_at: order_by
}

type strapiMutation {
  """Change user password. Confirm with the current password."""
  changePassword(currentPassword: String!, password: String!, passwordConfirmation: String!): StrapiUsersPermissionsLoginPayload
  createContentReleasesRelease(data: StrapiContentReleasesReleaseInput!): StrapiContentReleasesReleaseEntityResponse
  createContentReleasesReleaseAction(data: StrapiContentReleasesReleaseActionInput!): StrapiContentReleasesReleaseActionEntityResponse
  createEntityNotesNote(data: StrapiEntityNotesNoteInput!): StrapiEntityNotesNoteEntityResponse
  createMarketingBanner(data: StrapiMarketingBannerInput!): StrapiMarketingBannerEntityResponse
  createUploadFile(data: StrapiUploadFileInput!): StrapiUploadFileEntityResponse
  createUploadFolder(data: StrapiUploadFolderInput!): StrapiUploadFolderEntityResponse

  """Create a new role"""
  createUsersPermissionsRole(data: StrapiUsersPermissionsRoleInput!): StrapiUsersPermissionsCreateRolePayload

  """Create a new user"""
  createUsersPermissionsUser(data: StrapiUsersPermissionsUserInput!): StrapiUsersPermissionsUserEntityResponse!
  deleteContentReleasesRelease(id: ID!): StrapiContentReleasesReleaseEntityResponse
  deleteContentReleasesReleaseAction(id: ID!): StrapiContentReleasesReleaseActionEntityResponse
  deleteEntityNotesNote(id: ID!): StrapiEntityNotesNoteEntityResponse
  deleteMarketingBanner(id: ID!): StrapiMarketingBannerEntityResponse
  deleteUploadFile(id: ID!): StrapiUploadFileEntityResponse
  deleteUploadFolder(id: ID!): StrapiUploadFolderEntityResponse

  """Delete an existing role"""
  deleteUsersPermissionsRole(id: ID!): StrapiUsersPermissionsDeleteRolePayload

  """Delete an existing user"""
  deleteUsersPermissionsUser(id: ID!): StrapiUsersPermissionsUserEntityResponse!

  """Confirm an email users email address"""
  emailConfirmation(confirmation: String!): StrapiUsersPermissionsLoginPayload

  """Request a reset password token"""
  forgotPassword(email: String!): StrapiUsersPermissionsPasswordPayload
  login(input: StrapiUsersPermissionsLoginInput!): StrapiUsersPermissionsLoginPayload!
  multipleUpload(field: String, files: [StrapiUpload]!, ref: String, refId: ID): [StrapiUploadFileEntityResponse]!

  """Register a user"""
  register(input: StrapiUsersPermissionsRegisterInput!): StrapiUsersPermissionsLoginPayload!
  removeFile(id: ID!): StrapiUploadFileEntityResponse

  """
  Reset user password. Confirm with a code (resetToken from forgotPassword)
  """
  resetPassword(code: String!, password: String!, passwordConfirmation: String!): StrapiUsersPermissionsLoginPayload
  updateContentReleasesRelease(data: StrapiContentReleasesReleaseInput!, id: ID!): StrapiContentReleasesReleaseEntityResponse
  updateContentReleasesReleaseAction(data: StrapiContentReleasesReleaseActionInput!, id: ID!): StrapiContentReleasesReleaseActionEntityResponse
  updateEntityNotesNote(data: StrapiEntityNotesNoteInput!, id: ID!): StrapiEntityNotesNoteEntityResponse
  updateFileInfo(id: ID!, info: StrapiFileInfoInput): StrapiUploadFileEntityResponse!
  updateMarketingBanner(data: StrapiMarketingBannerInput!, id: ID!): StrapiMarketingBannerEntityResponse
  updateUploadFile(data: StrapiUploadFileInput!, id: ID!): StrapiUploadFileEntityResponse
  updateUploadFolder(data: StrapiUploadFolderInput!, id: ID!): StrapiUploadFolderEntityResponse

  """Update an existing role"""
  updateUsersPermissionsRole(data: StrapiUsersPermissionsRoleInput!, id: ID!): StrapiUsersPermissionsUpdateRolePayload

  """Update an existing user"""
  updateUsersPermissionsUser(data: StrapiUsersPermissionsUserInput!, id: ID!): StrapiUsersPermissionsUserEntityResponse!
  upload(field: String, file: StrapiUpload!, info: StrapiFileInfoInput, ref: String, refId: ID): StrapiUploadFileEntityResponse!
}

type strapiQuery {
  contentReleasesRelease(id: ID): StrapiContentReleasesReleaseEntityResponse
  contentReleasesReleaseAction(id: ID): StrapiContentReleasesReleaseActionEntityResponse
  contentReleasesReleaseActions(filters: StrapiContentReleasesReleaseActionFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiContentReleasesReleaseActionEntityResponseCollection
  contentReleasesReleases(filters: StrapiContentReleasesReleaseFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiContentReleasesReleaseEntityResponseCollection
  entityNotesNote(id: ID): StrapiEntityNotesNoteEntityResponse
  entityNotesNotes(filters: StrapiEntityNotesNoteFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiEntityNotesNoteEntityResponseCollection
  i18NLocale(id: ID): StrapiI18NLocaleEntityResponse
  i18NLocales(filters: StrapiI18NLocaleFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiI18NLocaleEntityResponseCollection
  marketingBanner(id: ID): StrapiMarketingBannerEntityResponse
  marketingBanners(filters: StrapiMarketingBannerFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiMarketingBannerEntityResponseCollection
  me: StrapiUsersPermissionsMe
  uploadFile(id: ID): StrapiUploadFileEntityResponse
  uploadFiles(filters: StrapiUploadFileFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiUploadFileEntityResponseCollection
  uploadFolder(id: ID): StrapiUploadFolderEntityResponse
  uploadFolders(filters: StrapiUploadFolderFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiUploadFolderEntityResponseCollection
  usersPermissionsRole(id: ID): StrapiUsersPermissionsRoleEntityResponse
  usersPermissionsRoles(filters: StrapiUsersPermissionsRoleFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiUsersPermissionsRoleEntityResponseCollection
  usersPermissionsUser(id: ID): StrapiUsersPermissionsUserEntityResponse
  usersPermissionsUsers(filters: StrapiUsersPermissionsUserFiltersInput, pagination: StrapiPaginationArg = {}, sort: [String] = []): StrapiUsersPermissionsUserEntityResponseCollection
}

type subscription_root {
  """An array relationship"""
  addresses(
    """distinct select on columns"""
    distinct_on: [addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [addresses_order_by!]

    """filter the rows returned"""
    where: addresses_bool_exp
  ): [addresses!]!

  """An aggregate relationship"""
  addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [addresses_order_by!]

    """filter the rows returned"""
    where: addresses_bool_exp
  ): addresses_aggregate!

  """fetch data from the table: "addresses" using primary key columns"""
  addresses_by_pk(id: uuid!): addresses

  """
  fetch data from the table in a streaming manner: "addresses"
  """
  addresses_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [addresses_stream_cursor_input]!

    """filter the rows returned"""
    where: addresses_bool_exp
  ): [addresses!]!

  """
  fetch data from the table: "attribute_attribute_group"
  """
  attribute_attribute_group(
    """distinct select on columns"""
    distinct_on: [attribute_attribute_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_attribute_group_order_by!]

    """filter the rows returned"""
    where: attribute_attribute_group_bool_exp
  ): [attribute_attribute_group!]!

  """
  fetch aggregated fields from the table: "attribute_attribute_group"
  """
  attribute_attribute_group_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_attribute_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_attribute_group_order_by!]

    """filter the rows returned"""
    where: attribute_attribute_group_bool_exp
  ): attribute_attribute_group_aggregate!

  """
  fetch data from the table: "attribute_attribute_group" using primary key columns
  """
  attribute_attribute_group_by_pk(id: uuid!): attribute_attribute_group

  """
  fetch data from the table in a streaming manner: "attribute_attribute_group"
  """
  attribute_attribute_group_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attribute_attribute_group_stream_cursor_input]!

    """filter the rows returned"""
    where: attribute_attribute_group_bool_exp
  ): [attribute_attribute_group!]!

  """
  fetch data from the table: "attribute_groups"
  """
  attribute_groups(
    """distinct select on columns"""
    distinct_on: [attribute_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_groups_order_by!]

    """filter the rows returned"""
    where: attribute_groups_bool_exp
  ): [attribute_groups!]!

  """
  fetch aggregated fields from the table: "attribute_groups"
  """
  attribute_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_groups_order_by!]

    """filter the rows returned"""
    where: attribute_groups_bool_exp
  ): attribute_groups_aggregate!

  """
  fetch data from the table: "attribute_groups" using primary key columns
  """
  attribute_groups_by_pk(id: uuid!): attribute_groups

  """
  fetch data from the table in a streaming manner: "attribute_groups"
  """
  attribute_groups_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attribute_groups_stream_cursor_input]!

    """filter the rows returned"""
    where: attribute_groups_bool_exp
  ): [attribute_groups!]!

  """An array relationship"""
  attribute_preferences(
    """distinct select on columns"""
    distinct_on: [attribute_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_preferences_order_by!]

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): [attribute_preferences!]!

  """An aggregate relationship"""
  attribute_preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_preferences_order_by!]

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): attribute_preferences_aggregate!

  """
  fetch data from the table: "attribute_preferences" using primary key columns
  """
  attribute_preferences_by_pk(id: uuid!): attribute_preferences

  """
  fetch data from the table in a streaming manner: "attribute_preferences"
  """
  attribute_preferences_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attribute_preferences_stream_cursor_input]!

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): [attribute_preferences!]!

  """An array relationship"""
  attribute_selections(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): [attribute_selections!]!

  """An aggregate relationship"""
  attribute_selections_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): attribute_selections_aggregate!

  """
  fetch data from the table: "attribute_selections" using primary key columns
  """
  attribute_selections_by_pk(id: uuid!): attribute_selections

  """
  fetch data from the table in a streaming manner: "attribute_selections"
  """
  attribute_selections_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attribute_selections_stream_cursor_input]!

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): [attribute_selections!]!

  """
  fetch data from the table: "attribute_type"
  """
  attribute_type(
    """distinct select on columns"""
    distinct_on: [attribute_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_type_order_by!]

    """filter the rows returned"""
    where: attribute_type_bool_exp
  ): [attribute_type!]!

  """
  fetch aggregated fields from the table: "attribute_type"
  """
  attribute_type_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_type_order_by!]

    """filter the rows returned"""
    where: attribute_type_bool_exp
  ): attribute_type_aggregate!

  """fetch data from the table: "attribute_type" using primary key columns"""
  attribute_type_by_pk(value: String!): attribute_type

  """
  fetch data from the table in a streaming manner: "attribute_type"
  """
  attribute_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attribute_type_stream_cursor_input]!

    """filter the rows returned"""
    where: attribute_type_bool_exp
  ): [attribute_type!]!

  """An array relationship"""
  attribute_values(
    """distinct select on columns"""
    distinct_on: [attribute_values_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_values_order_by!]

    """filter the rows returned"""
    where: attribute_values_bool_exp
  ): [attribute_values!]!

  """An aggregate relationship"""
  attribute_values_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_values_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_values_order_by!]

    """filter the rows returned"""
    where: attribute_values_bool_exp
  ): attribute_values_aggregate!

  """
  fetch data from the table: "attribute_values" using primary key columns
  """
  attribute_values_by_pk(id: uuid!): attribute_values

  """
  fetch data from the table in a streaming manner: "attribute_values"
  """
  attribute_values_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attribute_values_stream_cursor_input]!

    """filter the rows returned"""
    where: attribute_values_bool_exp
  ): [attribute_values!]!

  """An array relationship"""
  attributes(
    """distinct select on columns"""
    distinct_on: [attributes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attributes_order_by!]

    """filter the rows returned"""
    where: attributes_bool_exp
  ): [attributes!]!

  """An aggregate relationship"""
  attributes_aggregate(
    """distinct select on columns"""
    distinct_on: [attributes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attributes_order_by!]

    """filter the rows returned"""
    where: attributes_bool_exp
  ): attributes_aggregate!

  """fetch data from the table: "attributes" using primary key columns"""
  attributes_by_pk(id: uuid!): attributes

  """
  fetch data from the table in a streaming manner: "attributes"
  """
  attributes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attributes_stream_cursor_input]!

    """filter the rows returned"""
    where: attributes_bool_exp
  ): [attributes!]!

  """
  fetch data from the table: "badges"
  """
  badges(
    """distinct select on columns"""
    distinct_on: [badges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [badges_order_by!]

    """filter the rows returned"""
    where: badges_bool_exp
  ): [badges!]!

  """
  fetch aggregated fields from the table: "badges"
  """
  badges_aggregate(
    """distinct select on columns"""
    distinct_on: [badges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [badges_order_by!]

    """filter the rows returned"""
    where: badges_bool_exp
  ): badges_aggregate!

  """fetch data from the table: "badges" using primary key columns"""
  badges_by_pk(name: String!): badges

  """
  fetch data from the table in a streaming manner: "badges"
  """
  badges_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [badges_stream_cursor_input]!

    """filter the rows returned"""
    where: badges_bool_exp
  ): [badges!]!

  """
  fetch data from the table: "blocks"
  """
  blocks(
    """distinct select on columns"""
    distinct_on: [blocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blocks_order_by!]

    """filter the rows returned"""
    where: blocks_bool_exp
  ): [blocks!]!

  """
  fetch aggregated fields from the table: "blocks"
  """
  blocks_aggregate(
    """distinct select on columns"""
    distinct_on: [blocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blocks_order_by!]

    """filter the rows returned"""
    where: blocks_bool_exp
  ): blocks_aggregate!

  """fetch data from the table: "blocks" using primary key columns"""
  blocks_by_pk(blocked_id: uuid!, blocker_id: uuid!): blocks

  """
  fetch data from the table in a streaming manner: "blocks"
  """
  blocks_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [blocks_stream_cursor_input]!

    """filter the rows returned"""
    where: blocks_bool_exp
  ): [blocks!]!

  """
  fetch data from the table: "communication_preference_groups"
  """
  communication_preference_groups(
    """distinct select on columns"""
    distinct_on: [communication_preference_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_preference_groups_order_by!]

    """filter the rows returned"""
    where: communication_preference_groups_bool_exp
  ): [communication_preference_groups!]!

  """
  fetch aggregated fields from the table: "communication_preference_groups"
  """
  communication_preference_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [communication_preference_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_preference_groups_order_by!]

    """filter the rows returned"""
    where: communication_preference_groups_bool_exp
  ): communication_preference_groups_aggregate!

  """
  fetch data from the table: "communication_preference_groups" using primary key columns
  """
  communication_preference_groups_by_pk(key: String!): communication_preference_groups

  """
  fetch data from the table in a streaming manner: "communication_preference_groups"
  """
  communication_preference_groups_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [communication_preference_groups_stream_cursor_input]!

    """filter the rows returned"""
    where: communication_preference_groups_bool_exp
  ): [communication_preference_groups!]!

  """An array relationship"""
  communication_preferences(
    """distinct select on columns"""
    distinct_on: [communication_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_preferences_order_by!]

    """filter the rows returned"""
    where: communication_preferences_bool_exp
  ): [communication_preferences!]!

  """An aggregate relationship"""
  communication_preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [communication_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_preferences_order_by!]

    """filter the rows returned"""
    where: communication_preferences_bool_exp
  ): communication_preferences_aggregate!

  """
  fetch data from the table: "communication_preferences" using primary key columns
  """
  communication_preferences_by_pk(communication_preference_group_key: String!, user_preference_id: uuid!): communication_preferences

  """
  fetch data from the table in a streaming manner: "communication_preferences"
  """
  communication_preferences_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [communication_preferences_stream_cursor_input]!

    """filter the rows returned"""
    where: communication_preferences_bool_exp
  ): [communication_preferences!]!

  """An array relationship"""
  communication_templates(
    """distinct select on columns"""
    distinct_on: [communication_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_templates_order_by!]

    """filter the rows returned"""
    where: communication_templates_bool_exp
  ): [communication_templates!]!

  """An aggregate relationship"""
  communication_templates_aggregate(
    """distinct select on columns"""
    distinct_on: [communication_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_templates_order_by!]

    """filter the rows returned"""
    where: communication_templates_bool_exp
  ): communication_templates_aggregate!

  """
  fetch data from the table: "communication_templates" using primary key columns
  """
  communication_templates_by_pk(key: String!): communication_templates

  """
  fetch data from the table in a streaming manner: "communication_templates"
  """
  communication_templates_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [communication_templates_stream_cursor_input]!

    """filter the rows returned"""
    where: communication_templates_bool_exp
  ): [communication_templates!]!

  """
  fetch data from the table: "currencies"
  """
  currencies(
    """distinct select on columns"""
    distinct_on: [currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currencies_order_by!]

    """filter the rows returned"""
    where: currencies_bool_exp
  ): [currencies!]!

  """
  fetch aggregated fields from the table: "currencies"
  """
  currencies_aggregate(
    """distinct select on columns"""
    distinct_on: [currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currencies_order_by!]

    """filter the rows returned"""
    where: currencies_bool_exp
  ): currencies_aggregate!

  """fetch data from the table: "currencies" using primary key columns"""
  currencies_by_pk(currency: String!): currencies

  """
  fetch data from the table in a streaming manner: "currencies"
  """
  currencies_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [currencies_stream_cursor_input]!

    """filter the rows returned"""
    where: currencies_bool_exp
  ): [currencies!]!

  """An array relationship"""
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """An aggregate relationship"""
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!

  """fetch data from the table: "devices" using primary key columns"""
  devices_by_pk(id: uuid!): devices

  """
  fetch data from the table in a streaming manner: "devices"
  """
  devices_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [devices_stream_cursor_input]!

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """
  fetch data from the table: "files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "files"
  """
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """fetch data from the table: "files" using primary key columns"""
  files_by_pk(id: uuid!): files

  """
  fetch data from the table in a streaming manner: "files"
  """
  files_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [files_stream_cursor_input]!

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch data from the table: "follows"
  """
  follows(
    """distinct select on columns"""
    distinct_on: [follows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [follows_order_by!]

    """filter the rows returned"""
    where: follows_bool_exp
  ): [follows!]!

  """
  fetch aggregated fields from the table: "follows"
  """
  follows_aggregate(
    """distinct select on columns"""
    distinct_on: [follows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [follows_order_by!]

    """filter the rows returned"""
    where: follows_bool_exp
  ): follows_aggregate!

  """fetch data from the table: "follows" using primary key columns"""
  follows_by_pk(follower_id: uuid!, following_id: uuid!): follows

  """
  fetch data from the table in a streaming manner: "follows"
  """
  follows_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [follows_stream_cursor_input]!

    """filter the rows returned"""
    where: follows_bool_exp
  ): [follows!]!

  """
  fetch data from the table: "free_shipping_configuration"
  """
  free_shipping_configuration(
    """distinct select on columns"""
    distinct_on: [free_shipping_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [free_shipping_configuration_order_by!]

    """filter the rows returned"""
    where: free_shipping_configuration_bool_exp
  ): [free_shipping_configuration!]!

  """
  fetch aggregated fields from the table: "free_shipping_configuration"
  """
  free_shipping_configuration_aggregate(
    """distinct select on columns"""
    distinct_on: [free_shipping_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [free_shipping_configuration_order_by!]

    """filter the rows returned"""
    where: free_shipping_configuration_bool_exp
  ): free_shipping_configuration_aggregate!

  """
  fetch data from the table: "free_shipping_configuration" using primary key columns
  """
  free_shipping_configuration_by_pk(id: uuid!): free_shipping_configuration

  """
  fetch data from the table in a streaming manner: "free_shipping_configuration"
  """
  free_shipping_configuration_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [free_shipping_configuration_stream_cursor_input]!

    """filter the rows returned"""
    where: free_shipping_configuration_bool_exp
  ): [free_shipping_configuration!]!

  """An array relationship"""
  inventory_items(
    """distinct select on columns"""
    distinct_on: [inventory_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_items_order_by!]

    """filter the rows returned"""
    where: inventory_items_bool_exp
  ): [inventory_items!]!

  """An aggregate relationship"""
  inventory_items_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_items_order_by!]

    """filter the rows returned"""
    where: inventory_items_bool_exp
  ): inventory_items_aggregate!

  """fetch data from the table: "inventory_items" using primary key columns"""
  inventory_items_by_pk(id: uuid!): inventory_items

  """
  fetch data from the table in a streaming manner: "inventory_items"
  """
  inventory_items_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [inventory_items_stream_cursor_input]!

    """filter the rows returned"""
    where: inventory_items_bool_exp
  ): [inventory_items!]!

  """
  fetch data from the table: "inventory_status"
  """
  inventory_status(
    """distinct select on columns"""
    distinct_on: [inventory_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_status_order_by!]

    """filter the rows returned"""
    where: inventory_status_bool_exp
  ): [inventory_status!]!

  """
  fetch aggregated fields from the table: "inventory_status"
  """
  inventory_status_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_status_order_by!]

    """filter the rows returned"""
    where: inventory_status_bool_exp
  ): inventory_status_aggregate!

  """
  fetch data from the table: "inventory_status" using primary key columns
  """
  inventory_status_by_pk(value: String!): inventory_status

  """
  fetch data from the table in a streaming manner: "inventory_status"
  """
  inventory_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [inventory_status_stream_cursor_input]!

    """filter the rows returned"""
    where: inventory_status_bool_exp
  ): [inventory_status!]!

  """
  fetch data from the table: "languages"
  """
  languages(
    """distinct select on columns"""
    distinct_on: [languages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [languages_order_by!]

    """filter the rows returned"""
    where: languages_bool_exp
  ): [languages!]!

  """
  fetch aggregated fields from the table: "languages"
  """
  languages_aggregate(
    """distinct select on columns"""
    distinct_on: [languages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [languages_order_by!]

    """filter the rows returned"""
    where: languages_bool_exp
  ): languages_aggregate!

  """fetch data from the table: "languages" using primary key columns"""
  languages_by_pk(code: String!): languages

  """
  fetch data from the table in a streaming manner: "languages"
  """
  languages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [languages_stream_cursor_input]!

    """filter the rows returned"""
    where: languages_bool_exp
  ): [languages!]!

  """
  fetch data from the table: "march_mania_bracket"
  """
  march_mania_bracket(
    """distinct select on columns"""
    distinct_on: [march_mania_bracket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [march_mania_bracket_order_by!]

    """filter the rows returned"""
    where: march_mania_bracket_bool_exp
  ): [march_mania_bracket!]!

  """
  fetch aggregated fields from the table: "march_mania_bracket"
  """
  march_mania_bracket_aggregate(
    """distinct select on columns"""
    distinct_on: [march_mania_bracket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [march_mania_bracket_order_by!]

    """filter the rows returned"""
    where: march_mania_bracket_bool_exp
  ): march_mania_bracket_aggregate!

  """
  fetch data from the table: "march_mania_bracket" using primary key columns
  """
  march_mania_bracket_by_pk(id: uuid!): march_mania_bracket

  """
  fetch data from the table in a streaming manner: "march_mania_bracket"
  """
  march_mania_bracket_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [march_mania_bracket_stream_cursor_input]!

    """filter the rows returned"""
    where: march_mania_bracket_bool_exp
  ): [march_mania_bracket!]!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: uuid!): notifications

  """
  fetch data from the table in a streaming manner: "notifications"
  """
  notifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notifications_stream_cursor_input]!

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An array relationship"""
  offer_checkouts(
    """distinct select on columns"""
    distinct_on: [offer_checkouts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_checkouts_order_by!]

    """filter the rows returned"""
    where: offer_checkouts_bool_exp
  ): [offer_checkouts!]!

  """An aggregate relationship"""
  offer_checkouts_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_checkouts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_checkouts_order_by!]

    """filter the rows returned"""
    where: offer_checkouts_bool_exp
  ): offer_checkouts_aggregate!

  """fetch data from the table: "offer_checkouts" using primary key columns"""
  offer_checkouts_by_pk(id: uuid!): offer_checkouts

  """
  fetch data from the table in a streaming manner: "offer_checkouts"
  """
  offer_checkouts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [offer_checkouts_stream_cursor_input]!

    """filter the rows returned"""
    where: offer_checkouts_bool_exp
  ): [offer_checkouts!]!

  """
  fetch data from the table: "offer_item_issue_offer_item_issue_types"
  """
  offer_item_issue_offer_item_issue_types(
    """distinct select on columns"""
    distinct_on: [offer_item_issue_offer_item_issue_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_issue_offer_item_issue_types_order_by!]

    """filter the rows returned"""
    where: offer_item_issue_offer_item_issue_types_bool_exp
  ): [offer_item_issue_offer_item_issue_types!]!

  """
  fetch aggregated fields from the table: "offer_item_issue_offer_item_issue_types"
  """
  offer_item_issue_offer_item_issue_types_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_item_issue_offer_item_issue_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_issue_offer_item_issue_types_order_by!]

    """filter the rows returned"""
    where: offer_item_issue_offer_item_issue_types_bool_exp
  ): offer_item_issue_offer_item_issue_types_aggregate!

  """
  fetch data from the table: "offer_item_issue_offer_item_issue_types" using primary key columns
  """
  offer_item_issue_offer_item_issue_types_by_pk(issue_id: uuid!, issue_type: String!): offer_item_issue_offer_item_issue_types

  """
  fetch data from the table in a streaming manner: "offer_item_issue_offer_item_issue_types"
  """
  offer_item_issue_offer_item_issue_types_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [offer_item_issue_offer_item_issue_types_stream_cursor_input]!

    """filter the rows returned"""
    where: offer_item_issue_offer_item_issue_types_bool_exp
  ): [offer_item_issue_offer_item_issue_types!]!

  """
  fetch data from the table: "offer_item_owners"
  """
  offer_item_owners(
    """distinct select on columns"""
    distinct_on: [offer_item_owners_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_owners_order_by!]

    """filter the rows returned"""
    where: offer_item_owners_bool_exp
  ): [offer_item_owners!]!

  """
  fetch aggregated fields from the table: "offer_item_owners"
  """
  offer_item_owners_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_item_owners_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_owners_order_by!]

    """filter the rows returned"""
    where: offer_item_owners_bool_exp
  ): offer_item_owners_aggregate!

  """
  fetch data from the table: "offer_item_owners" using primary key columns
  """
  offer_item_owners_by_pk(owner: String!): offer_item_owners

  """
  fetch data from the table in a streaming manner: "offer_item_owners"
  """
  offer_item_owners_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [offer_item_owners_stream_cursor_input]!

    """filter the rows returned"""
    where: offer_item_owners_bool_exp
  ): [offer_item_owners!]!

  """An array relationship"""
  offer_item_shipments(
    """distinct select on columns"""
    distinct_on: [offer_item_shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_shipments_order_by!]

    """filter the rows returned"""
    where: offer_item_shipments_bool_exp
  ): [offer_item_shipments!]!

  """An aggregate relationship"""
  offer_item_shipments_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_item_shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_item_shipments_order_by!]

    """filter the rows returned"""
    where: offer_item_shipments_bool_exp
  ): offer_item_shipments_aggregate!

  """
  fetch data from the table: "offer_item_shipments" using primary key columns
  """
  offer_item_shipments_by_pk(offer_item_id: uuid!, shipment_id: uuid!): offer_item_shipments

  """
  fetch data from the table in a streaming manner: "offer_item_shipments"
  """
  offer_item_shipments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [offer_item_shipments_stream_cursor_input]!

    """filter the rows returned"""
    where: offer_item_shipments_bool_exp
  ): [offer_item_shipments!]!

  """An array relationship"""
  offer_items(
    """distinct select on columns"""
    distinct_on: [offer_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_order_by!]

    """filter the rows returned"""
    where: offer_items_bool_exp
  ): [offer_items!]!

  """An aggregate relationship"""
  offer_items_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_order_by!]

    """filter the rows returned"""
    where: offer_items_bool_exp
  ): offer_items_aggregate!

  """fetch data from the table: "offer_items" using primary key columns"""
  offer_items_by_pk(id: uuid!): offer_items

  """An array relationship"""
  offer_items_issues(
    """distinct select on columns"""
    distinct_on: [offer_items_issues_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_issues_order_by!]

    """filter the rows returned"""
    where: offer_items_issues_bool_exp
  ): [offer_items_issues!]!

  """An aggregate relationship"""
  offer_items_issues_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_items_issues_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_items_issues_order_by!]

    """filter the rows returned"""
    where: offer_items_issues_bool_exp
  ): offer_items_issues_aggregate!

  """
  fetch data from the table: "offer_items_issues" using primary key columns
  """
  offer_items_issues_by_pk(id: uuid!): offer_items_issues

  """
  fetch data from the table in a streaming manner: "offer_items_issues"
  """
  offer_items_issues_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [offer_items_issues_stream_cursor_input]!

    """filter the rows returned"""
    where: offer_items_issues_bool_exp
  ): [offer_items_issues!]!

  """
  fetch data from the table in a streaming manner: "offer_items"
  """
  offer_items_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [offer_items_stream_cursor_input]!

    """filter the rows returned"""
    where: offer_items_bool_exp
  ): [offer_items!]!

  """
  fetch data from the table: "offer_statuses"
  """
  offer_statuses(
    """distinct select on columns"""
    distinct_on: [offer_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_statuses_order_by!]

    """filter the rows returned"""
    where: offer_statuses_bool_exp
  ): [offer_statuses!]!

  """
  fetch aggregated fields from the table: "offer_statuses"
  """
  offer_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_statuses_order_by!]

    """filter the rows returned"""
    where: offer_statuses_bool_exp
  ): offer_statuses_aggregate!

  """fetch data from the table: "offer_statuses" using primary key columns"""
  offer_statuses_by_pk(status: String!): offer_statuses

  """
  fetch data from the table in a streaming manner: "offer_statuses"
  """
  offer_statuses_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [offer_statuses_stream_cursor_input]!

    """filter the rows returned"""
    where: offer_statuses_bool_exp
  ): [offer_statuses!]!

  """
  fetch data from the table: "offer_transaction_types"
  """
  offer_transaction_types(
    """distinct select on columns"""
    distinct_on: [offer_transaction_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_transaction_types_order_by!]

    """filter the rows returned"""
    where: offer_transaction_types_bool_exp
  ): [offer_transaction_types!]!

  """
  fetch aggregated fields from the table: "offer_transaction_types"
  """
  offer_transaction_types_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_transaction_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_transaction_types_order_by!]

    """filter the rows returned"""
    where: offer_transaction_types_bool_exp
  ): offer_transaction_types_aggregate!

  """
  fetch data from the table: "offer_transaction_types" using primary key columns
  """
  offer_transaction_types_by_pk(transaction_type: String!): offer_transaction_types

  """
  fetch data from the table in a streaming manner: "offer_transaction_types"
  """
  offer_transaction_types_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [offer_transaction_types_stream_cursor_input]!

    """filter the rows returned"""
    where: offer_transaction_types_bool_exp
  ): [offer_transaction_types!]!

  """
  fetch data from the table: "offer_types"
  """
  offer_types(
    """distinct select on columns"""
    distinct_on: [offer_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_types_order_by!]

    """filter the rows returned"""
    where: offer_types_bool_exp
  ): [offer_types!]!

  """
  fetch aggregated fields from the table: "offer_types"
  """
  offer_types_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_types_order_by!]

    """filter the rows returned"""
    where: offer_types_bool_exp
  ): offer_types_aggregate!

  """fetch data from the table: "offer_types" using primary key columns"""
  offer_types_by_pk(type: String!): offer_types

  """
  fetch data from the table in a streaming manner: "offer_types"
  """
  offer_types_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [offer_types_stream_cursor_input]!

    """filter the rows returned"""
    where: offer_types_bool_exp
  ): [offer_types!]!

  """
  fetch data from the table: "offers"
  """
  offers(
    """distinct select on columns"""
    distinct_on: [offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offers_order_by!]

    """filter the rows returned"""
    where: offers_bool_exp
  ): [offers!]!

  """
  fetch aggregated fields from the table: "offers"
  """
  offers_aggregate(
    """distinct select on columns"""
    distinct_on: [offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offers_order_by!]

    """filter the rows returned"""
    where: offers_bool_exp
  ): offers_aggregate!

  """fetch data from the table: "offers" using primary key columns"""
  offers_by_pk(id: uuid!): offers

  """
  fetch data from the table in a streaming manner: "offers"
  """
  offers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [offers_stream_cursor_input]!

    """filter the rows returned"""
    where: offers_bool_exp
  ): [offers!]!

  """
  fetch data from the table: "payment_transactions"
  """
  payment_transactions(
    """distinct select on columns"""
    distinct_on: [payment_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_transactions_order_by!]

    """filter the rows returned"""
    where: payment_transactions_bool_exp
  ): [payment_transactions!]!

  """
  fetch aggregated fields from the table: "payment_transactions"
  """
  payment_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_transactions_order_by!]

    """filter the rows returned"""
    where: payment_transactions_bool_exp
  ): payment_transactions_aggregate!

  """
  fetch data from the table: "payment_transactions" using primary key columns
  """
  payment_transactions_by_pk(id: uuid!): payment_transactions

  """
  fetch data from the table in a streaming manner: "payment_transactions"
  """
  payment_transactions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payment_transactions_stream_cursor_input]!

    """filter the rows returned"""
    where: payment_transactions_bool_exp
  ): [payment_transactions!]!

  """
  fetch data from the table: "price_report"
  """
  price_report(
    """distinct select on columns"""
    distinct_on: [price_report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [price_report_order_by!]

    """filter the rows returned"""
    where: price_report_bool_exp
  ): [price_report!]!

  """
  fetch aggregated fields from the table: "price_report"
  """
  price_report_aggregate(
    """distinct select on columns"""
    distinct_on: [price_report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [price_report_order_by!]

    """filter the rows returned"""
    where: price_report_bool_exp
  ): price_report_aggregate!

  """fetch data from the table: "price_report" using primary key columns"""
  price_report_by_pk(id: uuid!): price_report

  """
  fetch data from the table in a streaming manner: "price_report"
  """
  price_report_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [price_report_stream_cursor_input]!

    """filter the rows returned"""
    where: price_report_bool_exp
  ): [price_report!]!

  """
  fetch data from the table: "product_promo_configuration"
  """
  product_promo_configuration(
    """distinct select on columns"""
    distinct_on: [product_promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_promo_configuration_order_by!]

    """filter the rows returned"""
    where: product_promo_configuration_bool_exp
  ): [product_promo_configuration!]!

  """
  fetch aggregated fields from the table: "product_promo_configuration"
  """
  product_promo_configuration_aggregate(
    """distinct select on columns"""
    distinct_on: [product_promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_promo_configuration_order_by!]

    """filter the rows returned"""
    where: product_promo_configuration_bool_exp
  ): product_promo_configuration_aggregate!

  """
  fetch data from the table: "product_promo_configuration" using primary key columns
  """
  product_promo_configuration_by_pk(product_id: uuid!, promo_configuration_id: uuid!): product_promo_configuration

  """
  fetch data from the table in a streaming manner: "product_promo_configuration"
  """
  product_promo_configuration_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_promo_configuration_stream_cursor_input]!

    """filter the rows returned"""
    where: product_promo_configuration_bool_exp
  ): [product_promo_configuration!]!

  """An array relationship"""
  product_variants(
    """distinct select on columns"""
    distinct_on: [product_variants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_variants_order_by!]

    """filter the rows returned"""
    where: product_variants_bool_exp
  ): [product_variants!]!

  """An aggregate relationship"""
  product_variants_aggregate(
    """distinct select on columns"""
    distinct_on: [product_variants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_variants_order_by!]

    """filter the rows returned"""
    where: product_variants_bool_exp
  ): product_variants_aggregate!

  """
  fetch data from the table: "product_variants" using primary key columns
  """
  product_variants_by_pk(id: uuid!): product_variants

  """
  fetch data from the table in a streaming manner: "product_variants"
  """
  product_variants_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_variants_stream_cursor_input]!

    """filter the rows returned"""
    where: product_variants_bool_exp
  ): [product_variants!]!

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): products_aggregate!

  """fetch data from the table: "products" using primary key columns"""
  products_by_pk(id: uuid!): products

  """
  fetch data from the table in a streaming manner: "products"
  """
  products_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [products_stream_cursor_input]!

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """
  fetch data from the table: "promo_configuration"
  """
  promo_configuration(
    """distinct select on columns"""
    distinct_on: [promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [promo_configuration_order_by!]

    """filter the rows returned"""
    where: promo_configuration_bool_exp
  ): [promo_configuration!]!

  """
  fetch aggregated fields from the table: "promo_configuration"
  """
  promo_configuration_aggregate(
    """distinct select on columns"""
    distinct_on: [promo_configuration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [promo_configuration_order_by!]

    """filter the rows returned"""
    where: promo_configuration_bool_exp
  ): promo_configuration_aggregate!

  """
  fetch data from the table: "promo_configuration" using primary key columns
  """
  promo_configuration_by_pk(id: uuid!): promo_configuration

  """
  fetch data from the table: "promo_configuration_name"
  """
  promo_configuration_name(
    """distinct select on columns"""
    distinct_on: [promo_configuration_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [promo_configuration_name_order_by!]

    """filter the rows returned"""
    where: promo_configuration_name_bool_exp
  ): [promo_configuration_name!]!

  """
  fetch aggregated fields from the table: "promo_configuration_name"
  """
  promo_configuration_name_aggregate(
    """distinct select on columns"""
    distinct_on: [promo_configuration_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [promo_configuration_name_order_by!]

    """filter the rows returned"""
    where: promo_configuration_name_bool_exp
  ): promo_configuration_name_aggregate!

  """
  fetch data from the table: "promo_configuration_name" using primary key columns
  """
  promo_configuration_name_by_pk(name: String!): promo_configuration_name

  """
  fetch data from the table in a streaming manner: "promo_configuration_name"
  """
  promo_configuration_name_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [promo_configuration_name_stream_cursor_input]!

    """filter the rows returned"""
    where: promo_configuration_name_bool_exp
  ): [promo_configuration_name!]!

  """
  fetch data from the table in a streaming manner: "promo_configuration"
  """
  promo_configuration_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [promo_configuration_stream_cursor_input]!

    """filter the rows returned"""
    where: promo_configuration_bool_exp
  ): [promo_configuration!]!

  """
  fetch data from the table: "report_categories"
  """
  report_categories(
    """distinct select on columns"""
    distinct_on: [report_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_categories_order_by!]

    """filter the rows returned"""
    where: report_categories_bool_exp
  ): [report_categories!]!

  """
  fetch aggregated fields from the table: "report_categories"
  """
  report_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [report_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_categories_order_by!]

    """filter the rows returned"""
    where: report_categories_bool_exp
  ): report_categories_aggregate!

  """
  fetch data from the table: "report_categories" using primary key columns
  """
  report_categories_by_pk(key: String!): report_categories

  """
  fetch data from the table in a streaming manner: "report_categories"
  """
  report_categories_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [report_categories_stream_cursor_input]!

    """filter the rows returned"""
    where: report_categories_bool_exp
  ): [report_categories!]!

  """An array relationship"""
  reports(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """An aggregate relationship"""
  reports_aggregate(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): reports_aggregate!

  """fetch data from the table: "reports" using primary key columns"""
  reports_by_pk(categoryKey: report_categories_enum!, reported_id: uuid!, reporter_id: uuid!): reports

  """
  fetch data from the table in a streaming manner: "reports"
  """
  reports_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [reports_stream_cursor_input]!

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(name: String!): roles

  """
  fetch data from the table in a streaming manner: "roles"
  """
  roles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [roles_stream_cursor_input]!

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """An array relationship"""
  shipments(
    """distinct select on columns"""
    distinct_on: [shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipments_order_by!]

    """filter the rows returned"""
    where: shipments_bool_exp
  ): [shipments!]!

  """An aggregate relationship"""
  shipments_aggregate(
    """distinct select on columns"""
    distinct_on: [shipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shipments_order_by!]

    """filter the rows returned"""
    where: shipments_bool_exp
  ): shipments_aggregate!

  """fetch data from the table: "shipments" using primary key columns"""
  shipments_by_pk(id: uuid!): shipments

  """
  fetch data from the table in a streaming manner: "shipments"
  """
  shipments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [shipments_stream_cursor_input]!

    """filter the rows returned"""
    where: shipments_bool_exp
  ): [shipments!]!

  """An array relationship"""
  trade_state_updates(
    """distinct select on columns"""
    distinct_on: [trade_state_updates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_state_updates_order_by!]

    """filter the rows returned"""
    where: trade_state_updates_bool_exp
  ): [trade_state_updates!]!

  """An aggregate relationship"""
  trade_state_updates_aggregate(
    """distinct select on columns"""
    distinct_on: [trade_state_updates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_state_updates_order_by!]

    """filter the rows returned"""
    where: trade_state_updates_bool_exp
  ): trade_state_updates_aggregate!

  """
  fetch data from the table: "trade_state_updates" using primary key columns
  """
  trade_state_updates_by_pk(id: uuid!): trade_state_updates

  """
  fetch data from the table in a streaming manner: "trade_state_updates"
  """
  trade_state_updates_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [trade_state_updates_stream_cursor_input]!

    """filter the rows returned"""
    where: trade_state_updates_bool_exp
  ): [trade_state_updates!]!

  """
  fetch data from the table: "trades"
  """
  trades(
    """distinct select on columns"""
    distinct_on: [trades_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trades_order_by!]

    """filter the rows returned"""
    where: trades_bool_exp
  ): [trades!]!

  """
  fetch aggregated fields from the table: "trades"
  """
  trades_aggregate(
    """distinct select on columns"""
    distinct_on: [trades_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trades_order_by!]

    """filter the rows returned"""
    where: trades_bool_exp
  ): trades_aggregate!

  """fetch data from the table: "trades" using primary key columns"""
  trades_by_pk(id: uuid!): trades

  """
  fetch data from the table in a streaming manner: "trades"
  """
  trades_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [trades_stream_cursor_input]!

    """filter the rows returned"""
    where: trades_bool_exp
  ): [trades!]!

  """
  fetch data from the table: "user_activities"
  """
  user_activities(
    """distinct select on columns"""
    distinct_on: [user_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_activities_order_by!]

    """filter the rows returned"""
    where: user_activities_bool_exp
  ): [user_activities!]!

  """
  fetch aggregated fields from the table: "user_activities"
  """
  user_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [user_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_activities_order_by!]

    """filter the rows returned"""
    where: user_activities_bool_exp
  ): user_activities_aggregate!

  """fetch data from the table: "user_activities" using primary key columns"""
  user_activities_by_pk(id: uuid!): user_activities

  """
  fetch data from the table in a streaming manner: "user_activities"
  """
  user_activities_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_activities_stream_cursor_input]!

    """filter the rows returned"""
    where: user_activities_bool_exp
  ): [user_activities!]!

  """
  fetch data from the table: "user_admin_informations"
  """
  user_admin_informations(
    """distinct select on columns"""
    distinct_on: [user_admin_informations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_admin_informations_order_by!]

    """filter the rows returned"""
    where: user_admin_informations_bool_exp
  ): [user_admin_informations!]!

  """
  fetch aggregated fields from the table: "user_admin_informations"
  """
  user_admin_informations_aggregate(
    """distinct select on columns"""
    distinct_on: [user_admin_informations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_admin_informations_order_by!]

    """filter the rows returned"""
    where: user_admin_informations_bool_exp
  ): user_admin_informations_aggregate!

  """
  fetch data from the table: "user_admin_informations" using primary key columns
  """
  user_admin_informations_by_pk(id: uuid!): user_admin_informations

  """
  fetch data from the table in a streaming manner: "user_admin_informations"
  """
  user_admin_informations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_admin_informations_stream_cursor_input]!

    """filter the rows returned"""
    where: user_admin_informations_bool_exp
  ): [user_admin_informations!]!

  """An array relationship"""
  user_badges(
    """distinct select on columns"""
    distinct_on: [user_badges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_badges_order_by!]

    """filter the rows returned"""
    where: user_badges_bool_exp
  ): [user_badges!]!

  """An aggregate relationship"""
  user_badges_aggregate(
    """distinct select on columns"""
    distinct_on: [user_badges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_badges_order_by!]

    """filter the rows returned"""
    where: user_badges_bool_exp
  ): user_badges_aggregate!

  """fetch data from the table: "user_badges" using primary key columns"""
  user_badges_by_pk(badge_name: badges_enum!, user_id: uuid!): user_badges

  """
  fetch data from the table in a streaming manner: "user_badges"
  """
  user_badges_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_badges_stream_cursor_input]!

    """filter the rows returned"""
    where: user_badges_bool_exp
  ): [user_badges!]!

  """An array relationship"""
  user_notifications(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): [user_notifications!]!

  """An aggregate relationship"""
  user_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): user_notifications_aggregate!

  """
  fetch data from the table: "user_notifications" using primary key columns
  """
  user_notifications_by_pk(notification_id: uuid!, notified_id: uuid!): user_notifications

  """
  fetch data from the table in a streaming manner: "user_notifications"
  """
  user_notifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_notifications_stream_cursor_input]!

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): [user_notifications!]!

  """
  fetch data from the table: "user_preferences"
  """
  user_preferences(
    """distinct select on columns"""
    distinct_on: [user_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_preferences_order_by!]

    """filter the rows returned"""
    where: user_preferences_bool_exp
  ): [user_preferences!]!

  """
  fetch aggregated fields from the table: "user_preferences"
  """
  user_preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [user_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_preferences_order_by!]

    """filter the rows returned"""
    where: user_preferences_bool_exp
  ): user_preferences_aggregate!

  """
  fetch data from the table: "user_preferences" using primary key columns
  """
  user_preferences_by_pk(id: uuid!): user_preferences

  """
  fetch data from the table in a streaming manner: "user_preferences"
  """
  user_preferences_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_preferences_stream_cursor_input]!

    """filter the rows returned"""
    where: user_preferences_bool_exp
  ): [user_preferences!]!

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users

  """
  fetch data from the table in a streaming manner: "users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch data from the table: "validators"
  """
  validators(
    """distinct select on columns"""
    distinct_on: [validators_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validators_order_by!]

    """filter the rows returned"""
    where: validators_bool_exp
  ): [validators!]!

  """
  fetch aggregated fields from the table: "validators"
  """
  validators_aggregate(
    """distinct select on columns"""
    distinct_on: [validators_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validators_order_by!]

    """filter the rows returned"""
    where: validators_bool_exp
  ): validators_aggregate!

  """fetch data from the table: "validators" using primary key columns"""
  validators_by_pk(id: uuid!): validators

  """
  fetch data from the table in a streaming manner: "validators"
  """
  validators_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [validators_stream_cursor_input]!

    """filter the rows returned"""
    where: validators_bool_exp
  ): [validators!]!

  """An array relationship"""
  wishlist_items(
    """distinct select on columns"""
    distinct_on: [wishlist_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlist_items_order_by!]

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): [wishlist_items!]!

  """An aggregate relationship"""
  wishlist_items_aggregate(
    """distinct select on columns"""
    distinct_on: [wishlist_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlist_items_order_by!]

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): wishlist_items_aggregate!

  """fetch data from the table: "wishlist_items" using primary key columns"""
  wishlist_items_by_pk(id: uuid!): wishlist_items

  """
  fetch data from the table in a streaming manner: "wishlist_items"
  """
  wishlist_items_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [wishlist_items_stream_cursor_input]!

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): [wishlist_items!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "trade_state_updates"
"""
type trade_state_updates {
  created_at: timestamptz!
  id: uuid!
  state: String!
  trade_id: uuid!
}

"""
aggregated selection of "trade_state_updates"
"""
type trade_state_updates_aggregate {
  aggregate: trade_state_updates_aggregate_fields
  nodes: [trade_state_updates!]!
}

input trade_state_updates_aggregate_bool_exp {
  count: trade_state_updates_aggregate_bool_exp_count
}

input trade_state_updates_aggregate_bool_exp_count {
  arguments: [trade_state_updates_select_column!]
  distinct: Boolean
  filter: trade_state_updates_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "trade_state_updates"
"""
type trade_state_updates_aggregate_fields {
  count(columns: [trade_state_updates_select_column!], distinct: Boolean): Int!
  max: trade_state_updates_max_fields
  min: trade_state_updates_min_fields
}

"""
order by aggregate values of table "trade_state_updates"
"""
input trade_state_updates_aggregate_order_by {
  count: order_by
  max: trade_state_updates_max_order_by
  min: trade_state_updates_min_order_by
}

"""
input type for inserting array relation for remote table "trade_state_updates"
"""
input trade_state_updates_arr_rel_insert_input {
  data: [trade_state_updates_insert_input!]!

  """upsert condition"""
  on_conflict: trade_state_updates_on_conflict
}

"""
Boolean expression to filter rows from the table "trade_state_updates". All fields are combined with a logical 'AND'.
"""
input trade_state_updates_bool_exp {
  _and: [trade_state_updates_bool_exp!]
  _not: trade_state_updates_bool_exp
  _or: [trade_state_updates_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  state: String_comparison_exp
  trade_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "trade_state_updates"
"""
enum trade_state_updates_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  trade_state_updates_pkey
}

"""
input type for inserting data into table "trade_state_updates"
"""
input trade_state_updates_insert_input {
  created_at: timestamptz
  id: uuid
  state: String
  trade_id: uuid
}

"""aggregate max on columns"""
type trade_state_updates_max_fields {
  created_at: timestamptz
  id: uuid
  state: String
  trade_id: uuid
}

"""
order by max() on columns of table "trade_state_updates"
"""
input trade_state_updates_max_order_by {
  created_at: order_by
  id: order_by
  state: order_by
  trade_id: order_by
}

"""aggregate min on columns"""
type trade_state_updates_min_fields {
  created_at: timestamptz
  id: uuid
  state: String
  trade_id: uuid
}

"""
order by min() on columns of table "trade_state_updates"
"""
input trade_state_updates_min_order_by {
  created_at: order_by
  id: order_by
  state: order_by
  trade_id: order_by
}

"""
response of any mutation on the table "trade_state_updates"
"""
type trade_state_updates_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [trade_state_updates!]!
}

"""
on_conflict condition type for table "trade_state_updates"
"""
input trade_state_updates_on_conflict {
  constraint: trade_state_updates_constraint!
  update_columns: [trade_state_updates_update_column!]! = []
  where: trade_state_updates_bool_exp
}

"""Ordering options when selecting data from "trade_state_updates"."""
input trade_state_updates_order_by {
  created_at: order_by
  id: order_by
  state: order_by
  trade_id: order_by
}

"""primary key columns input for table: trade_state_updates"""
input trade_state_updates_pk_columns_input {
  id: uuid!
}

"""
select columns of table "trade_state_updates"
"""
enum trade_state_updates_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  state

  """column name"""
  trade_id
}

"""
input type for updating data in table "trade_state_updates"
"""
input trade_state_updates_set_input {
  created_at: timestamptz
  id: uuid
  state: String
  trade_id: uuid
}

"""
Streaming cursor of the table "trade_state_updates"
"""
input trade_state_updates_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: trade_state_updates_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input trade_state_updates_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  state: String
  trade_id: uuid
}

"""
update columns of table "trade_state_updates"
"""
enum trade_state_updates_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  state

  """column name"""
  trade_id
}

input trade_state_updates_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: trade_state_updates_set_input

  """filter the rows which have to be updated"""
  where: trade_state_updates_bool_exp!
}

"""
columns and relationships of "trades"
"""
type trades {
  confirmed_trade_date: timestamptz
  created_at: timestamptz!
  creator_user_validation_expiration_date: timestamptz
  deleted_at: Int!
  id: uuid!
  note: String
  offer_id: uuid!
  on_hold_expiration_date: timestamptz
  origin: String
  receiver_user_validation_expiration_date: timestamptz
  state: String!
  trade_flow_version: Int!

  """An array relationship"""
  trade_state_updates(
    """distinct select on columns"""
    distinct_on: [trade_state_updates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_state_updates_order_by!]

    """filter the rows returned"""
    where: trade_state_updates_bool_exp
  ): [trade_state_updates!]!

  """An aggregate relationship"""
  trade_state_updates_aggregate(
    """distinct select on columns"""
    distinct_on: [trade_state_updates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trade_state_updates_order_by!]

    """filter the rows returned"""
    where: trade_state_updates_bool_exp
  ): trade_state_updates_aggregate!
  updated_at: timestamptz!
  validation_passed_date: timestamptz
}

"""
aggregated selection of "trades"
"""
type trades_aggregate {
  aggregate: trades_aggregate_fields
  nodes: [trades!]!
}

"""
aggregate fields of "trades"
"""
type trades_aggregate_fields {
  avg: trades_avg_fields
  count(columns: [trades_select_column!], distinct: Boolean): Int!
  max: trades_max_fields
  min: trades_min_fields
  stddev: trades_stddev_fields
  stddev_pop: trades_stddev_pop_fields
  stddev_samp: trades_stddev_samp_fields
  sum: trades_sum_fields
  var_pop: trades_var_pop_fields
  var_samp: trades_var_samp_fields
  variance: trades_variance_fields
}

"""aggregate avg on columns"""
type trades_avg_fields {
  deleted_at: Float
  trade_flow_version: Float
}

"""
Boolean expression to filter rows from the table "trades". All fields are combined with a logical 'AND'.
"""
input trades_bool_exp {
  _and: [trades_bool_exp!]
  _not: trades_bool_exp
  _or: [trades_bool_exp!]
  confirmed_trade_date: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  creator_user_validation_expiration_date: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  note: String_comparison_exp
  offer_id: uuid_comparison_exp
  on_hold_expiration_date: timestamptz_comparison_exp
  origin: String_comparison_exp
  receiver_user_validation_expiration_date: timestamptz_comparison_exp
  state: String_comparison_exp
  trade_flow_version: Int_comparison_exp
  trade_state_updates: trade_state_updates_bool_exp
  trade_state_updates_aggregate: trade_state_updates_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  validation_passed_date: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "trades"
"""
enum trades_constraint {
  """
  unique or primary key constraint on columns "offer_id"
  """
  trades_offer_id_key

  """
  unique or primary key constraint on columns "id"
  """
  trades_pkey
}

"""
input type for incrementing numeric columns in table "trades"
"""
input trades_inc_input {
  deleted_at: Int
  trade_flow_version: Int
}

"""
input type for inserting data into table "trades"
"""
input trades_insert_input {
  confirmed_trade_date: timestamptz
  created_at: timestamptz
  creator_user_validation_expiration_date: timestamptz
  deleted_at: Int
  id: uuid
  note: String
  offer_id: uuid
  on_hold_expiration_date: timestamptz
  origin: String
  receiver_user_validation_expiration_date: timestamptz
  state: String
  trade_flow_version: Int
  trade_state_updates: trade_state_updates_arr_rel_insert_input
  updated_at: timestamptz
  validation_passed_date: timestamptz
}

"""aggregate max on columns"""
type trades_max_fields {
  confirmed_trade_date: timestamptz
  created_at: timestamptz
  creator_user_validation_expiration_date: timestamptz
  deleted_at: Int
  id: uuid
  note: String
  offer_id: uuid
  on_hold_expiration_date: timestamptz
  origin: String
  receiver_user_validation_expiration_date: timestamptz
  state: String
  trade_flow_version: Int
  updated_at: timestamptz
  validation_passed_date: timestamptz
}

"""aggregate min on columns"""
type trades_min_fields {
  confirmed_trade_date: timestamptz
  created_at: timestamptz
  creator_user_validation_expiration_date: timestamptz
  deleted_at: Int
  id: uuid
  note: String
  offer_id: uuid
  on_hold_expiration_date: timestamptz
  origin: String
  receiver_user_validation_expiration_date: timestamptz
  state: String
  trade_flow_version: Int
  updated_at: timestamptz
  validation_passed_date: timestamptz
}

"""
response of any mutation on the table "trades"
"""
type trades_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [trades!]!
}

"""
input type for inserting object relation for remote table "trades"
"""
input trades_obj_rel_insert_input {
  data: trades_insert_input!

  """upsert condition"""
  on_conflict: trades_on_conflict
}

"""
on_conflict condition type for table "trades"
"""
input trades_on_conflict {
  constraint: trades_constraint!
  update_columns: [trades_update_column!]! = []
  where: trades_bool_exp
}

"""Ordering options when selecting data from "trades"."""
input trades_order_by {
  confirmed_trade_date: order_by
  created_at: order_by
  creator_user_validation_expiration_date: order_by
  deleted_at: order_by
  id: order_by
  note: order_by
  offer_id: order_by
  on_hold_expiration_date: order_by
  origin: order_by
  receiver_user_validation_expiration_date: order_by
  state: order_by
  trade_flow_version: order_by
  trade_state_updates_aggregate: trade_state_updates_aggregate_order_by
  updated_at: order_by
  validation_passed_date: order_by
}

"""primary key columns input for table: trades"""
input trades_pk_columns_input {
  id: uuid!
}

"""
select columns of table "trades"
"""
enum trades_select_column {
  """column name"""
  confirmed_trade_date

  """column name"""
  created_at

  """column name"""
  creator_user_validation_expiration_date

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  note

  """column name"""
  offer_id

  """column name"""
  on_hold_expiration_date

  """column name"""
  origin

  """column name"""
  receiver_user_validation_expiration_date

  """column name"""
  state

  """column name"""
  trade_flow_version

  """column name"""
  updated_at

  """column name"""
  validation_passed_date
}

"""
input type for updating data in table "trades"
"""
input trades_set_input {
  confirmed_trade_date: timestamptz
  created_at: timestamptz
  creator_user_validation_expiration_date: timestamptz
  deleted_at: Int
  id: uuid
  note: String
  offer_id: uuid
  on_hold_expiration_date: timestamptz
  origin: String
  receiver_user_validation_expiration_date: timestamptz
  state: String
  trade_flow_version: Int
  updated_at: timestamptz
  validation_passed_date: timestamptz
}

"""aggregate stddev on columns"""
type trades_stddev_fields {
  deleted_at: Float
  trade_flow_version: Float
}

"""aggregate stddev_pop on columns"""
type trades_stddev_pop_fields {
  deleted_at: Float
  trade_flow_version: Float
}

"""aggregate stddev_samp on columns"""
type trades_stddev_samp_fields {
  deleted_at: Float
  trade_flow_version: Float
}

"""
Streaming cursor of the table "trades"
"""
input trades_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: trades_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input trades_stream_cursor_value_input {
  confirmed_trade_date: timestamptz
  created_at: timestamptz
  creator_user_validation_expiration_date: timestamptz
  deleted_at: Int
  id: uuid
  note: String
  offer_id: uuid
  on_hold_expiration_date: timestamptz
  origin: String
  receiver_user_validation_expiration_date: timestamptz
  state: String
  trade_flow_version: Int
  updated_at: timestamptz
  validation_passed_date: timestamptz
}

"""aggregate sum on columns"""
type trades_sum_fields {
  deleted_at: Int
  trade_flow_version: Int
}

"""
update columns of table "trades"
"""
enum trades_update_column {
  """column name"""
  confirmed_trade_date

  """column name"""
  created_at

  """column name"""
  creator_user_validation_expiration_date

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  note

  """column name"""
  offer_id

  """column name"""
  on_hold_expiration_date

  """column name"""
  origin

  """column name"""
  receiver_user_validation_expiration_date

  """column name"""
  state

  """column name"""
  trade_flow_version

  """column name"""
  updated_at

  """column name"""
  validation_passed_date
}

input trades_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: trades_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: trades_set_input

  """filter the rows which have to be updated"""
  where: trades_bool_exp!
}

"""aggregate var_pop on columns"""
type trades_var_pop_fields {
  deleted_at: Float
  trade_flow_version: Float
}

"""aggregate var_samp on columns"""
type trades_var_samp_fields {
  deleted_at: Float
  trade_flow_version: Float
}

"""aggregate variance on columns"""
type trades_variance_fields {
  deleted_at: Float
  trade_flow_version: Float
}

"""Record of user activity, with at most one record per day."""
type user_activities {
  id: uuid!
  last_active: timestamptz!
  last_streak_update: timestamptz!
  streak_count: Int!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "user_activities"
"""
type user_activities_aggregate {
  aggregate: user_activities_aggregate_fields
  nodes: [user_activities!]!
}

"""
aggregate fields of "user_activities"
"""
type user_activities_aggregate_fields {
  avg: user_activities_avg_fields
  count(columns: [user_activities_select_column!], distinct: Boolean): Int!
  max: user_activities_max_fields
  min: user_activities_min_fields
  stddev: user_activities_stddev_fields
  stddev_pop: user_activities_stddev_pop_fields
  stddev_samp: user_activities_stddev_samp_fields
  sum: user_activities_sum_fields
  var_pop: user_activities_var_pop_fields
  var_samp: user_activities_var_samp_fields
  variance: user_activities_variance_fields
}

"""aggregate avg on columns"""
type user_activities_avg_fields {
  streak_count: Float
}

"""
Boolean expression to filter rows from the table "user_activities". All fields are combined with a logical 'AND'.
"""
input user_activities_bool_exp {
  _and: [user_activities_bool_exp!]
  _not: user_activities_bool_exp
  _or: [user_activities_bool_exp!]
  id: uuid_comparison_exp
  last_active: timestamptz_comparison_exp
  last_streak_update: timestamptz_comparison_exp
  streak_count: Int_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_activities"
"""
enum user_activities_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_activities_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  user_activities_user_id_key
}

"""
input type for incrementing numeric columns in table "user_activities"
"""
input user_activities_inc_input {
  streak_count: Int
}

"""
input type for inserting data into table "user_activities"
"""
input user_activities_insert_input {
  id: uuid
  last_active: timestamptz
  last_streak_update: timestamptz
  streak_count: Int
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type user_activities_max_fields {
  id: uuid
  last_active: timestamptz
  last_streak_update: timestamptz
  streak_count: Int
  user_id: uuid
}

"""aggregate min on columns"""
type user_activities_min_fields {
  id: uuid
  last_active: timestamptz
  last_streak_update: timestamptz
  streak_count: Int
  user_id: uuid
}

"""
response of any mutation on the table "user_activities"
"""
type user_activities_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_activities!]!
}

"""
input type for inserting object relation for remote table "user_activities"
"""
input user_activities_obj_rel_insert_input {
  data: user_activities_insert_input!

  """upsert condition"""
  on_conflict: user_activities_on_conflict
}

"""
on_conflict condition type for table "user_activities"
"""
input user_activities_on_conflict {
  constraint: user_activities_constraint!
  update_columns: [user_activities_update_column!]! = []
  where: user_activities_bool_exp
}

"""Ordering options when selecting data from "user_activities"."""
input user_activities_order_by {
  id: order_by
  last_active: order_by
  last_streak_update: order_by
  streak_count: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: user_activities"""
input user_activities_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_activities"
"""
enum user_activities_select_column {
  """column name"""
  id

  """column name"""
  last_active

  """column name"""
  last_streak_update

  """column name"""
  streak_count

  """column name"""
  user_id
}

"""
input type for updating data in table "user_activities"
"""
input user_activities_set_input {
  id: uuid
  last_active: timestamptz
  last_streak_update: timestamptz
  streak_count: Int
  user_id: uuid
}

"""aggregate stddev on columns"""
type user_activities_stddev_fields {
  streak_count: Float
}

"""aggregate stddev_pop on columns"""
type user_activities_stddev_pop_fields {
  streak_count: Float
}

"""aggregate stddev_samp on columns"""
type user_activities_stddev_samp_fields {
  streak_count: Float
}

"""
Streaming cursor of the table "user_activities"
"""
input user_activities_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_activities_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_activities_stream_cursor_value_input {
  id: uuid
  last_active: timestamptz
  last_streak_update: timestamptz
  streak_count: Int
  user_id: uuid
}

"""aggregate sum on columns"""
type user_activities_sum_fields {
  streak_count: Int
}

"""
update columns of table "user_activities"
"""
enum user_activities_update_column {
  """column name"""
  id

  """column name"""
  last_active

  """column name"""
  last_streak_update

  """column name"""
  streak_count

  """column name"""
  user_id
}

input user_activities_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_activities_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_activities_set_input

  """filter the rows which have to be updated"""
  where: user_activities_bool_exp!
}

"""aggregate var_pop on columns"""
type user_activities_var_pop_fields {
  streak_count: Float
}

"""aggregate var_samp on columns"""
type user_activities_var_samp_fields {
  streak_count: Float
}

"""aggregate variance on columns"""
type user_activities_variance_fields {
  streak_count: Float
}

"""Information about a user meant for admin use."""
type user_admin_informations {
  carrier_rate_token: String
  created_at: timestamptz!
  deleted_at: Int!
  discounted_offer_id: uuid
  discounted_purchase_offer_id: uuid
  entered_referral_code: String
  force_trusted_trader_candidate: Boolean!
  free_tradeblock_secure: Boolean!
  freeze_reason: String
  id: uuid!
  is_bounty_program_member: Boolean!
  is_seller_fee_free: Boolean!
  is_suspect: Boolean!
  is_trusted_trader_candidate: Boolean!
  is_vip: Boolean!
  personal_referral_code: String!
  purchase_limit_expiration_date: timestamptz
  role: roles_enum
  service_fee: numeric
  should_skip_address_validation: Boolean!
  stripe_connected_account_id: String
  stripe_customer_id: String!
  trusted_trader_requirements_start_date: timestamp
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
  weekly_purchases: Int!
}

"""
aggregated selection of "user_admin_informations"
"""
type user_admin_informations_aggregate {
  aggregate: user_admin_informations_aggregate_fields
  nodes: [user_admin_informations!]!
}

"""
aggregate fields of "user_admin_informations"
"""
type user_admin_informations_aggregate_fields {
  avg: user_admin_informations_avg_fields
  count(columns: [user_admin_informations_select_column!], distinct: Boolean): Int!
  max: user_admin_informations_max_fields
  min: user_admin_informations_min_fields
  stddev: user_admin_informations_stddev_fields
  stddev_pop: user_admin_informations_stddev_pop_fields
  stddev_samp: user_admin_informations_stddev_samp_fields
  sum: user_admin_informations_sum_fields
  var_pop: user_admin_informations_var_pop_fields
  var_samp: user_admin_informations_var_samp_fields
  variance: user_admin_informations_variance_fields
}

"""aggregate avg on columns"""
type user_admin_informations_avg_fields {
  deleted_at: Float
  service_fee: Float
  weekly_purchases: Float
}

"""
Boolean expression to filter rows from the table "user_admin_informations". All fields are combined with a logical 'AND'.
"""
input user_admin_informations_bool_exp {
  _and: [user_admin_informations_bool_exp!]
  _not: user_admin_informations_bool_exp
  _or: [user_admin_informations_bool_exp!]
  carrier_rate_token: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  discounted_offer_id: uuid_comparison_exp
  discounted_purchase_offer_id: uuid_comparison_exp
  entered_referral_code: String_comparison_exp
  force_trusted_trader_candidate: Boolean_comparison_exp
  free_tradeblock_secure: Boolean_comparison_exp
  freeze_reason: String_comparison_exp
  id: uuid_comparison_exp
  is_bounty_program_member: Boolean_comparison_exp
  is_seller_fee_free: Boolean_comparison_exp
  is_suspect: Boolean_comparison_exp
  is_trusted_trader_candidate: Boolean_comparison_exp
  is_vip: Boolean_comparison_exp
  personal_referral_code: String_comparison_exp
  purchase_limit_expiration_date: timestamptz_comparison_exp
  role: roles_enum_comparison_exp
  service_fee: numeric_comparison_exp
  should_skip_address_validation: Boolean_comparison_exp
  stripe_connected_account_id: String_comparison_exp
  stripe_customer_id: String_comparison_exp
  trusted_trader_requirements_start_date: timestamp_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
  weekly_purchases: Int_comparison_exp
}

"""
unique or primary key constraints on table "user_admin_informations"
"""
enum user_admin_informations_constraint {
  """
  unique or primary key constraint on columns "personal_referral_code"
  """
  user_admin_informations_personal_referral_code_key

  """
  unique or primary key constraint on columns "id"
  """
  user_admin_informations_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  user_admin_informations_user_id_key
}

"""
input type for incrementing numeric columns in table "user_admin_informations"
"""
input user_admin_informations_inc_input {
  deleted_at: Int
  service_fee: numeric
  weekly_purchases: Int
}

"""
input type for inserting data into table "user_admin_informations"
"""
input user_admin_informations_insert_input {
  carrier_rate_token: String
  created_at: timestamptz
  deleted_at: Int
  discounted_offer_id: uuid
  discounted_purchase_offer_id: uuid
  entered_referral_code: String
  force_trusted_trader_candidate: Boolean
  free_tradeblock_secure: Boolean
  freeze_reason: String
  id: uuid
  is_bounty_program_member: Boolean
  is_seller_fee_free: Boolean
  is_suspect: Boolean
  is_trusted_trader_candidate: Boolean
  is_vip: Boolean
  personal_referral_code: String
  purchase_limit_expiration_date: timestamptz
  role: roles_enum
  service_fee: numeric
  should_skip_address_validation: Boolean
  stripe_connected_account_id: String
  stripe_customer_id: String
  trusted_trader_requirements_start_date: timestamp
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
  weekly_purchases: Int
}

"""aggregate max on columns"""
type user_admin_informations_max_fields {
  carrier_rate_token: String
  created_at: timestamptz
  deleted_at: Int
  discounted_offer_id: uuid
  discounted_purchase_offer_id: uuid
  entered_referral_code: String
  freeze_reason: String
  id: uuid
  personal_referral_code: String
  purchase_limit_expiration_date: timestamptz
  service_fee: numeric
  stripe_connected_account_id: String
  stripe_customer_id: String
  trusted_trader_requirements_start_date: timestamp
  updated_at: timestamptz
  user_id: uuid
  weekly_purchases: Int
}

"""aggregate min on columns"""
type user_admin_informations_min_fields {
  carrier_rate_token: String
  created_at: timestamptz
  deleted_at: Int
  discounted_offer_id: uuid
  discounted_purchase_offer_id: uuid
  entered_referral_code: String
  freeze_reason: String
  id: uuid
  personal_referral_code: String
  purchase_limit_expiration_date: timestamptz
  service_fee: numeric
  stripe_connected_account_id: String
  stripe_customer_id: String
  trusted_trader_requirements_start_date: timestamp
  updated_at: timestamptz
  user_id: uuid
  weekly_purchases: Int
}

"""
response of any mutation on the table "user_admin_informations"
"""
type user_admin_informations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_admin_informations!]!
}

"""
input type for inserting object relation for remote table "user_admin_informations"
"""
input user_admin_informations_obj_rel_insert_input {
  data: user_admin_informations_insert_input!

  """upsert condition"""
  on_conflict: user_admin_informations_on_conflict
}

"""
on_conflict condition type for table "user_admin_informations"
"""
input user_admin_informations_on_conflict {
  constraint: user_admin_informations_constraint!
  update_columns: [user_admin_informations_update_column!]! = []
  where: user_admin_informations_bool_exp
}

"""Ordering options when selecting data from "user_admin_informations"."""
input user_admin_informations_order_by {
  carrier_rate_token: order_by
  created_at: order_by
  deleted_at: order_by
  discounted_offer_id: order_by
  discounted_purchase_offer_id: order_by
  entered_referral_code: order_by
  force_trusted_trader_candidate: order_by
  free_tradeblock_secure: order_by
  freeze_reason: order_by
  id: order_by
  is_bounty_program_member: order_by
  is_seller_fee_free: order_by
  is_suspect: order_by
  is_trusted_trader_candidate: order_by
  is_vip: order_by
  personal_referral_code: order_by
  purchase_limit_expiration_date: order_by
  role: order_by
  service_fee: order_by
  should_skip_address_validation: order_by
  stripe_connected_account_id: order_by
  stripe_customer_id: order_by
  trusted_trader_requirements_start_date: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
  weekly_purchases: order_by
}

"""primary key columns input for table: user_admin_informations"""
input user_admin_informations_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_admin_informations"
"""
enum user_admin_informations_select_column {
  """column name"""
  carrier_rate_token

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  discounted_offer_id

  """column name"""
  discounted_purchase_offer_id

  """column name"""
  entered_referral_code

  """column name"""
  force_trusted_trader_candidate

  """column name"""
  free_tradeblock_secure

  """column name"""
  freeze_reason

  """column name"""
  id

  """column name"""
  is_bounty_program_member

  """column name"""
  is_seller_fee_free

  """column name"""
  is_suspect

  """column name"""
  is_trusted_trader_candidate

  """column name"""
  is_vip

  """column name"""
  personal_referral_code

  """column name"""
  purchase_limit_expiration_date

  """column name"""
  role

  """column name"""
  service_fee

  """column name"""
  should_skip_address_validation

  """column name"""
  stripe_connected_account_id

  """column name"""
  stripe_customer_id

  """column name"""
  trusted_trader_requirements_start_date

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  weekly_purchases
}

"""
input type for updating data in table "user_admin_informations"
"""
input user_admin_informations_set_input {
  carrier_rate_token: String
  created_at: timestamptz
  deleted_at: Int
  discounted_offer_id: uuid
  discounted_purchase_offer_id: uuid
  entered_referral_code: String
  force_trusted_trader_candidate: Boolean
  free_tradeblock_secure: Boolean
  freeze_reason: String
  id: uuid
  is_bounty_program_member: Boolean
  is_seller_fee_free: Boolean
  is_suspect: Boolean
  is_trusted_trader_candidate: Boolean
  is_vip: Boolean
  personal_referral_code: String
  purchase_limit_expiration_date: timestamptz
  role: roles_enum
  service_fee: numeric
  should_skip_address_validation: Boolean
  stripe_connected_account_id: String
  stripe_customer_id: String
  trusted_trader_requirements_start_date: timestamp
  updated_at: timestamptz
  user_id: uuid
  weekly_purchases: Int
}

"""aggregate stddev on columns"""
type user_admin_informations_stddev_fields {
  deleted_at: Float
  service_fee: Float
  weekly_purchases: Float
}

"""aggregate stddev_pop on columns"""
type user_admin_informations_stddev_pop_fields {
  deleted_at: Float
  service_fee: Float
  weekly_purchases: Float
}

"""aggregate stddev_samp on columns"""
type user_admin_informations_stddev_samp_fields {
  deleted_at: Float
  service_fee: Float
  weekly_purchases: Float
}

"""
Streaming cursor of the table "user_admin_informations"
"""
input user_admin_informations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_admin_informations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_admin_informations_stream_cursor_value_input {
  carrier_rate_token: String
  created_at: timestamptz
  deleted_at: Int
  discounted_offer_id: uuid
  discounted_purchase_offer_id: uuid
  entered_referral_code: String
  force_trusted_trader_candidate: Boolean
  free_tradeblock_secure: Boolean
  freeze_reason: String
  id: uuid
  is_bounty_program_member: Boolean
  is_seller_fee_free: Boolean
  is_suspect: Boolean
  is_trusted_trader_candidate: Boolean
  is_vip: Boolean
  personal_referral_code: String
  purchase_limit_expiration_date: timestamptz
  role: roles_enum
  service_fee: numeric
  should_skip_address_validation: Boolean
  stripe_connected_account_id: String
  stripe_customer_id: String
  trusted_trader_requirements_start_date: timestamp
  updated_at: timestamptz
  user_id: uuid
  weekly_purchases: Int
}

"""aggregate sum on columns"""
type user_admin_informations_sum_fields {
  deleted_at: Int
  service_fee: numeric
  weekly_purchases: Int
}

"""
update columns of table "user_admin_informations"
"""
enum user_admin_informations_update_column {
  """column name"""
  carrier_rate_token

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  discounted_offer_id

  """column name"""
  discounted_purchase_offer_id

  """column name"""
  entered_referral_code

  """column name"""
  force_trusted_trader_candidate

  """column name"""
  free_tradeblock_secure

  """column name"""
  freeze_reason

  """column name"""
  id

  """column name"""
  is_bounty_program_member

  """column name"""
  is_seller_fee_free

  """column name"""
  is_suspect

  """column name"""
  is_trusted_trader_candidate

  """column name"""
  is_vip

  """column name"""
  personal_referral_code

  """column name"""
  purchase_limit_expiration_date

  """column name"""
  role

  """column name"""
  service_fee

  """column name"""
  should_skip_address_validation

  """column name"""
  stripe_connected_account_id

  """column name"""
  stripe_customer_id

  """column name"""
  trusted_trader_requirements_start_date

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  weekly_purchases
}

input user_admin_informations_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_admin_informations_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_admin_informations_set_input

  """filter the rows which have to be updated"""
  where: user_admin_informations_bool_exp!
}

"""aggregate var_pop on columns"""
type user_admin_informations_var_pop_fields {
  deleted_at: Float
  service_fee: Float
  weekly_purchases: Float
}

"""aggregate var_samp on columns"""
type user_admin_informations_var_samp_fields {
  deleted_at: Float
  service_fee: Float
  weekly_purchases: Float
}

"""aggregate variance on columns"""
type user_admin_informations_variance_fields {
  deleted_at: Float
  service_fee: Float
  weekly_purchases: Float
}

"""
columns and relationships of "user_badges"
"""
type user_badges {
  """An object relationship"""
  badge: badges!
  badge_name: badges_enum!
  user_id: uuid!
}

"""
aggregated selection of "user_badges"
"""
type user_badges_aggregate {
  aggregate: user_badges_aggregate_fields
  nodes: [user_badges!]!
}

input user_badges_aggregate_bool_exp {
  count: user_badges_aggregate_bool_exp_count
}

input user_badges_aggregate_bool_exp_count {
  arguments: [user_badges_select_column!]
  distinct: Boolean
  filter: user_badges_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_badges"
"""
type user_badges_aggregate_fields {
  count(columns: [user_badges_select_column!], distinct: Boolean): Int!
  max: user_badges_max_fields
  min: user_badges_min_fields
}

"""
order by aggregate values of table "user_badges"
"""
input user_badges_aggregate_order_by {
  count: order_by
  max: user_badges_max_order_by
  min: user_badges_min_order_by
}

"""
input type for inserting array relation for remote table "user_badges"
"""
input user_badges_arr_rel_insert_input {
  data: [user_badges_insert_input!]!

  """upsert condition"""
  on_conflict: user_badges_on_conflict
}

"""
Boolean expression to filter rows from the table "user_badges". All fields are combined with a logical 'AND'.
"""
input user_badges_bool_exp {
  _and: [user_badges_bool_exp!]
  _not: user_badges_bool_exp
  _or: [user_badges_bool_exp!]
  badge: badges_bool_exp
  badge_name: badges_enum_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_badges"
"""
enum user_badges_constraint {
  """
  unique or primary key constraint on columns "user_id", "badge_name"
  """
  user_badges_pkey
}

"""
input type for inserting data into table "user_badges"
"""
input user_badges_insert_input {
  badge: badges_obj_rel_insert_input
  badge_name: badges_enum
  user_id: uuid
}

"""aggregate max on columns"""
type user_badges_max_fields {
  user_id: uuid
}

"""
order by max() on columns of table "user_badges"
"""
input user_badges_max_order_by {
  user_id: order_by
}

"""aggregate min on columns"""
type user_badges_min_fields {
  user_id: uuid
}

"""
order by min() on columns of table "user_badges"
"""
input user_badges_min_order_by {
  user_id: order_by
}

"""
response of any mutation on the table "user_badges"
"""
type user_badges_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_badges!]!
}

"""
on_conflict condition type for table "user_badges"
"""
input user_badges_on_conflict {
  constraint: user_badges_constraint!
  update_columns: [user_badges_update_column!]! = []
  where: user_badges_bool_exp
}

"""Ordering options when selecting data from "user_badges"."""
input user_badges_order_by {
  badge: badges_order_by
  badge_name: order_by
  user_id: order_by
}

"""primary key columns input for table: user_badges"""
input user_badges_pk_columns_input {
  badge_name: badges_enum!
  user_id: uuid!
}

"""
select columns of table "user_badges"
"""
enum user_badges_select_column {
  """column name"""
  badge_name

  """column name"""
  user_id
}

"""
input type for updating data in table "user_badges"
"""
input user_badges_set_input {
  badge_name: badges_enum
  user_id: uuid
}

"""
Streaming cursor of the table "user_badges"
"""
input user_badges_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_badges_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_badges_stream_cursor_value_input {
  badge_name: badges_enum
  user_id: uuid
}

"""
update columns of table "user_badges"
"""
enum user_badges_update_column {
  """column name"""
  badge_name

  """column name"""
  user_id
}

input user_badges_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_badges_set_input

  """filter the rows which have to be updated"""
  where: user_badges_bool_exp!
}

"""
Holds users that should be notified of a given user-instigated notification.
"""
type user_notifications {
  """An object relationship"""
  notification: notifications!
  notification_id: uuid!
  notified_id: uuid!

  """An object relationship"""
  notified_user: users!
  read_at: timestamptz
}

"""
aggregated selection of "user_notifications"
"""
type user_notifications_aggregate {
  aggregate: user_notifications_aggregate_fields
  nodes: [user_notifications!]!
}

input user_notifications_aggregate_bool_exp {
  count: user_notifications_aggregate_bool_exp_count
}

input user_notifications_aggregate_bool_exp_count {
  arguments: [user_notifications_select_column!]
  distinct: Boolean
  filter: user_notifications_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_notifications"
"""
type user_notifications_aggregate_fields {
  count(columns: [user_notifications_select_column!], distinct: Boolean): Int!
  max: user_notifications_max_fields
  min: user_notifications_min_fields
}

"""
order by aggregate values of table "user_notifications"
"""
input user_notifications_aggregate_order_by {
  count: order_by
  max: user_notifications_max_order_by
  min: user_notifications_min_order_by
}

"""
input type for inserting array relation for remote table "user_notifications"
"""
input user_notifications_arr_rel_insert_input {
  data: [user_notifications_insert_input!]!

  """upsert condition"""
  on_conflict: user_notifications_on_conflict
}

"""
Boolean expression to filter rows from the table "user_notifications". All fields are combined with a logical 'AND'.
"""
input user_notifications_bool_exp {
  _and: [user_notifications_bool_exp!]
  _not: user_notifications_bool_exp
  _or: [user_notifications_bool_exp!]
  notification: notifications_bool_exp
  notification_id: uuid_comparison_exp
  notified_id: uuid_comparison_exp
  notified_user: users_bool_exp
  read_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "user_notifications"
"""
enum user_notifications_constraint {
  """
  unique or primary key constraint on columns "notified_id", "notification_id"
  """
  user_notifications_pkey
}

"""
input type for inserting data into table "user_notifications"
"""
input user_notifications_insert_input {
  notification: notifications_obj_rel_insert_input
  notification_id: uuid
  notified_id: uuid
  notified_user: users_obj_rel_insert_input
  read_at: timestamptz
}

"""aggregate max on columns"""
type user_notifications_max_fields {
  notification_id: uuid
  notified_id: uuid
  read_at: timestamptz
}

"""
order by max() on columns of table "user_notifications"
"""
input user_notifications_max_order_by {
  notification_id: order_by
  notified_id: order_by
  read_at: order_by
}

"""aggregate min on columns"""
type user_notifications_min_fields {
  notification_id: uuid
  notified_id: uuid
  read_at: timestamptz
}

"""
order by min() on columns of table "user_notifications"
"""
input user_notifications_min_order_by {
  notification_id: order_by
  notified_id: order_by
  read_at: order_by
}

"""
response of any mutation on the table "user_notifications"
"""
type user_notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_notifications!]!
}

"""
on_conflict condition type for table "user_notifications"
"""
input user_notifications_on_conflict {
  constraint: user_notifications_constraint!
  update_columns: [user_notifications_update_column!]! = []
  where: user_notifications_bool_exp
}

"""Ordering options when selecting data from "user_notifications"."""
input user_notifications_order_by {
  notification: notifications_order_by
  notification_id: order_by
  notified_id: order_by
  notified_user: users_order_by
  read_at: order_by
}

"""primary key columns input for table: user_notifications"""
input user_notifications_pk_columns_input {
  notification_id: uuid!
  notified_id: uuid!
}

"""
select columns of table "user_notifications"
"""
enum user_notifications_select_column {
  """column name"""
  notification_id

  """column name"""
  notified_id

  """column name"""
  read_at
}

"""
input type for updating data in table "user_notifications"
"""
input user_notifications_set_input {
  notification_id: uuid
  notified_id: uuid
  read_at: timestamptz
}

"""
Streaming cursor of the table "user_notifications"
"""
input user_notifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_notifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_notifications_stream_cursor_value_input {
  notification_id: uuid
  notified_id: uuid
  read_at: timestamptz
}

"""
update columns of table "user_notifications"
"""
enum user_notifications_update_column {
  """column name"""
  notification_id

  """column name"""
  notified_id

  """column name"""
  read_at
}

input user_notifications_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_notifications_set_input

  """filter the rows which have to be updated"""
  where: user_notifications_bool_exp!
}

"""Preferences or dislikes a user has."""
type user_preferences {
  """An array relationship"""
  attribute_preferences(
    """distinct select on columns"""
    distinct_on: [attribute_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_preferences_order_by!]

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): [attribute_preferences!]!

  """An aggregate relationship"""
  attribute_preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_preferences_order_by!]

    """filter the rows returned"""
    where: attribute_preferences_bool_exp
  ): attribute_preferences_aggregate!
  block_private_bids: Boolean!

  """An array relationship"""
  communication_preferences(
    """distinct select on columns"""
    distinct_on: [communication_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_preferences_order_by!]

    """filter the rows returned"""
    where: communication_preferences_bool_exp
  ): [communication_preferences!]!

  """An aggregate relationship"""
  communication_preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [communication_preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [communication_preferences_order_by!]

    """filter the rows returned"""
    where: communication_preferences_bool_exp
  ): communication_preferences_aggregate!
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!

  """An object relationship"""
  language: languages
  language_code: String
  only_accept_size_match: Boolean!
  only_accept_wishlist_match: Boolean!
  public_total_closet_value: Boolean!
  updated_at: timestamptz!
  use_dark_mode: Boolean
  use_vacation_mode: Boolean

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "user_preferences"
"""
type user_preferences_aggregate {
  aggregate: user_preferences_aggregate_fields
  nodes: [user_preferences!]!
}

"""
aggregate fields of "user_preferences"
"""
type user_preferences_aggregate_fields {
  avg: user_preferences_avg_fields
  count(columns: [user_preferences_select_column!], distinct: Boolean): Int!
  max: user_preferences_max_fields
  min: user_preferences_min_fields
  stddev: user_preferences_stddev_fields
  stddev_pop: user_preferences_stddev_pop_fields
  stddev_samp: user_preferences_stddev_samp_fields
  sum: user_preferences_sum_fields
  var_pop: user_preferences_var_pop_fields
  var_samp: user_preferences_var_samp_fields
  variance: user_preferences_variance_fields
}

"""aggregate avg on columns"""
type user_preferences_avg_fields {
  deleted_at: Float
}

"""
Boolean expression to filter rows from the table "user_preferences". All fields are combined with a logical 'AND'.
"""
input user_preferences_bool_exp {
  _and: [user_preferences_bool_exp!]
  _not: user_preferences_bool_exp
  _or: [user_preferences_bool_exp!]
  attribute_preferences: attribute_preferences_bool_exp
  attribute_preferences_aggregate: attribute_preferences_aggregate_bool_exp
  block_private_bids: Boolean_comparison_exp
  communication_preferences: communication_preferences_bool_exp
  communication_preferences_aggregate: communication_preferences_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  language: languages_bool_exp
  language_code: String_comparison_exp
  only_accept_size_match: Boolean_comparison_exp
  only_accept_wishlist_match: Boolean_comparison_exp
  public_total_closet_value: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
  use_dark_mode: Boolean_comparison_exp
  use_vacation_mode: Boolean_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_preferences"
"""
enum user_preferences_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_preferences_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  user_preferences_user_id_key
}

"""
input type for incrementing numeric columns in table "user_preferences"
"""
input user_preferences_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "user_preferences"
"""
input user_preferences_insert_input {
  attribute_preferences: attribute_preferences_arr_rel_insert_input
  block_private_bids: Boolean
  communication_preferences: communication_preferences_arr_rel_insert_input
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  language: languages_obj_rel_insert_input
  language_code: String
  only_accept_size_match: Boolean
  only_accept_wishlist_match: Boolean
  public_total_closet_value: Boolean
  updated_at: timestamptz
  use_dark_mode: Boolean
  use_vacation_mode: Boolean
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type user_preferences_max_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  language_code: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type user_preferences_min_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  language_code: String
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "user_preferences"
"""
type user_preferences_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_preferences!]!
}

"""
input type for inserting object relation for remote table "user_preferences"
"""
input user_preferences_obj_rel_insert_input {
  data: user_preferences_insert_input!

  """upsert condition"""
  on_conflict: user_preferences_on_conflict
}

"""
on_conflict condition type for table "user_preferences"
"""
input user_preferences_on_conflict {
  constraint: user_preferences_constraint!
  update_columns: [user_preferences_update_column!]! = []
  where: user_preferences_bool_exp
}

"""Ordering options when selecting data from "user_preferences"."""
input user_preferences_order_by {
  attribute_preferences_aggregate: attribute_preferences_aggregate_order_by
  block_private_bids: order_by
  communication_preferences_aggregate: communication_preferences_aggregate_order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  language: languages_order_by
  language_code: order_by
  only_accept_size_match: order_by
  only_accept_wishlist_match: order_by
  public_total_closet_value: order_by
  updated_at: order_by
  use_dark_mode: order_by
  use_vacation_mode: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: user_preferences"""
input user_preferences_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_preferences"
"""
enum user_preferences_select_column {
  """column name"""
  block_private_bids

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  language_code

  """column name"""
  only_accept_size_match

  """column name"""
  only_accept_wishlist_match

  """column name"""
  public_total_closet_value

  """column name"""
  updated_at

  """column name"""
  use_dark_mode

  """column name"""
  use_vacation_mode

  """column name"""
  user_id
}

"""
input type for updating data in table "user_preferences"
"""
input user_preferences_set_input {
  block_private_bids: Boolean
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  language_code: String
  only_accept_size_match: Boolean
  only_accept_wishlist_match: Boolean
  public_total_closet_value: Boolean
  updated_at: timestamptz
  use_dark_mode: Boolean
  use_vacation_mode: Boolean
  user_id: uuid
}

"""aggregate stddev on columns"""
type user_preferences_stddev_fields {
  deleted_at: Float
}

"""aggregate stddev_pop on columns"""
type user_preferences_stddev_pop_fields {
  deleted_at: Float
}

"""aggregate stddev_samp on columns"""
type user_preferences_stddev_samp_fields {
  deleted_at: Float
}

"""
Streaming cursor of the table "user_preferences"
"""
input user_preferences_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_preferences_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_preferences_stream_cursor_value_input {
  block_private_bids: Boolean
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  language_code: String
  only_accept_size_match: Boolean
  only_accept_wishlist_match: Boolean
  public_total_closet_value: Boolean
  updated_at: timestamptz
  use_dark_mode: Boolean
  use_vacation_mode: Boolean
  user_id: uuid
}

"""aggregate sum on columns"""
type user_preferences_sum_fields {
  deleted_at: Int
}

"""
update columns of table "user_preferences"
"""
enum user_preferences_update_column {
  """column name"""
  block_private_bids

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  language_code

  """column name"""
  only_accept_size_match

  """column name"""
  only_accept_wishlist_match

  """column name"""
  public_total_closet_value

  """column name"""
  updated_at

  """column name"""
  use_dark_mode

  """column name"""
  use_vacation_mode

  """column name"""
  user_id
}

input user_preferences_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_preferences_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_preferences_set_input

  """filter the rows which have to be updated"""
  where: user_preferences_bool_exp!
}

"""aggregate var_pop on columns"""
type user_preferences_var_pop_fields {
  deleted_at: Float
}

"""aggregate var_samp on columns"""
type user_preferences_var_samp_fields {
  deleted_at: Float
}

"""aggregate variance on columns"""
type user_preferences_variance_fields {
  deleted_at: Float
}

"""External and internal users."""
type users {
  """An array relationship"""
  addresses(
    """distinct select on columns"""
    distinct_on: [addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [addresses_order_by!]

    """filter the rows returned"""
    where: addresses_bool_exp
  ): [addresses!]!

  """An aggregate relationship"""
  addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [addresses_order_by!]

    """filter the rows returned"""
    where: addresses_bool_exp
  ): addresses_aggregate!

  """An object relationship"""
  avatar: files
  avatar_id: uuid
  bio: String
  birthday: date

  """An array relationship"""
  blocked(
    """distinct select on columns"""
    distinct_on: [blocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blocks_order_by!]

    """filter the rows returned"""
    where: blocks_bool_exp
  ): [blocks!]!

  """An aggregate relationship"""
  blocked_aggregate(
    """distinct select on columns"""
    distinct_on: [blocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blocks_order_by!]

    """filter the rows returned"""
    where: blocks_bool_exp
  ): blocks_aggregate!
  closet_value: Int!
  completed_buys_count: Int!
  completed_sells_count: Int!
  completed_trades_count: Int!
  created_at: timestamptz!
  deleted_at: Int!

  """An array relationship"""
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """An aggregate relationship"""
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!
  email: String
  first_name: String

  """An array relationship"""
  followers(
    """distinct select on columns"""
    distinct_on: [follows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [follows_order_by!]

    """filter the rows returned"""
    where: follows_bool_exp
  ): [follows!]!

  """An aggregate relationship"""
  followers_aggregate(
    """distinct select on columns"""
    distinct_on: [follows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [follows_order_by!]

    """filter the rows returned"""
    where: follows_bool_exp
  ): follows_aggregate!

  """An array relationship"""
  following(
    """distinct select on columns"""
    distinct_on: [follows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [follows_order_by!]

    """filter the rows returned"""
    where: follows_bool_exp
  ): [follows!]!

  """An aggregate relationship"""
  following_aggregate(
    """distinct select on columns"""
    distinct_on: [follows_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [follows_order_by!]

    """filter the rows returned"""
    where: follows_bool_exp
  ): follows_aggregate!
  id: uuid!
  instagram_handle: String

  """An array relationship"""
  inventory(
    """distinct select on columns"""
    distinct_on: [inventory_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_items_order_by!]

    """filter the rows returned"""
    where: inventory_items_bool_exp
  ): [inventory_items!]!

  """An aggregate relationship"""
  inventory_aggregate(
    """distinct select on columns"""
    distinct_on: [inventory_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inventory_items_order_by!]

    """filter the rows returned"""
    where: inventory_items_bool_exp
  ): inventory_items_aggregate!
  is_trusted_trader: Boolean!
  is_verified: Boolean!
  last_name: String
  legacy_user_id: bpchar

  """An array relationship"""
  march_mania_brackets(
    """distinct select on columns"""
    distinct_on: [march_mania_bracket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [march_mania_bracket_order_by!]

    """filter the rows returned"""
    where: march_mania_bracket_bool_exp
  ): [march_mania_bracket!]!

  """An aggregate relationship"""
  march_mania_brackets_aggregate(
    """distinct select on columns"""
    distinct_on: [march_mania_bracket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [march_mania_bracket_order_by!]

    """filter the rows returned"""
    where: march_mania_bracket_bool_exp
  ): march_mania_bracket_aggregate!
  phone_number: String

  """An array relationship"""
  reported(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """An aggregate relationship"""
  reported_aggregate(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): reports_aggregate!
  update_index: Boolean!
  updated_at: timestamptz!

  """An object relationship"""
  user_activity: user_activities

  """An object relationship"""
  user_admin_information: user_admin_informations

  """An array relationship"""
  user_badges(
    """distinct select on columns"""
    distinct_on: [user_badges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_badges_order_by!]

    """filter the rows returned"""
    where: user_badges_bool_exp
  ): [user_badges!]!

  """An aggregate relationship"""
  user_badges_aggregate(
    """distinct select on columns"""
    distinct_on: [user_badges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_badges_order_by!]

    """filter the rows returned"""
    where: user_badges_bool_exp
  ): user_badges_aggregate!

  """An array relationship"""
  user_notifications(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): [user_notifications!]!

  """An aggregate relationship"""
  user_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): user_notifications_aggregate!

  """An object relationship"""
  user_preference: user_preferences
  username: String

  """An array relationship"""
  wishlist(
    """distinct select on columns"""
    distinct_on: [wishlist_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlist_items_order_by!]

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): [wishlist_items!]!

  """An aggregate relationship"""
  wishlist_aggregate(
    """distinct select on columns"""
    distinct_on: [wishlist_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wishlist_items_order_by!]

    """filter the rows returned"""
    where: wishlist_items_bool_exp
  ): wishlist_items_aggregate!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  avg: users_avg_fields
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
  stddev: users_stddev_fields
  stddev_pop: users_stddev_pop_fields
  stddev_samp: users_stddev_samp_fields
  sum: users_sum_fields
  var_pop: users_var_pop_fields
  var_samp: users_var_samp_fields
  variance: users_variance_fields
}

"""aggregate avg on columns"""
type users_avg_fields {
  closet_value: Float
  completed_buys_count: Float
  completed_sells_count: Float
  completed_trades_count: Float
  deleted_at: Float
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  addresses: addresses_bool_exp
  addresses_aggregate: addresses_aggregate_bool_exp
  avatar: files_bool_exp
  avatar_id: uuid_comparison_exp
  bio: String_comparison_exp
  birthday: date_comparison_exp
  blocked: blocks_bool_exp
  blocked_aggregate: blocks_aggregate_bool_exp
  closet_value: Int_comparison_exp
  completed_buys_count: Int_comparison_exp
  completed_sells_count: Int_comparison_exp
  completed_trades_count: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  devices: devices_bool_exp
  devices_aggregate: devices_aggregate_bool_exp
  email: String_comparison_exp
  first_name: String_comparison_exp
  followers: follows_bool_exp
  followers_aggregate: follows_aggregate_bool_exp
  following: follows_bool_exp
  following_aggregate: follows_aggregate_bool_exp
  id: uuid_comparison_exp
  instagram_handle: String_comparison_exp
  inventory: inventory_items_bool_exp
  inventory_aggregate: inventory_items_aggregate_bool_exp
  is_trusted_trader: Boolean_comparison_exp
  is_verified: Boolean_comparison_exp
  last_name: String_comparison_exp
  legacy_user_id: bpchar_comparison_exp
  march_mania_brackets: march_mania_bracket_bool_exp
  march_mania_brackets_aggregate: march_mania_bracket_aggregate_bool_exp
  phone_number: String_comparison_exp
  reported: reports_bool_exp
  reported_aggregate: reports_aggregate_bool_exp
  update_index: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_activity: user_activities_bool_exp
  user_admin_information: user_admin_informations_bool_exp
  user_badges: user_badges_bool_exp
  user_badges_aggregate: user_badges_aggregate_bool_exp
  user_notifications: user_notifications_bool_exp
  user_notifications_aggregate: user_notifications_aggregate_bool_exp
  user_preference: user_preferences_bool_exp
  username: String_comparison_exp
  wishlist: wishlist_items_bool_exp
  wishlist_aggregate: wishlist_items_aggregate_bool_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "avatar_id"
  """
  users_avatar_id_key

  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "legacy_user_id"
  """
  users_legacy_user_id_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey

  """
  unique or primary key constraint on columns "username"
  """
  users_username_key
}

"""
input type for incrementing numeric columns in table "users"
"""
input users_inc_input {
  closet_value: Int
  completed_buys_count: Int
  completed_sells_count: Int
  completed_trades_count: Int
  deleted_at: Int
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  addresses: addresses_arr_rel_insert_input
  avatar: files_obj_rel_insert_input
  avatar_id: uuid
  bio: String
  birthday: date
  blocked: blocks_arr_rel_insert_input
  closet_value: Int
  completed_buys_count: Int
  completed_sells_count: Int
  completed_trades_count: Int
  created_at: timestamptz
  deleted_at: Int
  devices: devices_arr_rel_insert_input
  email: String
  first_name: String
  followers: follows_arr_rel_insert_input
  following: follows_arr_rel_insert_input
  id: uuid
  instagram_handle: String
  inventory: inventory_items_arr_rel_insert_input
  is_trusted_trader: Boolean
  is_verified: Boolean
  last_name: String
  legacy_user_id: bpchar
  march_mania_brackets: march_mania_bracket_arr_rel_insert_input
  phone_number: String
  reported: reports_arr_rel_insert_input
  update_index: Boolean
  updated_at: timestamptz
  user_activity: user_activities_obj_rel_insert_input
  user_admin_information: user_admin_informations_obj_rel_insert_input
  user_badges: user_badges_arr_rel_insert_input
  user_notifications: user_notifications_arr_rel_insert_input
  user_preference: user_preferences_obj_rel_insert_input
  username: String
  wishlist: wishlist_items_arr_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  avatar_id: uuid
  bio: String
  birthday: date
  closet_value: Int
  completed_buys_count: Int
  completed_sells_count: Int
  completed_trades_count: Int
  created_at: timestamptz
  deleted_at: Int
  email: String
  first_name: String
  id: uuid
  instagram_handle: String
  last_name: String
  legacy_user_id: bpchar
  phone_number: String
  updated_at: timestamptz
  username: String
}

"""aggregate min on columns"""
type users_min_fields {
  avatar_id: uuid
  bio: String
  birthday: date
  closet_value: Int
  completed_buys_count: Int
  completed_sells_count: Int
  completed_trades_count: Int
  created_at: timestamptz
  deleted_at: Int
  email: String
  first_name: String
  id: uuid
  instagram_handle: String
  last_name: String
  legacy_user_id: bpchar
  phone_number: String
  updated_at: timestamptz
  username: String
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "users"."""
input users_order_by {
  addresses_aggregate: addresses_aggregate_order_by
  avatar: files_order_by
  avatar_id: order_by
  bio: order_by
  birthday: order_by
  blocked_aggregate: blocks_aggregate_order_by
  closet_value: order_by
  completed_buys_count: order_by
  completed_sells_count: order_by
  completed_trades_count: order_by
  created_at: order_by
  deleted_at: order_by
  devices_aggregate: devices_aggregate_order_by
  email: order_by
  first_name: order_by
  followers_aggregate: follows_aggregate_order_by
  following_aggregate: follows_aggregate_order_by
  id: order_by
  instagram_handle: order_by
  inventory_aggregate: inventory_items_aggregate_order_by
  is_trusted_trader: order_by
  is_verified: order_by
  last_name: order_by
  legacy_user_id: order_by
  march_mania_brackets_aggregate: march_mania_bracket_aggregate_order_by
  phone_number: order_by
  reported_aggregate: reports_aggregate_order_by
  update_index: order_by
  updated_at: order_by
  user_activity: user_activities_order_by
  user_admin_information: user_admin_informations_order_by
  user_badges_aggregate: user_badges_aggregate_order_by
  user_notifications_aggregate: user_notifications_aggregate_order_by
  user_preference: user_preferences_order_by
  username: order_by
  wishlist_aggregate: wishlist_items_aggregate_order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  id: uuid!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  avatar_id

  """column name"""
  bio

  """column name"""
  birthday

  """column name"""
  closet_value

  """column name"""
  completed_buys_count

  """column name"""
  completed_sells_count

  """column name"""
  completed_trades_count

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  instagram_handle

  """column name"""
  is_trusted_trader

  """column name"""
  is_verified

  """column name"""
  last_name

  """column name"""
  legacy_user_id

  """column name"""
  phone_number

  """column name"""
  update_index

  """column name"""
  updated_at

  """column name"""
  username
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  avatar_id: uuid
  bio: String
  birthday: date
  closet_value: Int
  completed_buys_count: Int
  completed_sells_count: Int
  completed_trades_count: Int
  created_at: timestamptz
  deleted_at: Int
  email: String
  first_name: String
  id: uuid
  instagram_handle: String
  is_trusted_trader: Boolean
  is_verified: Boolean
  last_name: String
  legacy_user_id: bpchar
  phone_number: String
  update_index: Boolean
  updated_at: timestamptz
  username: String
}

"""aggregate stddev on columns"""
type users_stddev_fields {
  closet_value: Float
  completed_buys_count: Float
  completed_sells_count: Float
  completed_trades_count: Float
  deleted_at: Float
}

"""aggregate stddev_pop on columns"""
type users_stddev_pop_fields {
  closet_value: Float
  completed_buys_count: Float
  completed_sells_count: Float
  completed_trades_count: Float
  deleted_at: Float
}

"""aggregate stddev_samp on columns"""
type users_stddev_samp_fields {
  closet_value: Float
  completed_buys_count: Float
  completed_sells_count: Float
  completed_trades_count: Float
  deleted_at: Float
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  avatar_id: uuid
  bio: String
  birthday: date
  closet_value: Int
  completed_buys_count: Int
  completed_sells_count: Int
  completed_trades_count: Int
  created_at: timestamptz
  deleted_at: Int
  email: String
  first_name: String
  id: uuid
  instagram_handle: String
  is_trusted_trader: Boolean
  is_verified: Boolean
  last_name: String
  legacy_user_id: bpchar
  phone_number: String
  update_index: Boolean
  updated_at: timestamptz
  username: String
}

"""aggregate sum on columns"""
type users_sum_fields {
  closet_value: Int
  completed_buys_count: Int
  completed_sells_count: Int
  completed_trades_count: Int
  deleted_at: Int
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  avatar_id

  """column name"""
  bio

  """column name"""
  birthday

  """column name"""
  closet_value

  """column name"""
  completed_buys_count

  """column name"""
  completed_sells_count

  """column name"""
  completed_trades_count

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  instagram_handle

  """column name"""
  is_trusted_trader

  """column name"""
  is_verified

  """column name"""
  last_name

  """column name"""
  legacy_user_id

  """column name"""
  phone_number

  """column name"""
  update_index

  """column name"""
  updated_at

  """column name"""
  username
}

input users_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: users_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

"""aggregate var_pop on columns"""
type users_var_pop_fields {
  closet_value: Float
  completed_buys_count: Float
  completed_sells_count: Float
  completed_trades_count: Float
  deleted_at: Float
}

"""aggregate var_samp on columns"""
type users_var_samp_fields {
  closet_value: Float
  completed_buys_count: Float
  completed_sells_count: Float
  completed_trades_count: Float
  deleted_at: Float
}

"""aggregate variance on columns"""
type users_variance_fields {
  closet_value: Float
  completed_buys_count: Float
  completed_sells_count: Float
  completed_trades_count: Float
  deleted_at: Float
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "validators"
"""
type validators {
  created_at: timestamptz!
  deleted_at: Int!
  email: String!
  id: uuid!
  phone_number: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "validators"
"""
type validators_aggregate {
  aggregate: validators_aggregate_fields
  nodes: [validators!]!
}

"""
aggregate fields of "validators"
"""
type validators_aggregate_fields {
  avg: validators_avg_fields
  count(columns: [validators_select_column!], distinct: Boolean): Int!
  max: validators_max_fields
  min: validators_min_fields
  stddev: validators_stddev_fields
  stddev_pop: validators_stddev_pop_fields
  stddev_samp: validators_stddev_samp_fields
  sum: validators_sum_fields
  var_pop: validators_var_pop_fields
  var_samp: validators_var_samp_fields
  variance: validators_variance_fields
}

"""aggregate avg on columns"""
type validators_avg_fields {
  deleted_at: Float
}

"""
Boolean expression to filter rows from the table "validators". All fields are combined with a logical 'AND'.
"""
input validators_bool_exp {
  _and: [validators_bool_exp!]
  _not: validators_bool_exp
  _or: [validators_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  phone_number: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "validators"
"""
enum validators_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  validators_email_key

  """
  unique or primary key constraint on columns "id"
  """
  validators_pkey
}

"""
input type for incrementing numeric columns in table "validators"
"""
input validators_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "validators"
"""
input validators_insert_input {
  created_at: timestamptz
  deleted_at: Int
  email: String
  id: uuid
  phone_number: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type validators_max_fields {
  created_at: timestamptz
  deleted_at: Int
  email: String
  id: uuid
  phone_number: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type validators_min_fields {
  created_at: timestamptz
  deleted_at: Int
  email: String
  id: uuid
  phone_number: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "validators"
"""
type validators_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [validators!]!
}

"""
input type for inserting object relation for remote table "validators"
"""
input validators_obj_rel_insert_input {
  data: validators_insert_input!

  """upsert condition"""
  on_conflict: validators_on_conflict
}

"""
on_conflict condition type for table "validators"
"""
input validators_on_conflict {
  constraint: validators_constraint!
  update_columns: [validators_update_column!]! = []
  where: validators_bool_exp
}

"""Ordering options when selecting data from "validators"."""
input validators_order_by {
  created_at: order_by
  deleted_at: order_by
  email: order_by
  id: order_by
  phone_number: order_by
  updated_at: order_by
}

"""primary key columns input for table: validators"""
input validators_pk_columns_input {
  id: uuid!
}

"""
select columns of table "validators"
"""
enum validators_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  phone_number

  """column name"""
  updated_at
}

"""
input type for updating data in table "validators"
"""
input validators_set_input {
  created_at: timestamptz
  deleted_at: Int
  email: String
  id: uuid
  phone_number: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type validators_stddev_fields {
  deleted_at: Float
}

"""aggregate stddev_pop on columns"""
type validators_stddev_pop_fields {
  deleted_at: Float
}

"""aggregate stddev_samp on columns"""
type validators_stddev_samp_fields {
  deleted_at: Float
}

"""
Streaming cursor of the table "validators"
"""
input validators_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: validators_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input validators_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: Int
  email: String
  id: uuid
  phone_number: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type validators_sum_fields {
  deleted_at: Int
}

"""
update columns of table "validators"
"""
enum validators_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  phone_number

  """column name"""
  updated_at
}

input validators_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: validators_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: validators_set_input

  """filter the rows which have to be updated"""
  where: validators_bool_exp!
}

"""aggregate var_pop on columns"""
type validators_var_pop_fields {
  deleted_at: Float
}

"""aggregate var_samp on columns"""
type validators_var_samp_fields {
  deleted_at: Float
}

"""aggregate variance on columns"""
type validators_variance_fields {
  deleted_at: Float
}

"""Products a user has added to their wishlist."""
type wishlist_items {
  """An array relationship"""
  attribute_selections(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): [attribute_selections!]!

  """An aggregate relationship"""
  attribute_selections_aggregate(
    """distinct select on columns"""
    distinct_on: [attribute_selections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attribute_selections_order_by!]

    """filter the rows returned"""
    where: attribute_selections_bool_exp
  ): attribute_selections_aggregate!
  created_at: timestamptz!
  deleted_at: Int!
  id: uuid!
  index_cache(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  product_variant: product_variants!
  product_variant_id: uuid!
  update_index: Boolean!
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "wishlist_items"
"""
type wishlist_items_aggregate {
  aggregate: wishlist_items_aggregate_fields
  nodes: [wishlist_items!]!
}

input wishlist_items_aggregate_bool_exp {
  bool_and: wishlist_items_aggregate_bool_exp_bool_and
  bool_or: wishlist_items_aggregate_bool_exp_bool_or
  count: wishlist_items_aggregate_bool_exp_count
}

input wishlist_items_aggregate_bool_exp_bool_and {
  arguments: wishlist_items_select_column_wishlist_items_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: wishlist_items_bool_exp
  predicate: Boolean_comparison_exp!
}

input wishlist_items_aggregate_bool_exp_bool_or {
  arguments: wishlist_items_select_column_wishlist_items_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: wishlist_items_bool_exp
  predicate: Boolean_comparison_exp!
}

input wishlist_items_aggregate_bool_exp_count {
  arguments: [wishlist_items_select_column!]
  distinct: Boolean
  filter: wishlist_items_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "wishlist_items"
"""
type wishlist_items_aggregate_fields {
  avg: wishlist_items_avg_fields
  count(columns: [wishlist_items_select_column!], distinct: Boolean): Int!
  max: wishlist_items_max_fields
  min: wishlist_items_min_fields
  stddev: wishlist_items_stddev_fields
  stddev_pop: wishlist_items_stddev_pop_fields
  stddev_samp: wishlist_items_stddev_samp_fields
  sum: wishlist_items_sum_fields
  var_pop: wishlist_items_var_pop_fields
  var_samp: wishlist_items_var_samp_fields
  variance: wishlist_items_variance_fields
}

"""
order by aggregate values of table "wishlist_items"
"""
input wishlist_items_aggregate_order_by {
  avg: wishlist_items_avg_order_by
  count: order_by
  max: wishlist_items_max_order_by
  min: wishlist_items_min_order_by
  stddev: wishlist_items_stddev_order_by
  stddev_pop: wishlist_items_stddev_pop_order_by
  stddev_samp: wishlist_items_stddev_samp_order_by
  sum: wishlist_items_sum_order_by
  var_pop: wishlist_items_var_pop_order_by
  var_samp: wishlist_items_var_samp_order_by
  variance: wishlist_items_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input wishlist_items_append_input {
  index_cache: jsonb
}

"""
input type for inserting array relation for remote table "wishlist_items"
"""
input wishlist_items_arr_rel_insert_input {
  data: [wishlist_items_insert_input!]!

  """upsert condition"""
  on_conflict: wishlist_items_on_conflict
}

"""aggregate avg on columns"""
type wishlist_items_avg_fields {
  deleted_at: Float
}

"""
order by avg() on columns of table "wishlist_items"
"""
input wishlist_items_avg_order_by {
  deleted_at: order_by
}

"""
Boolean expression to filter rows from the table "wishlist_items". All fields are combined with a logical 'AND'.
"""
input wishlist_items_bool_exp {
  _and: [wishlist_items_bool_exp!]
  _not: wishlist_items_bool_exp
  _or: [wishlist_items_bool_exp!]
  attribute_selections: attribute_selections_bool_exp
  attribute_selections_aggregate: attribute_selections_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  deleted_at: Int_comparison_exp
  id: uuid_comparison_exp
  index_cache: jsonb_comparison_exp
  product_variant: product_variants_bool_exp
  product_variant_id: uuid_comparison_exp
  update_index: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "wishlist_items"
"""
enum wishlist_items_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  wishlist_items_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input wishlist_items_delete_at_path_input {
  index_cache: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input wishlist_items_delete_elem_input {
  index_cache: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input wishlist_items_delete_key_input {
  index_cache: String
}

"""
input type for incrementing numeric columns in table "wishlist_items"
"""
input wishlist_items_inc_input {
  deleted_at: Int
}

"""
input type for inserting data into table "wishlist_items"
"""
input wishlist_items_insert_input {
  attribute_selections: attribute_selections_arr_rel_insert_input
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  index_cache: jsonb
  product_variant: product_variants_obj_rel_insert_input
  product_variant_id: uuid
  update_index: Boolean
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type wishlist_items_max_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  product_variant_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "wishlist_items"
"""
input wishlist_items_max_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  product_variant_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type wishlist_items_min_fields {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  product_variant_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "wishlist_items"
"""
input wishlist_items_min_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  product_variant_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "wishlist_items"
"""
type wishlist_items_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [wishlist_items!]!
}

"""
input type for inserting object relation for remote table "wishlist_items"
"""
input wishlist_items_obj_rel_insert_input {
  data: wishlist_items_insert_input!

  """upsert condition"""
  on_conflict: wishlist_items_on_conflict
}

"""
on_conflict condition type for table "wishlist_items"
"""
input wishlist_items_on_conflict {
  constraint: wishlist_items_constraint!
  update_columns: [wishlist_items_update_column!]! = []
  where: wishlist_items_bool_exp
}

"""Ordering options when selecting data from "wishlist_items"."""
input wishlist_items_order_by {
  attribute_selections_aggregate: attribute_selections_aggregate_order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  index_cache: order_by
  product_variant: product_variants_order_by
  product_variant_id: order_by
  update_index: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: wishlist_items"""
input wishlist_items_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input wishlist_items_prepend_input {
  index_cache: jsonb
}

"""
select columns of table "wishlist_items"
"""
enum wishlist_items_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  index_cache

  """column name"""
  product_variant_id

  """column name"""
  update_index

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
select "wishlist_items_aggregate_bool_exp_bool_and_arguments_columns" columns of table "wishlist_items"
"""
enum wishlist_items_select_column_wishlist_items_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  update_index
}

"""
select "wishlist_items_aggregate_bool_exp_bool_or_arguments_columns" columns of table "wishlist_items"
"""
enum wishlist_items_select_column_wishlist_items_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  update_index
}

"""
input type for updating data in table "wishlist_items"
"""
input wishlist_items_set_input {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  index_cache: jsonb
  product_variant_id: uuid
  update_index: Boolean
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type wishlist_items_stddev_fields {
  deleted_at: Float
}

"""
order by stddev() on columns of table "wishlist_items"
"""
input wishlist_items_stddev_order_by {
  deleted_at: order_by
}

"""aggregate stddev_pop on columns"""
type wishlist_items_stddev_pop_fields {
  deleted_at: Float
}

"""
order by stddev_pop() on columns of table "wishlist_items"
"""
input wishlist_items_stddev_pop_order_by {
  deleted_at: order_by
}

"""aggregate stddev_samp on columns"""
type wishlist_items_stddev_samp_fields {
  deleted_at: Float
}

"""
order by stddev_samp() on columns of table "wishlist_items"
"""
input wishlist_items_stddev_samp_order_by {
  deleted_at: order_by
}

"""
Streaming cursor of the table "wishlist_items"
"""
input wishlist_items_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: wishlist_items_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input wishlist_items_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: Int
  id: uuid
  index_cache: jsonb
  product_variant_id: uuid
  update_index: Boolean
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate sum on columns"""
type wishlist_items_sum_fields {
  deleted_at: Int
}

"""
order by sum() on columns of table "wishlist_items"
"""
input wishlist_items_sum_order_by {
  deleted_at: order_by
}

"""
update columns of table "wishlist_items"
"""
enum wishlist_items_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  index_cache

  """column name"""
  product_variant_id

  """column name"""
  update_index

  """column name"""
  updated_at

  """column name"""
  user_id
}

input wishlist_items_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: wishlist_items_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: wishlist_items_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: wishlist_items_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: wishlist_items_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: wishlist_items_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: wishlist_items_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: wishlist_items_set_input

  """filter the rows which have to be updated"""
  where: wishlist_items_bool_exp!
}

"""aggregate var_pop on columns"""
type wishlist_items_var_pop_fields {
  deleted_at: Float
}

"""
order by var_pop() on columns of table "wishlist_items"
"""
input wishlist_items_var_pop_order_by {
  deleted_at: order_by
}

"""aggregate var_samp on columns"""
type wishlist_items_var_samp_fields {
  deleted_at: Float
}

"""
order by var_samp() on columns of table "wishlist_items"
"""
input wishlist_items_var_samp_order_by {
  deleted_at: order_by
}

"""aggregate variance on columns"""
type wishlist_items_variance_fields {
  deleted_at: Float
}

"""
order by variance() on columns of table "wishlist_items"
"""
input wishlist_items_variance_order_by {
  deleted_at: order_by
}
